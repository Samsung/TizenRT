/*
 * Copyright (c) 2021-2022, Arm Limited. All rights reserved.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *
 */

#include "bl1_1_crypto_tests.h"

#include <stdint.h>
#include <stdlib.h>
#include <stddef.h>
#include <string.h>

#include "test_framework_helpers.h"
#include "crypto.h"

#define SHA256_LEN 32

uint8_t tfm_bl1_key_test_1_buf[32] = {
    0x01, 0x23, 0x45, 0x67, 0x89, 0x01, 0x23, 0x45, 0x67, 0x89, 0x01, 0x23,
    0x45, 0x67, 0x89, 0x01, 0x23, 0x45, 0x67, 0x89, 0x01, 0x23, 0x45, 0x67,
    0x89, 0x01, 0x23, 0x45, 0x67, 0x89, 0x01, 0x23, };
uint8_t tfm_bl1_key_test_2_buf[32] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, };

struct sha256_test_vector_t {
    char*   message;
    size_t  len;
    uint8_t hash[SHA256_LEN];
};


static void sha256_vector_test(struct test_result_t *ret,
                               const struct sha256_test_vector_t *vecs,
                               size_t vec_am)
{
    size_t vec_idx;
    uint8_t hash_out[SHA256_LEN];
    fih_int fih_rc;

    for (vec_idx = 0; vec_idx < vec_am; vec_idx++) {
        TEST_LOG("  > Vector %d of %d\r", vec_idx + 1, vec_am);
        const struct sha256_test_vector_t * const vec = vecs + vec_idx;
        fih_rc = bl1_sha256_compute((const uint8_t *)vec->message, vec->len, hash_out);
        if (fih_not_eq(fih_rc, FIH_SUCCESS)) {
            TEST_FAIL("\nHash function returned error");
            return;
        }
        if (memcmp(hash_out, vec->hash, SHA256_LEN)) {
            TEST_FAIL("\nVector comparison failed");
            return;
        }
    }

    ret->val = TEST_PASSED;
    return;
}

static const struct sha256_test_vector_t test_2001_vectors[] = {
    {
        "abc",
        3,
        {0xba, 0x78, 0x16, 0xbf, 0x8f, 0x01, 0xcf, 0xea, 0x41, 0x41, 0x40, 0xde,
         0x5d, 0xae, 0x22, 0x23, 0xb0, 0x03, 0x61, 0xa3, 0x96, 0x17, 0x7a,
         0x9c, 0xb4, 0x10, 0xff, 0x61, 0xf2, 0x00, 0x15, 0xad, },
    },
    {
        "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq",
        56,
        {0x24, 0x8d, 0x6a, 0x61, 0xd2, 0x06, 0x38, 0xb8, 0xe5, 0xc0, 0x26, 0x93,
         0x0c, 0x3e, 0x60, 0x39, 0xa3, 0x3c, 0xe4, 0x59, 0x64, 0xff, 0x21,
         0x67, 0xf6, 0xec, 0xed, 0xd4, 0x19, 0xdb, 0x06, 0xc1, },
    },
    {
        (char *)((uint8_t[]){0xd3}),
        1,
        {0x28, 0x96, 0x9c, 0xdf, 0xa7, 0x4a, 0x12, 0xc8, 0x2f, 0x3b, 0xad, 0x96,
         0x0b, 0x0b, 0x00, 0x0a, 0xca, 0x2a, 0xc3, 0x29, 0xde, 0xea, 0x5c,
         0x23, 0x28, 0xeb, 0xc6, 0xf2, 0xba, 0x98, 0x02, 0xc1, },
    },
    {
        (char *)((uint8_t[]){0x11, 0xaf}),
        2,
        {0x5c, 0xa7, 0x13, 0x3f, 0xa7, 0x35, 0x32, 0x60, 0x81, 0x55, 0x8a, 0xc3,
         0x12, 0xc6, 0x20, 0xee, 0xca, 0x99, 0x70, 0xd1, 0xe7, 0x0a, 0x4b,
         0x95, 0x53, 0x3d, 0x95, 0x6f, 0x07, 0x2d, 0x1f, 0x98, },
    },
    {
        (char *)((uint8_t[]){0x74, 0xba, 0x25, 0x21}),
        4,
        {0xb1, 0x6a, 0xa5, 0x6b, 0xe3, 0x88, 0x0d, 0x18, 0xcd, 0x41, 0xe6, 0x83,
         0x84, 0xcf, 0x1e, 0xc8, 0xc1, 0x76, 0x80, 0xc4, 0x5a, 0x02, 0xb1,
         0x57, 0x5d, 0xc1, 0x51, 0x89, 0x23, 0xae, 0x8b, 0x0e, },
    },
    {
        (char *)((uint8_t[])
        {0x5a, 0x86, 0xb7, 0x37, 0xea, 0xea, 0x8e, 0xe9, 0x76, 0xa0, 0xa2, 0x4d,
        0xa6, 0x3e, 0x7e, 0xd7, 0xee, 0xfa, 0xd1, 0x8a, 0x10, 0x1c, 0x12, 0x11,
        0xe2, 0xb3, 0x65, 0x0c, 0x51, 0x87, 0xc2, 0xa8, 0xa6, 0x50, 0x54, 0x72,
        0x08, 0x25, 0x1f, 0x6d, 0x42, 0x37, 0xe6, 0x61, 0xc7, 0xbf, 0x4c, 0x77,
        0xf3, 0x35, 0x39, 0x03, 0x94, 0xc3, 0x7f, 0xa1, 0xa9, 0xf9, 0xbe, 0x83,
        0x6a, 0xc2, 0x85, 0x09, }),
        64,
        {0x42, 0xe6, 0x1e, 0x17, 0x4f, 0xbb, 0x38, 0x97, 0xd6, 0xdd, 0x6c, 0xef,
         0x3d, 0xd2, 0x80, 0x2f, 0xe6, 0x7b, 0x33, 0x19, 0x53, 0xb0, 0x61,
         0x14, 0xa6, 0x5c, 0x77, 0x28, 0x59, 0xdf, 0xc1, 0xaa, },
    },
    {
        (char *)((uint8_t[])
        {0x03, 0xb2, 0x64, 0xbe, 0x51, 0xe4, 0xb9, 0x41, 0x86, 0x4f, 0x9b, 0x70,
         0xb4, 0xc9, 0x58, 0xf5, 0x35, 0x5a, 0xac, 0x29, 0x4b, 0x4b, 0x87, 0xcb,
         0x03, 0x7f, 0x11, 0xf8, 0x5f, 0x07, 0xeb, 0x57, 0xb3, 0xf0, 0xb8, 0x95,
         0x50, }),
        37,
        {0xd1, 0xf8, 0xbd, 0x68, 0x40, 0x01, 0xac, 0x5a, 0x4b, 0x67, 0xbb, 0xf7,
         0x9f, 0x87, 0xde, 0x52, 0x4d, 0x2d, 0xa9, 0x9a, 0xc0, 0x14, 0xde,
         0xc3, 0xe4, 0x18, 0x77, 0x28, 0xf4, 0x55, 0x74, 0x71, },
    },
    {
        (char *)((uint8_t[])
        {0x09, 0xfc, 0x1a, 0xcc, 0xc2, 0x30, 0xa2, 0x05, 0xe4, 0xa2, 0x08, 0xe6,
         0x4a, 0x8f, 0x20, 0x42, 0x91, 0xf5, 0x81, 0xa1, 0x27, 0x56, 0x39, 0x2d,
         0xa4, 0xb8, 0xc0, 0xcf, 0x5e, 0xf0, 0x2b, 0x95, }),
        32,
        {0x4f, 0x44, 0xc1, 0xc7, 0xfb, 0xeb, 0xb6, 0xf9, 0x60, 0x18, 0x29, 0xf3,
         0x89, 0x7b, 0xfd, 0x65, 0x0c, 0x56, 0xfa, 0x07, 0x84, 0x4b, 0xe7,
         0x64, 0x89, 0x07, 0x63, 0x56, 0xac, 0x18, 0x86, 0xa4, },
    },
};

static void tfm_bl1_crypto_test_2001(struct test_result_t *ret)
{
    sha256_vector_test(ret, test_2001_vectors,
                       sizeof(test_2001_vectors) / sizeof(struct sha256_test_vector_t));
    return;
}

static void tfm_bl1_crypto_test_2002(struct test_result_t *ret)
{
    uint8_t hash_out[SHA256_LEN];
    fih_int fih_rc;

    const struct sha256_test_vector_t * const vec = test_2001_vectors;
    fih_rc = bl1_sha256_compute(NULL, vec->len, hash_out);
    if (fih_eq(fih_rc, FIH_SUCCESS)) {
        TEST_FAIL("Hash function returned success");
        return;
    }

    ret->val = TEST_PASSED;
    return;
}

static void tfm_bl1_crypto_test_2003(struct test_result_t *ret)
{
    fih_int fih_rc;

    const struct sha256_test_vector_t * const vec = test_2001_vectors;
    fih_rc = bl1_sha256_compute((const uint8_t *)vec->message, vec->len, NULL);
    if (fih_eq(fih_rc, FIH_SUCCESS)) {
        TEST_FAIL("Hash function returned success");
        return;
    }

    ret->val = TEST_PASSED;
    return;
}

struct aes256_ctr_test_vector_t {
    enum tfm_bl1_key_id_t key_id;
    uint8_t iv[CTR_IV_LEN];
    char*   plaintext;
    size_t  len;
    char*   ciphertext;
};

static void aes_256_vector_test(struct test_result_t *ret,
                                const struct aes256_ctr_test_vector_t *vecs,
                                size_t vec_am)
{
    size_t vec_idx;
    uint8_t *plaintext_out;
    uint8_t counter[CTR_IV_LEN];
    int rc;

    for (vec_idx = 0; vec_idx < vec_am; vec_idx++) {
        TEST_LOG("  > Vector %d of %d\r", vec_idx + 1, vec_am);
        const struct aes256_ctr_test_vector_t * const vec = vecs + vec_idx;

        plaintext_out = malloc(vec->len);
        if (plaintext_out == NULL) {
            TEST_FAIL("\nFailed to allocate memory");
        }

        memcpy(counter, vec->iv, CTR_IV_LEN);

        rc = bl1_aes_256_ctr_decrypt(vec->key_id, counter,
                                     (const uint8_t *)vec->ciphertext,
                                     vec->len, plaintext_out);
        if (rc) {
            free(plaintext_out);
            TEST_FAIL("\nAES operation failed");
            return;
        }

        if (memcmp(plaintext_out, vec->plaintext, vec->len)) {
            TEST_LOG("\n");
            for (int I = 0; I < vec->len; I++) {
                TEST_LOG("%X ", plaintext_out[I]);
            }
            TEST_LOG("\r\n");
            for (int I = 0; I < vec->len; I++) {
                TEST_LOG("%X ", vec->plaintext[I]);
            }
            TEST_LOG("\r\n");
            free(plaintext_out);
            TEST_FAIL("\nVector comparison failed");
            return;
        }

        free(plaintext_out);
    }

    return;
}

static const struct aes256_ctr_test_vector_t test_2011_vectors[] = {
    {
        TFM_BL1_KEY_TEST_1,
        {0x83, 0xc2, 0xee, 0x4b, 0x86, 0x5d, 0x67, 0x7, 0xc8, 0xeb, 0x21, 0xca,
         0x0, 0x0, 0x0, 0x0, },
        (char *)((uint8_t[])
        {0x7b, 0xa6, 0xc0, 0x1a, 0xeb, 0x69, 0xde, 0xf4, 0x18, 0xe3, 0xbe, 0x39,
         0xb1, 0x56, 0xae, 0x26, 0x9a, 0x8c, 0xba, 0x59, 0x91, 0xa9, 0xa7, 0x7f,
         0x4d, 0x1b, 0xac, 0x5f, 0x8b, 0x6, 0x86, 0xb6, 0x2c, 0x51, 0xb5, 0xd4,
         0xaa, 0xcd, 0x96, 0xb8, 0x55, 0xa, 0x61, 0xac, 0xd1, 0xc3, 0x11, 0xc1,
         0x5b, 0x5c, 0x4f, 0xaa, 0xfd, 0xae, 0x86, 0x8c, 0x9d, 0xd, 0xb7, 0xe2,
         0xea, 0x14, 0x8a, 0xc5, 0x1b, 0x9a, 0x89, 0xce, 0x18, 0xa4, 0x75, 0x4a,
         0x44, 0x66, 0x68, 0x3e, 0xae, 0x3a, 0x7, 0xaa, 0x33, 0x73, 0x57, 0xe5,
         0x32, 0xbc, 0xef, 0x34, 0x70, 0xc0, 0x8, 0x71, 0x87, 0x42, 0xbd, 0xa5,
         0x14, 0xd4, 0xbf, 0x68, 0x71, 0xa3, 0x5e, 0x88, 0x22, 0xac, 0xb1, 0x1b,
         0xce, 0x72, 0x39, 0xa4, 0xb5, 0x3c, 0x37, 0xf8, 0xdd, 0xd8, 0x98, 0xae,
         0x63, 0x32, 0x10, 0xd2, 0xa1, 0xa8, 0xaa, 0xa2, }),
        128,
        (char *)((uint8_t[])
        {0x6, 0x2d, 0xa0, 0x45, 0xa, 0x4b, 0x5d, 0xfc, 0xb8, 0x4f, 0xd3, 0x43,
         0x9, 0x2e, 0xd4, 0xcd, 0x4d, 0x63, 0x52, 0x92, 0x9a, 0x60, 0xa8, 0x87,
         0xa3, 0xb3, 0xca, 0x3d, 0xb6, 0x67, 0x1f, 0xcf, 0x7f, 0xa4, 0xfd, 0xf2,
         0x88, 0xd2, 0x87, 0x10, 0xfe, 0xdb, 0x60, 0xba, 0x6e, 0xf7, 0xd8, 0xcd,
         0x17, 0xc3, 0xbd, 0x6a, 0x85, 0xca, 0xdb, 0xb1, 0x74, 0x97, 0xd6, 0xd9,
         0x21, 0x35, 0xc9, 0x70, 0x54, 0xf, 0x5d, 0x36, 0x83, 0x50, 0xf5, 0x41,
         0xdb, 0x32, 0xa0, 0x55, 0x71, 0xef, 0xf1, 0xdf, 0x1f, 0x62, 0xc8, 0x9a,
         0x4b, 0xaa, 0xf3, 0x7f, 0xc9, 0xf9, 0x8f, 0x97, 0xc, 0x4f, 0xbf, 0x97,
         0x4d, 0x4b, 0x2, 0x71, 0x8c, 0x58, 0x29, 0x38, 0x16, 0x5, 0x6b, 0x68,
         0x43, 0x4d, 0x1d, 0xb9, 0xad, 0xf0, 0xb7, 0x6c, 0x6, 0x8c, 0xf2, 0xf1,
         0xd4, 0xa7, 0x1e, 0xde, 0x56, 0x62, 0x4, 0x7e, }),
    },
    {
        TFM_BL1_KEY_TEST_1,
        {0x8, 0xf8, 0x74, 0xab, 0x1, 0xd1, 0x13, 0x87, 0x9, 0x61, 0x51, 0xc6,
         0x0, 0x0, 0x0, 0x0, },
        (char *)((uint8_t[])
        {0xc7, 0x8d, 0xcb, 0xcb, 0xcb, 0xc1, 0x86, 0x54, 0xbf, 0x25, 0x9b, 0x8,
         0x84, 0xf0, 0x64, 0x57, 0x2e, 0x4c, 0x1c, 0xf9, 0xa5, 0xfa, 0xbd, 0xf4,
         0x80, 0x43, 0xc1, 0x34, 0xf0, 0xc5, 0xf8, 0xa7, 0xee, 0xa7, 0xb2, 0xa2,
         0x17, 0x31, 0x3e, 0xa1, 0xaf, 0x5f, 0x8a, 0x7a, 0x44, 0x7a, 0x4a, 0x81,
         0x6f, 0xb8, 0x9e, 0xf4, 0x7d, 0x8b, 0xbb, 0xb5, 0x2f, 0xfe, 0x5d, 0x1d,
         0xdb, 0x8a, 0xc4, 0x8f, 0x6c, 0xfa, 0x12, 0xc8, 0x18, 0xe8, 0xb1, 0x3b,
         0x21, 0x10, 0x68, 0x78, 0xe, 0xc3, 0xc7, 0x4a, 0x91, 0x93, 0xba, 0x7d,
         0xa6, 0x5a, 0xcd, 0xc4, 0x63, 0x3a, 0x24, 0xfa, 0x29, 0x8a, 0xf0, 0x25,
         0xf5, 0xca, 0x52, 0xaa, 0x54, 0x8d, 0xad, 0x86, 0x61, 0x2, 0xcc, 0x6e,
         0x74, 0xea, 0xde, 0x87, 0x4c, 0xa7, 0x1c, 0x6d, 0xa6, 0x7, 0x2, 0x93,
         0x24, 0x4c, 0x72, 0xfd, 0xda, 0xa3, 0x4e, 0x53, }),
        128,
        (char *)((uint8_t[])
        {0x62, 0x12, 0xf4, 0xcd, 0xa5, 0x21, 0x5f, 0x72, 0x1, 0x6b, 0x17, 0xa3,
         0x42, 0xea, 0x9c, 0x8, 0x82, 0xa7, 0xca, 0xb6, 0xaf, 0x5, 0x35, 0x69,
         0x1b, 0x98, 0x64, 0x34, 0x42, 0x1e, 0xb5, 0xf5, 0xe0, 0x50, 0xac, 0xe3,
         0xb2, 0x9d, 0x86, 0xf, 0xd5, 0x17, 0x35, 0x6d, 0x7, 0x8f, 0x74, 0xb0,
         0x5e, 0x5e, 0x3b, 0xbb, 0xcb, 0xa1, 0xbc, 0xbd, 0xa9, 0x62, 0x7, 0xb7,
         0xb2, 0xe8, 0xc1, 0x10, 0xba, 0x33, 0x2a, 0x59, 0x7e, 0x42, 0xf0, 0x29,
         0x43, 0xdc, 0x5e, 0xa0, 0x8b, 0xff, 0xe4, 0xd0, 0x2c, 0xb6, 0xfa, 0x92,
         0xb2, 0x32, 0xa6, 0xea, 0x1a, 0x3, 0x8e, 0x63, 0x47, 0x87, 0xe9, 0x93,
         0x6d, 0x5f, 0x8d, 0x4e, 0x85, 0xb0, 0xc9, 0x0, 0x73, 0x83, 0x25, 0xe2,
         0x6c, 0x46, 0x93, 0xac, 0x8d, 0x73, 0x23, 0x1, 0x37, 0xd0, 0xec, 0x28,
         0xe4, 0xd3, 0x36, 0xe1, 0xf1, 0xd3, 0x79, 0x61, }),
    },
    {
        TFM_BL1_KEY_TEST_1,
        {0xf9, 0xa4, 0x7d, 0xa6, 0x4, 0x90, 0x17, 0xf1, 0x43, 0x2e, 0xd8, 0xdc,
         0x0, 0x0, 0x0, 0x0, },
        (char *)((uint8_t[])
        {0x24, 0xe, 0x30, 0x91, 0x35, 0x46, 0x4c, 0xd4, 0x4f, 0xc6,
         0xaa, 0x24, 0xb5, 0x7a, 0x7f, 0x2e, 0x30, 0xa, 0xea, 0x4d, 0x60,
         0xc2, 0x95, 0x5, 0x33, 0x39, 0x5b, 0x51, 0xd4, 0xd4, 0x25, 0x85,
         0x6, 0x53, 0x22, 0x2a, 0xcb, 0x5a, 0x35, 0x6e, 0x67, 0x99, 0x20,
         0xb7, 0x45, 0xd4, 0x1f, 0xc6, 0xe6, 0xb4, 0x52, 0x61, 0x87,
         0x8c, 0x15, 0xf3, 0x5d, 0xf, 0xf7, 0x5d, 0x97, 0x89, 0x57, 0x43,
         0xba, 0x22, 0x2f, 0x10, 0x9a, 0xea, 0xc0, 0x9, 0x70, 0xe9, 0x1c,
         0xf5, 0x2a, 0xd5, 0xfa, 0x57, 0x97, 0x3f, 0x33, 0x20, 0x6d,
         0x3a, 0xb5, 0xfe, 0xba, 0xf2, 0x4, 0xc0, 0xc5, 0x6e, 0xfa, 0x4e,
         0x24, 0xb, 0xc1, 0xae, 0xda, 0x34, 0xaf, 0x3d, 0x5c, 0x7, 0xbf,
         0x62, 0x6f, 0xfb, 0x8c, 0xf6, 0xca, 0x8a, 0x69, 0xf6, 0x69,
         0x72, 0xe3, 0x9e, 0xc6, 0x1, 0xe6, 0xfe, 0xe8, 0x66, 0xec, 0x46,
         }),
        128,
        (char *)((uint8_t[])
        {0x8d, 0xb, 0xad, 0x13, 0x26, 0x75, 0x35, 0xb1, 0xd6, 0x39, 0xa2, 0x75,
         0x56, 0xd2, 0x1d, 0x73, 0xef, 0x78, 0xed, 0xd0, 0xe, 0x27, 0xb2, 0x90,
         0x26, 0xbd, 0x72, 0x66, 0x9c, 0xab, 0xd, 0xa5, 0x71, 0xe2, 0xf4, 0xca,
         0xf8, 0x74, 0xd9, 0xf3, 0x62, 0xbb, 0xe4, 0xf5, 0xc, 0x63, 0x0, 0x67,
         0x76, 0xa2, 0x40, 0xf0, 0x31, 0x7d, 0x7f, 0x9, 0xcc, 0xff, 0x1e, 0x47,
         0xbf, 0x44, 0xc6, 0x9b, 0xd0, 0xb8, 0x67, 0x74, 0x20, 0x1, 0xf2, 0xdf,
         0xd3, 0xc8, 0x53, 0xa0, 0x67, 0x9c, 0xe9, 0x9c, 0x62, 0x4e, 0xf5, 0x39,
         0x89, 0xca, 0x58, 0x69, 0x98, 0x11, 0x21, 0x1e, 0xc2, 0xc8, 0x14, 0xf5,
         0x50, 0x91, 0x9, 0x5, 0xb6, 0x81, 0x44, 0xa7, 0x2e, 0x1d, 0xf, 0xbb,
         0xf, 0x83, 0x9, 0x77, 0xc9, 0xc8, 0xc4, 0xa4, 0xd8, 0xef, 0xc, 0x7e,
         0x68, 0x3d, 0xa8, 0x91, 0xc5, 0x86, 0xf8, 0x3b, }),
    },
    {
        TFM_BL1_KEY_TEST_1,
        {0xa5, 0x8c, 0xfa, 0xa, 0x42, 0xe0, 0x5d, 0xc4, 0x9d, 0xcc, 0xda, 0xa,
         0x0, 0x0, 0x0, 0x0, },
        (char *)((uint8_t[])
        {0xab, 0xbc, 0x52, 0x9c, 0x32, 0x66, 0x68, 0x2c, 0x30, 0x0, 0xa6, 0x98,
         0xc1, 0x2d, 0xbf, 0x85, 0x2, 0x21, 0x9d, 0x67, 0xfb, 0x3f, 0xed, 0xed,
         0xb1, 0x9a, 0x3d, 0x95, 0xc5, 0x9f, 0x2a, 0x1, 0xfd, 0xd1, 0x2d, 0xdb,
         0x99, 0x2f, 0xfa, 0x58, 0x27, 0x34, 0x19, 0xf, 0x46, 0xa5, 0x9a, 0xd8,
         0x8, 0x77, 0x95, 0x22, 0x1, 0x9e, 0x39, 0x23, 0xdc, 0xbf, 0xe7, 0x6b,
         0x8b, 0xba, 0x9b, 0xcf, 0xb6, 0xd0, 0x20, 0xef, 0x27, 0x9a, 0xb5, 0x7f,
         0x6c, 0xc3, 0x42, 0x54, 0xf6, 0x9f, 0xc4, 0xa7, 0xcc, 0xb6, 0x5e, 0xea,
         0xb1, 0xca, 0x62, 0x99, 0x79, 0xd4, 0x8c, 0xa3, 0x49, 0x42, 0x77, 0x64,
         0x1c, 0xdc, 0x81, 0xf, 0x4f, 0xb1, 0x24, 0x2, 0x9a, 0x66, 0x1a, 0x2c,
         0x8, 0xe1, 0xd6, 0x7a, 0x1a, 0x7e, 0x92, 0x7, 0x1b, 0x5e, 0x98, 0x5b,
         0x9b, 0x37, 0x66, 0x4c, 0xa5, 0x31, 0xd0, 0x1d, }),
        128,
        (char *)((uint8_t[])
        {0x25, 0x5f, 0xbb, 0xbc, 0x78, 0xa2, 0xf3, 0xbb, 0x7c, 0x73, 0xff, 0x4,
         0x8c, 0x78, 0x9d, 0xc0, 0xbe, 0xbc, 0x58, 0x75, 0x7f, 0x7b, 0x9a, 0x9,
         0xa2, 0x94, 0x42, 0x56, 0x78, 0xe9, 0x7, 0xc4, 0xf1, 0x38, 0x79, 0xec,
         0x2c, 0xbc, 0xcb, 0x7, 0xbc, 0xb3, 0x8f, 0xa1, 0xe8, 0xc7, 0xaf, 0xcd,
         0x1b, 0xad, 0xff, 0x2a, 0x7b, 0xfe, 0x0, 0x7, 0x82, 0xa2, 0x84, 0xb,
         0xa5, 0xd9, 0xa9, 0xd1, 0x41, 0xae, 0x8f, 0x17, 0x34, 0x1a, 0x67, 0xe8,
         0x11, 0x94, 0xb, 0x81, 0xe7, 0xfd, 0x1c, 0x25, 0xbe, 0xd8, 0xcb, 0x63,
         0x6b, 0x62, 0x6a, 0x85, 0x6f, 0x7, 0xac, 0x18, 0xd, 0x1f, 0xd9, 0xcf,
         0x89, 0x18, 0x9f, 0x8f, 0x13, 0xb, 0x86, 0x85, 0xfe, 0x84, 0x5b, 0xe2,
         0x29, 0xed, 0x14, 0xe5, 0x49, 0xea, 0x90, 0x3a, 0x58, 0xb6, 0xde, 0xd5,
         0x86, 0x9c, 0xbc, 0x1, 0x45, 0xdd, 0x2, 0xa, }),
    },
    {
        TFM_BL1_KEY_TEST_2,
        {0x50, 0xf1, 0x3f, 0x47, 0xe3, 0x14, 0x8b, 0x55, 0xa, 0x1a, 0xd7, 0x6,
         0x0, 0x0, 0x0, 0x0, },
        (char *)((uint8_t[])
        {0xf8, 0x61, 0xc5, 0x8f, 0x35, 0xb2, 0xd6, 0x9f, 0xc, 0x92, 0xa9, 0x0,
         0x7d, 0xac, 0x95, 0x82, 0xe3, 0xd9, 0x6, 0xb2, 0x1e, 0xed, 0x34, 0x72,
         0x2c, 0x4c, 0x34, 0x49, 0xfc, 0x19, 0x64, 0x24, 0x36, 0x7, 0x86, 0xc5,
         0x7a, 0x15, 0x35, 0x16, 0x47, 0x8d, 0x41, 0x6, 0xf3, 0xb1, 0x32, 0x60,
         0x6b, 0xce, 0x67, 0x9d, 0x7f, 0x4f, 0x2c, 0xd8, 0xc1, 0x91, 0x85, 0x45,
         0xe0, 0xf4, 0xfd, 0x6e, 0x9a, 0xab, 0xef, 0xee, 0x47, 0x83, 0x64, 0x7a,
         0xd1, 0xe5, 0x7d, 0x6a, 0x78, 0xdb, 0xf7, 0x3e, 0xc4, 0x5, 0xa, 0xda,
         0x23, 0x1d, 0x85, 0x4a, 0x82, 0x55, 0x7a, 0xdd, 0x83, 0x58, 0xd2, 0xe,
         0xc5, 0x3, 0x4e, 0xc7, 0xaf, 0xe5, 0xec, 0xe2, 0x2d, 0xd9, 0xd8, 0xd,
         0x2, 0xe4, 0x63, 0x1, 0x66, 0xa6, 0xb7, 0x9a, 0xad, 0xc9, 0xb6, 0xab,
         0x8, 0x19, 0x3e, 0xd6, 0xaa, 0x3d, 0x86, 0xc8, }),
        128,
        (char *)((uint8_t[])
        {0xa2, 0x8e, 0xab, 0x74, 0x24, 0x45, 0x7, 0x62, 0x42, 0x39, 0x85, 0x3f,
         0x5d, 0x3d, 0xb, 0xa4, 0x7c, 0x61, 0xd6, 0x41, 0xfc, 0xdf, 0xa7, 0x8d,
         0xad, 0x31, 0xbf, 0x1f, 0xa7, 0x35, 0xa8, 0xf8, 0x61, 0xb0, 0xf1, 0xd7,
         0x4d, 0x5b, 0x4f, 0x83, 0xd8, 0x9c, 0x49, 0x5, 0xac, 0xd9, 0x7b, 0x5e,
         0xca, 0x1c, 0xb3, 0x64, 0xc3, 0x1c, 0x75, 0xdc, 0x32, 0xa0, 0xc4, 0xf3,
         0x6, 0x36, 0x9c, 0xaf, 0x15, 0x84, 0xe3, 0xf9, 0xfb, 0x47, 0x31, 0x7f,
         0xa7, 0xca, 0x33, 0xf5, 0x13, 0x76, 0x4, 0x19, 0xa9, 0x4a, 0x68, 0x89,
         0xca, 0x98, 0xff, 0xe6, 0x3, 0x5, 0x9, 0x96, 0x24, 0x20, 0x82, 0x52,
         0x7, 0xa3, 0xf1, 0x14, 0x62, 0x31, 0xb1, 0x84, 0x84, 0x9f, 0xb2, 0xc,
         0xc2, 0xef, 0xcd, 0x3, 0xcb, 0xbd, 0x11, 0x2a, 0x8a, 0x8a, 0x82, 0x9,
         0x8b, 0xc, 0x4c, 0xe8, 0xed, 0x33, 0xf2, 0xf7, }),
    },
    {
        TFM_BL1_KEY_TEST_2,
        {0x42, 0xc0, 0x5e, 0xa1, 0x79, 0xd4, 0x98, 0xa0, 0xfe, 0xdb, 0xb8, 0x80,
         0x0, 0x0, 0x0, 0x0, },
        (char *)((uint8_t[])
        {0xa1, 0x56, 0x14, 0x9d, 0xc1, 0x58, 0x89, 0x98, 0x56, 0x67, 0x38, 0x3b,
         0x69, 0xd1, 0xce, 0x35, 0x72, 0x9c, 0xad, 0xc, 0x67, 0x27, 0x11, 0xc5,
         0xb6, 0x9f, 0x8a, 0x26, 0x9, 0xcb, 0x8, 0x5b, 0x75, 0x1b, 0x22, 0x86,
         0xb7, 0x5c, 0xb7, 0xd1, 0xe8, 0x2d, 0x38, 0x14, 0x93, 0x22, 0xde, 0x4e,
         0x1c, 0xd5, 0x8a, 0xf0, 0xf6, 0x62, 0x9f, 0x9b, 0x8b, 0xa, 0xa, 0xfc,
         0x7d, 0xed, 0x2c, 0x2a, 0xa6, 0x36, 0xf1, 0xd9, 0x71, 0x12, 0xe8, 0x11,
         0x9c, 0x13, 0x5c, 0xb3, 0x20, 0xa6, 0x71, 0x6b, 0xbd, 0xad, 0xe1, 0xbf,
         0xf2, 0x13, 0x8, 0x3, 0xed, 0x19, 0x5, 0xa1, 0xd1, 0x4b, 0xc4, 0x27,
         0x6d, 0x73, 0x34, 0xb4, 0x17, 0x1c, 0xd0, 0x16, 0xd6, 0xe8, 0x6c, 0xa5,
         0xda, 0x27, 0x2, 0x3d, 0x36, 0xa6, 0xd6, 0x47, 0xf7, 0xa5, 0x74, 0x84,
         0x9a, 0xc, 0x85, 0x23, 0x61, 0xaf, 0x2a, 0x6a, }),
        128,
        (char *)((uint8_t[])
        {0xd9, 0x6, 0xbb, 0x64, 0xf6, 0xfd, 0x5f, 0x6d, 0xfa, 0xc6, 0x45, 0x6b,
         0xf, 0x89, 0x35, 0xa5, 0xb, 0x62, 0xdb, 0xdc, 0x89, 0xf3, 0x9a, 0x16,
         0x15, 0x5, 0x48, 0x28, 0x3e, 0x57, 0x69, 0x87, 0x5e, 0xca, 0x48, 0xe2,
         0xe8, 0xc9, 0x6f, 0x81, 0xd1, 0x5d, 0xb4, 0x95, 0x5c, 0xa0, 0x60, 0x19,
         0x63, 0x8e, 0x95, 0x7f, 0x19, 0x82, 0x7, 0xfe, 0x3c, 0xc1, 0xb, 0xdc,
         0x0, 0x8, 0xba, 0x92, 0x53, 0x2c, 0xcf, 0x5e, 0x3c, 0x59, 0x4a, 0x97,
         0xcd, 0x56, 0x7d, 0xbf, 0xb6, 0x53, 0x33, 0x31, 0xf4, 0x67, 0x2, 0x9f,
         0xff, 0xc5, 0xd2, 0xc1, 0x85, 0xc, 0xa3, 0xe1, 0x4c, 0x30, 0x0, 0x2,
         0xc5, 0x31, 0x3b, 0xfe, 0xc7, 0x3e, 0xce, 0xc7, 0xc7, 0xa0, 0xd7, 0x8c,
         0xc5, 0x78, 0xdc, 0x9b, 0x47, 0xcd, 0x92, 0xbf, 0xc9, 0x5, 0x12, 0x71,
         0xa0, 0x3c, 0xe, 0x62, 0xf4, 0xd6, 0xba, 0x5, }),
    },
    {
        TFM_BL1_KEY_TEST_2,
        {0x68, 0x3a, 0x92, 0xf7, 0xfc, 0xdb, 0x82, 0xb4, 0xcb, 0x8f, 0x3b, 0x88,
         0x0, 0x0, 0x0, 0x0, },
        (char *)((uint8_t[])
        {0xc8, 0x6b, 0xc2, 0xe6, 0x27, 0x9e, 0xe6, 0x84, 0xe8, 0x6f, 0xb7, 0xde,
         0xfa, 0x5c, 0xe4, 0x34, 0xec, 0xe8, 0x1b, 0xc9, 0xaf, 0x18, 0xfb, 0xa7,
         0xa1, 0x20, 0x6e, 0x6b, 0xf7, 0x7c, 0x90, 0xdb, 0x83, 0x75, 0xf2, 0x23,
         0x53, 0x8e, 0x5d, 0x10, 0x12, 0x81, 0xde, 0x78, 0x89, 0x38, 0x0, 0x37,
         0xaf, 0x2d, 0xab, 0xe8, 0xf2, 0x91, 0xb1, 0xbf, 0x3e, 0xa8, 0xb2, 0x73,
         0x88, 0x6d, 0x48, 0x41, 0x60, 0x43, 0x19, 0xbd, 0x8, 0x86, 0x61, 0x8d,
         0xd3, 0x9d, 0xd1, 0x71, 0xf8, 0x78, 0x4, 0xbe, 0x88, 0x11, 0x4f, 0xee,
         0xcd, 0xc7, 0x6a, 0x87, 0x49, 0x86, 0xb7, 0xdb, 0x62, 0x78, 0x61, 0x89,
         0xee, 0xe8, 0x23, 0x54, 0xc3, 0x87, 0x3d, 0x7e, 0x41, 0xdd, 0xe3, 0x60,
         0xec, 0xa8, 0xe0, 0xf8, 0xac, 0xcc, 0x26, 0x93, 0xa7, 0x19, 0x81, 0xb1,
         0x63, 0x4c, 0xf1, 0x93, 0x24, 0xca, 0x22, 0x90, }),
        128,
        (char *)((uint8_t[])
        {0x27, 0xa0, 0xdf, 0xca, 0x6d, 0xc6, 0xe9, 0x4, 0x7c, 0xa7, 0x9d, 0x4,
         0xca, 0x2d, 0xb8, 0xe1, 0x7f, 0x69, 0xb1, 0x7c, 0x15, 0xea, 0x2f, 0x50,
         0x63, 0x70, 0x17, 0x14, 0xea, 0xc6, 0xf0, 0x8c, 0xae, 0xef, 0x99, 0xa3,
         0x9d, 0x10, 0xe2, 0xbb, 0xeb, 0x22, 0xe8, 0x69, 0xf1, 0x84, 0xa, 0x42,
         0x38, 0xdc, 0x35, 0xdf, 0xb, 0x71, 0x48, 0xd1, 0x19, 0x2e, 0x4e, 0x6,
         0x4d, 0xba, 0xc, 0xe7, 0x93, 0x36, 0x8d, 0xd, 0x1e, 0xb1, 0xc2, 0xd7,
         0xf7, 0x1c, 0xf1, 0xe7, 0x47, 0x47, 0xb7, 0x87, 0xeb, 0xed, 0x51, 0xb7,
         0x60, 0x41, 0xf2, 0xca, 0x7, 0x1b, 0x96, 0x29, 0xa7, 0xfb, 0xf1, 0xa2,
         0x37, 0xe1, 0x8, 0x6e, 0xec, 0x70, 0xb5, 0x9d, 0x3a, 0x9d, 0xa7, 0xa0,
         0x19, 0xce, 0xb5, 0x95, 0xf2, 0x65, 0xbf, 0x9a, 0x52, 0x5b, 0xf5, 0x33,
         0xac, 0xbf, 0x3d, 0x1e, 0x3e, 0xb9, 0x7e, 0x38, }),
    },
    {
        TFM_BL1_KEY_TEST_2,
        {0x0, 0xd2, 0x52, 0xd0, 0x1b, 0x44, 0x6f, 0x69, 0x3a, 0x1c, 0x18, 0x7,
         0x0, 0x0, 0x0, 0x0, },
        (char *)((uint8_t[])
        {0x50, 0x65, 0x60, 0x6e, 0x32, 0xb2, 0x4, 0x71, 0xaf, 0xf7, 0xf1, 0x72,
         0x3b, 0xeb, 0xe2, 0xe5, 0x19, 0x96, 0x93, 0x50, 0x94, 0xb2, 0xa, 0x50,
         0xc5, 0x92, 0x6e, 0xe4, 0x57, 0x2e, 0x1e, 0xe5, 0x81, 0x3e, 0x2c, 0xb8,
         0xe0, 0x66, 0x1a, 0x14, 0x4a, 0x7e, 0x0, 0x6b, 0x7b, 0x82, 0xcd, 0x5a,
         0x39, 0xf4, 0x4, 0xb6, 0x95, 0x8e, 0x1f, 0x92, 0x0, 0xe8, 0xd3, 0x86,
         0x8f, 0x97, 0x51, 0x7c, 0x80, 0x7f, 0x89, 0xeb, 0x1b, 0x7d, 0x60, 0xf7,
         0x18, 0x5, 0x9a, 0xb3, 0xb5, 0xcb, 0xbd, 0x6d, 0x20, 0x6d, 0xa, 0x5a,
         0x98, 0x1b, 0xe7, 0x90, 0xde, 0xcd, 0x49, 0x6b, 0xbd, 0xc6, 0x2, 0x5a,
         0x30, 0xbe, 0x20, 0x16, 0xa8, 0x28, 0xc9, 0xab, 0xe4, 0x95, 0xd3, 0x1c,
         0xa3, 0xc2, 0xe3, 0xda, 0x42, 0x0, 0xe, 0xa6, 0x9e, 0x32, 0xa4, 0xcd,
         0x72, 0x20, 0xd5, 0x79, 0xb4, 0xd8, 0xcd, 0xc4, }),
        128,
        (char *)((uint8_t[])
        {0x32, 0xf9, 0xc9, 0x4d, 0x2d, 0x42, 0xde, 0x82, 0xd8, 0x2f, 0x78, 0x4,
         0xc6, 0xef, 0xa3, 0x77, 0xc7, 0x6a, 0xe6, 0xa7, 0x19, 0xcb, 0x3d, 0x1d,
         0x4, 0xe, 0x46, 0x82, 0x50, 0xbb, 0xcb, 0x11, 0x4f, 0x90, 0x13, 0xd9,
         0xf5, 0x64, 0xcb, 0xde, 0xd, 0x26, 0xd0, 0x3a, 0x77, 0xfa, 0x14, 0x3d,
         0x6, 0xd0, 0x5c, 0x6, 0xc6, 0xb5, 0x86, 0x24, 0x38, 0x9f, 0xff, 0x86,
         0x39, 0x4e, 0x55, 0x66, 0x85, 0xf6, 0x23, 0x3f, 0x8, 0x7, 0x73, 0x95,
         0x60, 0x49, 0x79, 0x57, 0xe2, 0x47, 0x53, 0xc2, 0x71, 0x53, 0x4, 0xe5,
         0x89, 0xc1, 0xe1, 0x67, 0x1e, 0x44, 0x6, 0x57, 0x31, 0xd4, 0xc2, 0xb5,
         0xa1, 0x65, 0x99, 0xab, 0x76, 0x40, 0x41, 0xc2, 0xa2, 0x13, 0x8e, 0x67,
         0x4e, 0x99, 0x41, 0x84, 0xaa, 0x15, 0xfb, 0x34, 0x55, 0x1d, 0x99, 0x60,
         0x62, 0xef, 0x33, 0xd9, 0x1e, 0xab, 0x5b, 0xf5, }),
    },
};

static void tfm_bl1_crypto_test_2011(struct test_result_t *ret)
{
    aes_256_vector_test(ret, test_2011_vectors,
                        sizeof(test_2011_vectors) / sizeof(struct aes256_ctr_test_vector_t));
    return;
}

static void tfm_bl1_crypto_test_2012(struct test_result_t *ret)
{
    uint8_t *plaintext_out;
    uint8_t counter[CTR_IV_LEN];
    int rc;

    const struct aes256_ctr_test_vector_t * const vec = test_2011_vectors;

    plaintext_out = malloc(vec->len);
    if (plaintext_out == NULL) {
        TEST_FAIL("Failed to allocate memory");
    }

    memcpy(counter, vec->iv, CTR_IV_LEN);

    rc = bl1_aes_256_ctr_decrypt(vec->key_id, counter,
                                 NULL,
                                 vec->len, plaintext_out);
    if (rc == 0) {
        free(plaintext_out);
        TEST_FAIL("AES operation return success when ciphertext was NULL");
        return;
    }

    rc = bl1_aes_256_ctr_decrypt(vec->key_id, NULL,
                                 (const uint8_t *)vec->ciphertext,
                                 vec->len, plaintext_out);
    if (rc == 0) {
        free(plaintext_out);
        TEST_FAIL("AES operation return success when counter was NULL");
        return;
    }

    free(plaintext_out);

    ret->val = TEST_PASSED;
    return;
}

static void tfm_bl1_crypto_test_2013(struct test_result_t *ret)
{
    uint8_t counter[CTR_IV_LEN];
    int rc;

    const struct aes256_ctr_test_vector_t * const vec = test_2011_vectors;

    memcpy(counter, vec->iv, CTR_IV_LEN);

    rc = bl1_aes_256_ctr_decrypt(vec->key_id, counter,
                                 (const uint8_t *)vec->ciphertext,
                                 vec->len, NULL);
    if (rc == 0) {
        TEST_FAIL("AES operation return success");
        return;
    }

    ret->val = TEST_PASSED;
    return;
}

static const struct aes256_ctr_test_vector_t test_2014_vectors[] = {
    {
        TFM_BL1_KEY_TEST_1,
        {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
         0xff, 0xff, 0xff, 0xff, },
        (char *)((uint8_t[])
        {0xb, 0x1, 0x77, 0x69, 0x7d, 0xea, 0x3, 0xa, 0x2, 0x89, 0x3f, 0x3, 0x32,
         0xdc, 0xdf, 0x91, 0xf6, 0x45, 0x50, 0x79, 0x54, 0x7c, 0xa, 0xf9, 0x1a,
         0x8f, 0x83, 0x40, 0xd8, 0xc2, 0xec, 0x27, 0x4a, 0xee, 0xb8, 0x1a, 0x37,
         0x95, 0x51, 0xa6, 0x6f, 0xde, 0xc3, 0xde, 0xed, 0x5e, 0x7e, 0x67, 0x86,
         0x8d, 0xeb, 0x31, 0x57, 0x3e, 0xff, 0xe1, 0xad, 0x32, 0x9f, 0x85, 0xd4,
         0x97, 0x5b, 0xb9, 0x84, 0xa9, 0xac, 0xfd, 0xb8, 0x68, 0x6f, 0xce, 0x8b,
         0xbc, 0x10, 0x29, 0xdb, 0xd9, 0xa9, 0x68, 0x3a, 0x79, 0x65, 0x79, 0x79,
         0xcd, 0x93, 0x57, 0x75, 0x13, 0x4d, 0xc8, 0xe5, 0xa9, 0xca, 0xca, 0x83,
         0x3a, 0x32, 0xd6, 0x20, 0xf2, 0xa9, 0x18, 0xed, 0x2, 0x71, 0x3f, 0x9c,
         0xb9, 0x87, 0x69, 0x98, 0xa9, 0xea, 0xf8, 0x84, 0x63, 0x8, 0xe4, 0x58,
         0xbd, 0xed, 0x5a, 0xe7, 0x83, 0xe0, 0xcb, }),
        128,
        (char *)((uint8_t[])
        {0x52, 0x73, 0x65, 0x33, 0x3b, 0xbd, 0xa7, 0x84, 0x23, 0x33, 0x69, 0x34,
         0x1d, 0x76, 0x22, 0xfd, 0xba, 0x32, 0x7b, 0x48, 0x38, 0x36, 0x92, 0x4f,
         0x3c, 0x94, 0xcd, 0xe0, 0x9d, 0xe3, 0x43, 0x29, 0x2a, 0x72, 0xd7, 0xda,
         0xfc, 0x4, 0xe8, 0xc9, 0xae, 0xe5, 0x5d, 0x49, 0x45, 0x4d, 0x80, 0xee,
         0x5c, 0x20, 0xda, 0xc, 0x78, 0x93, 0xc3, 0x23, 0xa4, 0x3e, 0xa, 0x3,
         0x5a, 0x19, 0x71, 0xb4, 0x25, 0x7c, 0x7e, 0x65, 0x19, 0x6f, 0xca, 0x78,
         0x52, 0xb5, 0x16, 0xb2, 0x57, 0x12, 0x43, 0xff, 0x8e, 0xfb, 0x2c, 0xd9,
         0xd4, 0xc3, 0xf3, 0x7c, 0x97, 0x9, 0xe6, 0x83, 0xf3, 0x46, 0xd3, 0xc2,
         0xeb, 0x8, 0x83, 0x48, 0xee, 0xcf, 0x27, 0xa4, 0xc0, 0xb4, 0x44, 0xdf,
         0xb7, 0xf1, 0xa6, 0xec, 0x8b, 0xba, 0x3a, 0xca, 0x8a, 0x50, 0xa2, 0xf1,
         0x76, 0x9b, 0xda, 0x5b, 0x4, 0xda, 0x33, 0x2f, }),
    },
};

static void tfm_bl1_crypto_test_2014(struct test_result_t *ret)
{
    aes_256_vector_test(ret, test_2014_vectors,
                        sizeof(test_2014_vectors) / sizeof(struct aes256_ctr_test_vector_t));
    return;
}

static void tfm_bl1_crypto_test_2015(struct test_result_t *ret)
{
    uint8_t *plaintext_out;
    uint8_t counter[CTR_IV_LEN];
    int rc;

    const struct aes256_ctr_test_vector_t * const vec = test_2011_vectors;

    plaintext_out = malloc(vec->len);
    if (plaintext_out == NULL) {
        TEST_FAIL("Failed to allocate memory");
    }

    memcpy(counter, vec->iv, CTR_IV_LEN);

    rc = bl1_aes_256_ctr_decrypt(-1, counter,
                                 (const uint8_t *)vec->ciphertext,
                                 vec->len, plaintext_out);
    if (rc == 0) {
        free(plaintext_out);
        TEST_FAIL("AES operation return success when key id was negative");
        return;
    }

    rc = bl1_aes_256_ctr_decrypt(tfm_bl1_key_max, counter,
                                 (const uint8_t *)vec->ciphertext,
                                 vec->len, plaintext_out);
    if (rc == 0) {
        free(plaintext_out);
        TEST_FAIL("AES operation return success when key id was invalid");
        return;
    }

    free(plaintext_out);

    ret->val = TEST_PASSED;
    return;
}

static const struct aes256_ctr_test_vector_t test_2016_vectors[] = {
    {
        TFM_BL1_KEY_TEST_1,
        {0x68, 0x3a, 0x92, 0xf7, 0xfc, 0xdb, 0x82, 0xb4, 0xcb, 0x8f, 0x3b, 0x88,
         0x0, 0x0, 0x0, 0x0, },
        NULL,
        0,
        NULL,
    },
};

static void tfm_bl1_crypto_test_2016(struct test_result_t *ret)
{
    aes_256_vector_test(ret, test_2016_vectors,
                        sizeof(test_2016_vectors) / sizeof(struct aes256_ctr_test_vector_t));
    return;
}

static struct test_t crypto_tests[] = {
    {&tfm_bl1_crypto_test_2001, "TFM_BL1_CRYPTO_TEST_2001",
     "Crypto SHA256 generic vector test" },
    {&tfm_bl1_crypto_test_2002, "TFM_BL1_CRYPTO_TEST_2002",
     "Crypto SHA256 input null-pointer test" },
    {&tfm_bl1_crypto_test_2003, "TFM_BL1_CRYPTO_TEST_2003",
     "Crypto SHA256 output null-pointer test" },

    {&tfm_bl1_crypto_test_2011, "TFM_BL1_CRYPTO_TEST_2011",
     "Crypto AES256-CTR generic vector test" },
    {&tfm_bl1_crypto_test_2012, "TFM_BL1_CRYPTO_TEST_2012",
     "Crypto AES256-CTR input null-pointer test" },
    {&tfm_bl1_crypto_test_2013, "TFM_BL1_CRYPTO_TEST_2013",
     "Crypto AES256-CTR output null-pointer test" },
    {&tfm_bl1_crypto_test_2014, "TFM_BL1_CRYPTO_TEST_2014",
     "Crypto AES256-CTR counter overflow test" },
    {&tfm_bl1_crypto_test_2015, "TFM_BL1_CRYPTO_TEST_2015",
     "Crypto AES256-CTR key id test" },
    {&tfm_bl1_crypto_test_2016, "TFM_BL1_CRYPTO_TEST_2016",
     "Crypto AES256-CTR zero-length test" },
};

void register_testsuite_bl1_crypto_interface(struct test_suite_t *p_test_suite)
{
    uint32_t list_size = (sizeof(crypto_tests) / sizeof(crypto_tests[0]));

    set_testsuite("CRYPTO interface test (TFM_BL1_CRYPTO_TEST_2XXX)",
                  crypto_tests, list_size, p_test_suite);
}

