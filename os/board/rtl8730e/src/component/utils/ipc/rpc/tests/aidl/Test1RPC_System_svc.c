/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include <Test1RPC_System.h>
#include <string.h>
#include <rpc_server.h>
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <RPCBaseDS.h>
#include <Test1RPCBaseDS.h>

static void
TEST1_SYSTEM_0(RPC_STRUCT *rpc, int32_t opt, RPC_Mutex *pMutex, char *buf)
{
	union {
		TEST1_RPC_AFE_INIT_CONFIG TEST1_RPC_ToAgent_AFE_Init_0_arg;
		TEST1_RPC_AFE_PROCESS_BUFS TEST1_RPC_ToAgent_AFE_Process_0_arg;
		TEST1_VOID TEST1_RPC_ToAgent_AFE_Destroy_0_arg;
	} argument;

	union {
		HRESULT TEST1_RPC_ToAgent_AFE_Init_0_ret;
		HRESULT TEST1_RPC_ToAgent_AFE_Process_0_ret;
		TEST1_VOID TEST1_RPC_ToAgent_AFE_Destroy_0_ret;
	} retval;
	xdrproc_t _xdr_argument, _xdr_result;
	char *(*local)(char *, struct RPC_STRUCT *, char *);
	int ReplyParaSize;


	switch (rpc->procedure_id) {
	case TEST1_RPC_ToAgent_AFE_Init:
		_xdr_argument = (xdrproc_t) xdr_TEST1_RPC_AFE_INIT_CONFIG;
		_xdr_result = (xdrproc_t) xdr_HRESULT;
		ReplyParaSize = sizeof(HRESULT);
		local = (char *(*)(char *, struct RPC_STRUCT *, char *)) TEST1_RPC_ToAgent_AFE_Init_0_svc;
		break;

	case TEST1_RPC_ToAgent_AFE_Process:
		_xdr_argument = (xdrproc_t) xdr_TEST1_RPC_AFE_PROCESS_BUFS;
		_xdr_result = (xdrproc_t) xdr_HRESULT;
		ReplyParaSize = sizeof(HRESULT);
		local = (char *(*)(char *, struct RPC_STRUCT *, char *)) TEST1_RPC_ToAgent_AFE_Process_0_svc;
		break;

	case TEST1_RPC_ToAgent_AFE_Destroy:
		_xdr_argument = (xdrproc_t) xdr_TEST1_VOID;
		_xdr_result = (xdrproc_t) xdr_TEST1_VOID;
		ReplyParaSize = sizeof(TEST1_VOID);
		local = (char *(*)(char *, struct RPC_STRUCT *, char *)) TEST1_RPC_ToAgent_AFE_Destroy_0_svc;
		break;

	default:
		return;
	}


	memset((char *)&argument, 0, sizeof(argument));


	if (!RPC_GetArgs(rpc, (xdrproc_t) _xdr_argument, (caddr_t) &argument, opt, buf)) {
		printf("get args error\n");
		RPC_MutexUnlock(pMutex);
		return;
	}

	RPC_MutexUnlock(pMutex);

	(*local)((char *)&argument, rpc, (char *)&retval);


	// When source msg is BLOCK_MODE,
	// we must help it reply
	// ps: reply mode is NON_BLOCK and use request's ringbuf type
	if (rpc->task_id != 0) {
		RPC_SendReply(rpc->task_id, rpc->context, (char *)&retval, ReplyParaSize,
					  (xdrproc_t) _xdr_result, opt);
	}

	return;
}
HRESULT   *(*p_TEST1_RPC_ToAgent_AFE_Init_0_svc)(TEST1_RPC_AFE_INIT_CONFIG *pParam, RPC_STRUCT *pRpcStruct, HRESULT *pRes) = 0;

HRESULT *TEST1_RPC_ToAgent_AFE_Init_0_svc(TEST1_RPC_AFE_INIT_CONFIG *pParam, RPC_STRUCT *pRpcStruct, HRESULT *pRes)
{
	if (p_TEST1_RPC_ToAgent_AFE_Init_0_svc) {
		p_TEST1_RPC_ToAgent_AFE_Init_0_svc(pParam, pRpcStruct, pRes);
		return pRes;
	} else {
		return pRes;
	}
}

HRESULT   *(*p_TEST1_RPC_ToAgent_AFE_Process_0_svc)(TEST1_RPC_AFE_PROCESS_BUFS *pParam, RPC_STRUCT *pRpcStruct, HRESULT *pRes) = 0;

HRESULT *TEST1_RPC_ToAgent_AFE_Process_0_svc(TEST1_RPC_AFE_PROCESS_BUFS *pParam, RPC_STRUCT *pRpcStruct, HRESULT *pRes)
{
	if (p_TEST1_RPC_ToAgent_AFE_Process_0_svc) {
		p_TEST1_RPC_ToAgent_AFE_Process_0_svc(pParam, pRpcStruct, pRes);
		return pRes;
	} else {
		return pRes;
	}
}

TEST1_VOID   *(*p_TEST1_RPC_ToAgent_AFE_Destroy_0_svc)(TEST1_VOID *pParam, RPC_STRUCT *pRpcStruct, TEST1_VOID *pRes) = 0;

TEST1_VOID *TEST1_RPC_ToAgent_AFE_Destroy_0_svc(TEST1_VOID *pParam, RPC_STRUCT *pRpcStruct, TEST1_VOID *pRes)
{
	if (p_TEST1_RPC_ToAgent_AFE_Destroy_0_svc) {
		p_TEST1_RPC_ToAgent_AFE_Destroy_0_svc(pParam, pRpcStruct, pRes);
		return pRes;
	} else {
		return pRes;
	}
}



struct REG_STRUCT *TEST1_SYSTEM_0_register(struct REG_STRUCT *rnode)
{

	REG_STRUCT *pReg = (struct REG_STRUCT *)RPC_Register(rnode, TEST1_SYSTEM, 0,
					   (void (*)(struct RPC_STRUCT *, int32_t, RPC_Mutex *, char *))TEST1_SYSTEM_0);
	return pReg;
}
