/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include <string.h> /* for memset */
#include <Test1RPC_System.h>
#include <rpc_client.h>

#include <RPCBaseDS.h>
#include <Test1RPCBaseDS.h>

HRESULT *
TEST1_RPC_ToAgent_AFE_Init_0(TEST1_RPC_AFE_INIT_CONFIG *argp, CLNT_STRUCT *clnt)
{
	RPC_STRUCT rpc;
	HRESULT *result = NULL ;
	long args_size = sizeof(TEST1_RPC_AFE_INIT_CONFIG);


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->send_mode & BLOCK_MODE) {
		result = (HRESULT *) rpc_malloc(sizeof(HRESULT));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = RPC_PrepareCall(clnt, (int)result);


	if (RPC_ClientCall(&rpc, TEST1_RPC_ToAgent_AFE_Init, clnt->send_mode,
					   (xdrproc_t) xdr_TEST1_RPC_AFE_INIT_CONFIG, (caddr_t) argp, args_size)
		!= 0) {
		if (result) {
			rpc_free(result);
		}
		return (HRESULT *) - 1;
	}


	//for blocking use
	if (clnt->send_mode & BLOCK_MODE) {
		XDR xdrs;

		WaitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		if (!xdr_HRESULT(&xdrs, result)) {
			return (HRESULT *) - 1;
		}
		return result;
	}

	return 0;

}

HRESULT *
TEST1_RPC_ToAgent_AFE_Process_0(TEST1_RPC_AFE_PROCESS_BUFS *argp, CLNT_STRUCT *clnt)
{
	RPC_STRUCT rpc;
	HRESULT *result = NULL ;
	long args_size = sizeof(TEST1_RPC_AFE_PROCESS_BUFS);


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->send_mode & BLOCK_MODE) {
		result = (HRESULT *) rpc_malloc(sizeof(HRESULT));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = RPC_PrepareCall(clnt, (int)result);


	if (RPC_ClientCall(&rpc, TEST1_RPC_ToAgent_AFE_Process, clnt->send_mode,
					   (xdrproc_t) xdr_TEST1_RPC_AFE_PROCESS_BUFS, (caddr_t) argp, args_size)
		!= 0) {
		if (result) {
			rpc_free(result);
		}
		return (HRESULT *) - 1;
	}


	//for blocking use
	if (clnt->send_mode & BLOCK_MODE) {
		XDR xdrs;

		WaitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		if (!xdr_HRESULT(&xdrs, result)) {
			return (HRESULT *) - 1;
		}
		return result;
	}

	return 0;

}

TEST1_VOID *
TEST1_RPC_ToAgent_AFE_Destroy_0(TEST1_VOID *argp, CLNT_STRUCT *clnt)
{
	RPC_STRUCT rpc;
	TEST1_VOID *result = NULL ;
	long args_size = sizeof(TEST1_VOID);


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->send_mode & BLOCK_MODE) {
		result = (TEST1_VOID *) rpc_malloc(sizeof(TEST1_VOID));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = RPC_PrepareCall(clnt, (int)result);


	if (RPC_ClientCall(&rpc, TEST1_RPC_ToAgent_AFE_Destroy, clnt->send_mode,
					   (xdrproc_t) xdr_TEST1_VOID, (caddr_t) argp, args_size)
		!= 0) {
		if (result) {
			rpc_free(result);
		}
		return (TEST1_VOID *) - 1;
	}


	//for blocking use
	if (clnt->send_mode & BLOCK_MODE) {
		XDR xdrs;

		WaitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(TEST1_VOID), XDR_DECODE);
		if (!xdr_TEST1_VOID(&xdrs, result)) {
			return (TEST1_VOID *) - 1;
		}
		return result;
	}

	return 0;

}
