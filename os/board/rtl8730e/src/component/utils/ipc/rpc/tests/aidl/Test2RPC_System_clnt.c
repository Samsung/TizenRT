/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include <string.h> /* for memset */
#include <Test2RPC_System.h>
#include <rpc_client.h>

#include <RPCBaseDS.h>
#include <Test2RPCBaseDS.h>

TEST2_RPCRES_INIT *
TEST2_RPC_ToAgent_Init_0(TEST2_RPC_MIC_DATA *argp, CLNT_STRUCT *clnt)
{
	RPC_STRUCT rpc;
	TEST2_RPCRES_INIT *result = NULL ;
	long args_size = sizeof(TEST2_RPC_MIC_DATA);


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->send_mode & BLOCK_MODE) {
		result = (TEST2_RPCRES_INIT *) rpc_malloc(sizeof(TEST2_RPCRES_INIT));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = RPC_PrepareCall(clnt, (int)result);


	if (RPC_ClientCall(&rpc, TEST2_RPC_ToAgent_Init, clnt->send_mode,
					   (xdrproc_t) xdr_TEST2_RPC_MIC_DATA, (caddr_t) argp, args_size)
		!= 0) {
		if (result) {
			rpc_free(result);
		}
		return (TEST2_RPCRES_INIT *) - 1;
	}


	//for blocking use
	if (clnt->send_mode & BLOCK_MODE) {
		XDR xdrs;

		WaitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(TEST2_RPCRES_INIT), XDR_DECODE);
		if (!xdr_TEST2_RPCRES_INIT(&xdrs, result)) {
			return (TEST2_RPCRES_INIT *) - 1;
		}
		return result;
	}

	return 0;

}

HRESULT *
TEST2_RPC_ToAgent_Release_0(TEST2_RPC_INSTANCE *argp, CLNT_STRUCT *clnt)
{
	RPC_STRUCT rpc;
	HRESULT *result = NULL ;
	long args_size = sizeof(TEST2_RPC_INSTANCE);


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->send_mode & BLOCK_MODE) {
		result = (HRESULT *) rpc_malloc(sizeof(HRESULT));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = RPC_PrepareCall(clnt, (int)result);


	if (RPC_ClientCall(&rpc, TEST2_RPC_ToAgent_Release, clnt->send_mode,
					   (xdrproc_t) xdr_TEST2_RPC_INSTANCE, (caddr_t) argp, args_size)
		!= 0) {
		if (result) {
			rpc_free(result);
		}
		return (HRESULT *) - 1;
	}


	//for blocking use
	if (clnt->send_mode & BLOCK_MODE) {
		XDR xdrs;

		WaitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		if (!xdr_HRESULT(&xdrs, result)) {
			return (HRESULT *) - 1;
		}
		return result;
	}

	return 0;

}

HRESULT *
TEST2_RPC_ToAgent_Streaming_Process_0(TEST2_RPC_INSTANCE *argp, CLNT_STRUCT *clnt)
{
	RPC_STRUCT rpc;
	HRESULT *result = NULL ;
	long args_size = sizeof(TEST2_RPC_INSTANCE);


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->send_mode & BLOCK_MODE) {
		result = (HRESULT *) rpc_malloc(sizeof(HRESULT));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = RPC_PrepareCall(clnt, (int)result);


	if (RPC_ClientCall(&rpc, TEST2_RPC_ToAgent_Streaming_Process, clnt->send_mode,
					   (xdrproc_t) xdr_TEST2_RPC_INSTANCE, (caddr_t) argp, args_size)
		!= 0) {
		if (result) {
			rpc_free(result);
		}
		return (HRESULT *) - 1;
	}


	//for blocking use
	if (clnt->send_mode & BLOCK_MODE) {
		XDR xdrs;

		WaitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		if (!xdr_HRESULT(&xdrs, result)) {
			return (HRESULT *) - 1;
		}
		return result;
	}

	return 0;

}

HRESULT *
TEST2_RPC_ToAgent_Recognizer_Process_0(TEST2_RPC_INSTANCE *argp, CLNT_STRUCT *clnt)
{
	RPC_STRUCT rpc;
	HRESULT *result = NULL ;
	long args_size = sizeof(TEST2_RPC_INSTANCE);


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->send_mode & BLOCK_MODE) {
		result = (HRESULT *) rpc_malloc(sizeof(HRESULT));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = RPC_PrepareCall(clnt, (int)result);


	if (RPC_ClientCall(&rpc, TEST2_RPC_ToAgent_Recognizer_Process, clnt->send_mode,
					   (xdrproc_t) xdr_TEST2_RPC_INSTANCE, (caddr_t) argp, args_size)
		!= 0) {
		if (result) {
			rpc_free(result);
		}
		return (HRESULT *) - 1;
	}


	//for blocking use
	if (clnt->send_mode & BLOCK_MODE) {
		XDR xdrs;

		WaitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		if (!xdr_HRESULT(&xdrs, result)) {
			return (HRESULT *) - 1;
		}
		return result;
	}

	return 0;

}

HRESULT *
TEST2_RPC_ToAgent_Sync_Mic_Data_0(TEST2_RPC_MIC_DATA *argp, CLNT_STRUCT *clnt)
{
	RPC_STRUCT rpc;
	HRESULT *result = NULL ;
	long args_size = sizeof(TEST2_RPC_MIC_DATA);


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->send_mode & BLOCK_MODE) {
		result = (HRESULT *) rpc_malloc(sizeof(HRESULT));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = RPC_PrepareCall(clnt, (int)result);


	if (RPC_ClientCall(&rpc, TEST2_RPC_ToAgent_Sync_Mic_Data, clnt->send_mode,
					   (xdrproc_t) xdr_TEST2_RPC_MIC_DATA, (caddr_t) argp, args_size)
		!= 0) {
		if (result) {
			rpc_free(result);
		}
		return (HRESULT *) - 1;
	}


	//for blocking use
	if (clnt->send_mode & BLOCK_MODE) {
		XDR xdrs;

		WaitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		if (!xdr_HRESULT(&xdrs, result)) {
			return (HRESULT *) - 1;
		}
		return result;
	}

	return 0;

}
