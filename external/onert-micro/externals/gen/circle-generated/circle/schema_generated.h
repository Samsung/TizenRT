/*
 * Copyright (c) 2023 Samsung Electronics Co., Ltd. All Rights Reserved
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_SCHEMA_CIRCLE_H_
#define FLATBUFFERS_GENERATED_SCHEMA_CIRCLE_H_

#include "externals/flatbuffers/flatbuffers.h"

namespace circle
{

struct CustomQuantization;
struct CustomQuantizationBuilder;
struct CustomQuantizationT;

struct QuantizationParameters;
struct QuantizationParametersBuilder;
struct QuantizationParametersT;

struct Int32Vector;
struct Int32VectorBuilder;
struct Int32VectorT;

struct Uint16Vector;
struct Uint16VectorBuilder;
struct Uint16VectorT;

struct Uint8Vector;
struct Uint8VectorBuilder;
struct Uint8VectorT;

struct DimensionMetadata;
struct DimensionMetadataBuilder;
struct DimensionMetadataT;

struct SparsityParameters;
struct SparsityParametersBuilder;
struct SparsityParametersT;

struct Tensor;
struct TensorBuilder;
struct TensorT;

struct Conv2DOptions;
struct Conv2DOptionsBuilder;
struct Conv2DOptionsT;

struct Conv3DOptions;
struct Conv3DOptionsBuilder;
struct Conv3DOptionsT;

struct Pool2DOptions;
struct Pool2DOptionsBuilder;
struct Pool2DOptionsT;

struct DepthwiseConv2DOptions;
struct DepthwiseConv2DOptionsBuilder;
struct DepthwiseConv2DOptionsT;

struct ConcatEmbeddingsOptions;
struct ConcatEmbeddingsOptionsBuilder;
struct ConcatEmbeddingsOptionsT;

struct LSHProjectionOptions;
struct LSHProjectionOptionsBuilder;
struct LSHProjectionOptionsT;

struct SVDFOptions;
struct SVDFOptionsBuilder;
struct SVDFOptionsT;

struct RNNOptions;
struct RNNOptionsBuilder;
struct RNNOptionsT;

struct SequenceRNNOptions;
struct SequenceRNNOptionsBuilder;
struct SequenceRNNOptionsT;

struct BidirectionalSequenceRNNOptions;
struct BidirectionalSequenceRNNOptionsBuilder;
struct BidirectionalSequenceRNNOptionsT;

struct FullyConnectedOptions;
struct FullyConnectedOptionsBuilder;
struct FullyConnectedOptionsT;

struct SoftmaxOptions;
struct SoftmaxOptionsBuilder;
struct SoftmaxOptionsT;

struct ConcatenationOptions;
struct ConcatenationOptionsBuilder;
struct ConcatenationOptionsT;

struct AddOptions;
struct AddOptionsBuilder;
struct AddOptionsT;

struct MulOptions;
struct MulOptionsBuilder;
struct MulOptionsT;

struct L2NormOptions;
struct L2NormOptionsBuilder;
struct L2NormOptionsT;

struct LocalResponseNormalizationOptions;
struct LocalResponseNormalizationOptionsBuilder;
struct LocalResponseNormalizationOptionsT;

struct LSTMOptions;
struct LSTMOptionsBuilder;
struct LSTMOptionsT;

struct UnidirectionalSequenceLSTMOptions;
struct UnidirectionalSequenceLSTMOptionsBuilder;
struct UnidirectionalSequenceLSTMOptionsT;

struct BidirectionalSequenceLSTMOptions;
struct BidirectionalSequenceLSTMOptionsBuilder;
struct BidirectionalSequenceLSTMOptionsT;

struct ResizeBilinearOptions;
struct ResizeBilinearOptionsBuilder;
struct ResizeBilinearOptionsT;

struct ResizeNearestNeighborOptions;
struct ResizeNearestNeighborOptionsBuilder;
struct ResizeNearestNeighborOptionsT;

struct CallOptions;
struct CallOptionsBuilder;
struct CallOptionsT;

struct PadOptions;
struct PadOptionsBuilder;
struct PadOptionsT;

struct PadV2Options;
struct PadV2OptionsBuilder;
struct PadV2OptionsT;

struct ReshapeOptions;
struct ReshapeOptionsBuilder;
struct ReshapeOptionsT;

struct SpaceToBatchNDOptions;
struct SpaceToBatchNDOptionsBuilder;
struct SpaceToBatchNDOptionsT;

struct BatchToSpaceNDOptions;
struct BatchToSpaceNDOptionsBuilder;
struct BatchToSpaceNDOptionsT;

struct SkipGramOptions;
struct SkipGramOptionsBuilder;
struct SkipGramOptionsT;

struct SpaceToDepthOptions;
struct SpaceToDepthOptionsBuilder;
struct SpaceToDepthOptionsT;

struct DepthToSpaceOptions;
struct DepthToSpaceOptionsBuilder;
struct DepthToSpaceOptionsT;

struct SubOptions;
struct SubOptionsBuilder;
struct SubOptionsT;

struct DivOptions;
struct DivOptionsBuilder;
struct DivOptionsT;

struct TopKV2Options;
struct TopKV2OptionsBuilder;
struct TopKV2OptionsT;

struct EmbeddingLookupSparseOptions;
struct EmbeddingLookupSparseOptionsBuilder;
struct EmbeddingLookupSparseOptionsT;

struct GatherOptions;
struct GatherOptionsBuilder;
struct GatherOptionsT;

struct TransposeOptions;
struct TransposeOptionsBuilder;
struct TransposeOptionsT;

struct ExpOptions;
struct ExpOptionsBuilder;
struct ExpOptionsT;

struct CosOptions;
struct CosOptionsBuilder;
struct CosOptionsT;

struct ReducerOptions;
struct ReducerOptionsBuilder;
struct ReducerOptionsT;

struct SqueezeOptions;
struct SqueezeOptionsBuilder;
struct SqueezeOptionsT;

struct SplitOptions;
struct SplitOptionsBuilder;
struct SplitOptionsT;

struct SplitVOptions;
struct SplitVOptionsBuilder;
struct SplitVOptionsT;

struct StridedSliceOptions;
struct StridedSliceOptionsBuilder;
struct StridedSliceOptionsT;

struct LogSoftmaxOptions;
struct LogSoftmaxOptionsBuilder;
struct LogSoftmaxOptionsT;

struct CastOptions;
struct CastOptionsBuilder;
struct CastOptionsT;

struct DequantizeOptions;
struct DequantizeOptionsBuilder;
struct DequantizeOptionsT;

struct MaximumMinimumOptions;
struct MaximumMinimumOptionsBuilder;
struct MaximumMinimumOptionsT;

struct TileOptions;
struct TileOptionsBuilder;
struct TileOptionsT;

struct ArgMaxOptions;
struct ArgMaxOptionsBuilder;
struct ArgMaxOptionsT;

struct ArgMinOptions;
struct ArgMinOptionsBuilder;
struct ArgMinOptionsT;

struct GreaterOptions;
struct GreaterOptionsBuilder;
struct GreaterOptionsT;

struct GreaterEqualOptions;
struct GreaterEqualOptionsBuilder;
struct GreaterEqualOptionsT;

struct LessOptions;
struct LessOptionsBuilder;
struct LessOptionsT;

struct LessEqualOptions;
struct LessEqualOptionsBuilder;
struct LessEqualOptionsT;

struct NegOptions;
struct NegOptionsBuilder;
struct NegOptionsT;

struct SelectOptions;
struct SelectOptionsBuilder;
struct SelectOptionsT;

struct SliceOptions;
struct SliceOptionsBuilder;
struct SliceOptionsT;

struct TransposeConvOptions;
struct TransposeConvOptionsBuilder;
struct TransposeConvOptionsT;

struct ExpandDimsOptions;
struct ExpandDimsOptionsBuilder;
struct ExpandDimsOptionsT;

struct SparseToDenseOptions;
struct SparseToDenseOptionsBuilder;
struct SparseToDenseOptionsT;

struct EqualOptions;
struct EqualOptionsBuilder;
struct EqualOptionsT;

struct NotEqualOptions;
struct NotEqualOptionsBuilder;
struct NotEqualOptionsT;

struct ShapeOptions;
struct ShapeOptionsBuilder;
struct ShapeOptionsT;

struct RankOptions;
struct RankOptionsBuilder;
struct RankOptionsT;

struct PowOptions;
struct PowOptionsBuilder;
struct PowOptionsT;

struct FakeQuantOptions;
struct FakeQuantOptionsBuilder;
struct FakeQuantOptionsT;

struct PackOptions;
struct PackOptionsBuilder;
struct PackOptionsT;

struct LogicalOrOptions;
struct LogicalOrOptionsBuilder;
struct LogicalOrOptionsT;

struct OneHotOptions;
struct OneHotOptionsBuilder;
struct OneHotOptionsT;

struct AbsOptions;
struct AbsOptionsBuilder;
struct AbsOptionsT;

struct HardSwishOptions;
struct HardSwishOptionsBuilder;
struct HardSwishOptionsT;

struct LogicalAndOptions;
struct LogicalAndOptionsBuilder;
struct LogicalAndOptionsT;

struct LogicalNotOptions;
struct LogicalNotOptionsBuilder;
struct LogicalNotOptionsT;

struct UnpackOptions;
struct UnpackOptionsBuilder;
struct UnpackOptionsT;

struct FloorDivOptions;
struct FloorDivOptionsBuilder;
struct FloorDivOptionsT;

struct SquareOptions;
struct SquareOptionsBuilder;
struct SquareOptionsT;

struct ZerosLikeOptions;
struct ZerosLikeOptionsBuilder;
struct ZerosLikeOptionsT;

struct FillOptions;
struct FillOptionsBuilder;
struct FillOptionsT;

struct FloorModOptions;
struct FloorModOptionsBuilder;
struct FloorModOptionsT;

struct RangeOptions;
struct RangeOptionsBuilder;
struct RangeOptionsT;

struct LeakyReluOptions;
struct LeakyReluOptionsBuilder;
struct LeakyReluOptionsT;

struct SquaredDifferenceOptions;
struct SquaredDifferenceOptionsBuilder;
struct SquaredDifferenceOptionsT;

struct MirrorPadOptions;
struct MirrorPadOptionsBuilder;
struct MirrorPadOptionsT;

struct UniqueOptions;
struct UniqueOptionsBuilder;
struct UniqueOptionsT;

struct ReverseV2Options;
struct ReverseV2OptionsBuilder;
struct ReverseV2OptionsT;

struct AddNOptions;
struct AddNOptionsBuilder;
struct AddNOptionsT;

struct GatherNdOptions;
struct GatherNdOptionsBuilder;
struct GatherNdOptionsT;

struct WhereOptions;
struct WhereOptionsBuilder;
struct WhereOptionsT;

struct ReverseSequenceOptions;
struct ReverseSequenceOptionsBuilder;
struct ReverseSequenceOptionsT;

struct MatrixDiagOptions;
struct MatrixDiagOptionsBuilder;
struct MatrixDiagOptionsT;

struct QuantizeOptions;
struct QuantizeOptionsBuilder;
struct QuantizeOptionsT;

struct MatrixSetDiagOptions;
struct MatrixSetDiagOptionsBuilder;
struct MatrixSetDiagOptionsT;

struct IfOptions;
struct IfOptionsBuilder;
struct IfOptionsT;

struct CallOnceOptions;
struct CallOnceOptionsBuilder;
struct CallOnceOptionsT;

struct WhileOptions;
struct WhileOptionsBuilder;
struct WhileOptionsT;

struct NonMaxSuppressionV4Options;
struct NonMaxSuppressionV4OptionsBuilder;
struct NonMaxSuppressionV4OptionsT;

struct NonMaxSuppressionV5Options;
struct NonMaxSuppressionV5OptionsBuilder;
struct NonMaxSuppressionV5OptionsT;

struct ScatterNdOptions;
struct ScatterNdOptionsBuilder;
struct ScatterNdOptionsT;

struct SelectV2Options;
struct SelectV2OptionsBuilder;
struct SelectV2OptionsT;

struct DensifyOptions;
struct DensifyOptionsBuilder;
struct DensifyOptionsT;

struct SegmentSumOptions;
struct SegmentSumOptionsBuilder;
struct SegmentSumOptionsT;

struct BatchMatMulOptions;
struct BatchMatMulOptionsBuilder;
struct BatchMatMulOptionsT;

struct CumsumOptions;
struct CumsumOptionsBuilder;
struct CumsumOptionsT;

struct BroadcastToOptions;
struct BroadcastToOptionsBuilder;
struct BroadcastToOptionsT;

struct Rfft2dOptions;
struct Rfft2dOptionsBuilder;
struct Rfft2dOptionsT;

struct HashtableOptions;
struct HashtableOptionsBuilder;
struct HashtableOptionsT;

struct HashtableFindOptions;
struct HashtableFindOptionsBuilder;
struct HashtableFindOptionsT;

struct HashtableImportOptions;
struct HashtableImportOptionsBuilder;
struct HashtableImportOptionsT;

struct HashtableSizeOptions;
struct HashtableSizeOptionsBuilder;
struct HashtableSizeOptionsT;

struct VarHandleOptions;
struct VarHandleOptionsBuilder;
struct VarHandleOptionsT;

struct ReadVariableOptions;
struct ReadVariableOptionsBuilder;
struct ReadVariableOptionsT;

struct AssignVariableOptions;
struct AssignVariableOptionsBuilder;
struct AssignVariableOptionsT;

struct RandomOptions;
struct RandomOptionsBuilder;
struct RandomOptionsT;

struct BCQGatherOptions;
struct BCQGatherOptionsBuilder;
struct BCQGatherOptionsT;

struct BCQFullyConnectedOptions;
struct BCQFullyConnectedOptionsBuilder;
struct BCQFullyConnectedOptionsT;

struct InstanceNormOptions;
struct InstanceNormOptionsBuilder;
struct InstanceNormOptionsT;

struct OperatorCode;
struct OperatorCodeBuilder;
struct OperatorCodeT;

struct Operator;
struct OperatorBuilder;
struct OperatorT;

struct SubGraph;
struct SubGraphBuilder;
struct SubGraphT;

struct Buffer;
struct BufferBuilder;
struct BufferT;

struct Metadata;
struct MetadataBuilder;
struct MetadataT;

struct TensorMap;
struct TensorMapBuilder;
struct TensorMapT;

struct SignatureDef;
struct SignatureDefBuilder;
struct SignatureDefT;

struct Model;
struct ModelBuilder;
struct ModelT;

enum TensorType : int8_t
{
  TensorType_FLOAT32 = 0,
  TensorType_FLOAT16 = 1,
  TensorType_INT32 = 2,
  TensorType_UINT8 = 3,
  TensorType_INT64 = 4,
  TensorType_STRING = 5,
  TensorType_BOOL = 6,
  TensorType_INT16 = 7,
  TensorType_COMPLEX64 = 8,
  TensorType_INT8 = 9,
  TensorType_FLOAT64 = 10,
  TensorType_COMPLEX128 = 11,
  TensorType_UINT64 = 12,
  TensorType_RESOURCE = 13,
  TensorType_VARIANT = 14,
  TensorType_UINT32 = 15,
  TensorType_MIN = TensorType_FLOAT32,
  TensorType_MAX = TensorType_UINT32
};

inline const TensorType (&EnumValuesTensorType())[16]
{
  static const TensorType values[] = {
    TensorType_FLOAT32,   TensorType_FLOAT16,  TensorType_INT32,   TensorType_UINT8,
    TensorType_INT64,     TensorType_STRING,   TensorType_BOOL,    TensorType_INT16,
    TensorType_COMPLEX64, TensorType_INT8,     TensorType_FLOAT64, TensorType_COMPLEX128,
    TensorType_UINT64,    TensorType_RESOURCE, TensorType_VARIANT, TensorType_UINT32};
  return values;
}

inline const char *const *EnumNamesTensorType()
{
  static const char *const names[17] = {"FLOAT32", "FLOAT16",    "INT32",  "UINT8",     "INT64",
                                        "STRING",  "BOOL",       "INT16",  "COMPLEX64", "INT8",
                                        "FLOAT64", "COMPLEX128", "UINT64", "RESOURCE",  "VARIANT",
                                        "UINT32",  nullptr};
  return names;
}

inline const char *EnumNameTensorType(TensorType e)
{
  if (flatbuffers::IsOutRange(e, TensorType_FLOAT32, TensorType_UINT32))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTensorType()[index];
}

enum QuantizationDetails : uint8_t
{
  QuantizationDetails_NONE = 0,
  QuantizationDetails_CustomQuantization = 1,
  QuantizationDetails_MIN = QuantizationDetails_NONE,
  QuantizationDetails_MAX = QuantizationDetails_CustomQuantization
};

inline const QuantizationDetails (&EnumValuesQuantizationDetails())[2]
{
  static const QuantizationDetails values[] = {QuantizationDetails_NONE,
                                               QuantizationDetails_CustomQuantization};
  return values;
}

inline const char *const *EnumNamesQuantizationDetails()
{
  static const char *const names[3] = {"NONE", "CustomQuantization", nullptr};
  return names;
}

inline const char *EnumNameQuantizationDetails(QuantizationDetails e)
{
  if (flatbuffers::IsOutRange(e, QuantizationDetails_NONE, QuantizationDetails_CustomQuantization))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesQuantizationDetails()[index];
}

template <typename T> struct QuantizationDetailsTraits
{
  static const QuantizationDetails enum_value = QuantizationDetails_NONE;
};

template <> struct QuantizationDetailsTraits<circle::CustomQuantization>
{
  static const QuantizationDetails enum_value = QuantizationDetails_CustomQuantization;
};

struct QuantizationDetailsUnion
{
  QuantizationDetails type;
  void *value;

  QuantizationDetailsUnion() : type(QuantizationDetails_NONE), value(nullptr) {}
  QuantizationDetailsUnion(QuantizationDetailsUnion &&u) FLATBUFFERS_NOEXCEPT
    : type(QuantizationDetails_NONE),
      value(nullptr)
  {
    std::swap(type, u.type);
    std::swap(value, u.value);
  }
  QuantizationDetailsUnion(const QuantizationDetailsUnion &);
  QuantizationDetailsUnion &operator=(const QuantizationDetailsUnion &u)
  {
    QuantizationDetailsUnion t(u);
    std::swap(type, t.type);
    std::swap(value, t.value);
    return *this;
  }
  QuantizationDetailsUnion &operator=(QuantizationDetailsUnion &&u) FLATBUFFERS_NOEXCEPT
  {
    std::swap(type, u.type);
    std::swap(value, u.value);
    return *this;
  }
  ~QuantizationDetailsUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T> void Set(T &&val)
  {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = QuantizationDetailsTraits<typename RT::TableType>::enum_value;
    if (type != QuantizationDetails_NONE)
    {
      value = new RT(std::forward<T>(val));
    }
  }
#endif // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, QuantizationDetails type,
                      const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  circle::CustomQuantizationT *AsCustomQuantization()
  {
    return type == QuantizationDetails_CustomQuantization
             ? reinterpret_cast<circle::CustomQuantizationT *>(value)
             : nullptr;
  }
  const circle::CustomQuantizationT *AsCustomQuantization() const
  {
    return type == QuantizationDetails_CustomQuantization
             ? reinterpret_cast<const circle::CustomQuantizationT *>(value)
             : nullptr;
  }
};

bool VerifyQuantizationDetails(flatbuffers::Verifier &verifier, const void *obj,
                               QuantizationDetails type);
bool VerifyQuantizationDetailsVector(flatbuffers::Verifier &verifier,
                                     const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
                                     const flatbuffers::Vector<uint8_t> *types);

enum DimensionType : int8_t
{
  DimensionType_DENSE = 0,
  DimensionType_SPARSE_CSR = 1,
  DimensionType_MIN = DimensionType_DENSE,
  DimensionType_MAX = DimensionType_SPARSE_CSR
};

inline const DimensionType (&EnumValuesDimensionType())[2]
{
  static const DimensionType values[] = {DimensionType_DENSE, DimensionType_SPARSE_CSR};
  return values;
}

inline const char *const *EnumNamesDimensionType()
{
  static const char *const names[3] = {"DENSE", "SPARSE_CSR", nullptr};
  return names;
}

inline const char *EnumNameDimensionType(DimensionType e)
{
  if (flatbuffers::IsOutRange(e, DimensionType_DENSE, DimensionType_SPARSE_CSR))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDimensionType()[index];
}

enum SparseIndexVector : uint8_t
{
  SparseIndexVector_NONE = 0,
  SparseIndexVector_Int32Vector = 1,
  SparseIndexVector_Uint16Vector = 2,
  SparseIndexVector_Uint8Vector = 3,
  SparseIndexVector_MIN = SparseIndexVector_NONE,
  SparseIndexVector_MAX = SparseIndexVector_Uint8Vector
};

inline const SparseIndexVector (&EnumValuesSparseIndexVector())[4]
{
  static const SparseIndexVector values[] = {SparseIndexVector_NONE, SparseIndexVector_Int32Vector,
                                             SparseIndexVector_Uint16Vector,
                                             SparseIndexVector_Uint8Vector};
  return values;
}

inline const char *const *EnumNamesSparseIndexVector()
{
  static const char *const names[5] = {"NONE", "Int32Vector", "Uint16Vector", "Uint8Vector",
                                       nullptr};
  return names;
}

inline const char *EnumNameSparseIndexVector(SparseIndexVector e)
{
  if (flatbuffers::IsOutRange(e, SparseIndexVector_NONE, SparseIndexVector_Uint8Vector))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSparseIndexVector()[index];
}

template <typename T> struct SparseIndexVectorTraits
{
  static const SparseIndexVector enum_value = SparseIndexVector_NONE;
};

template <> struct SparseIndexVectorTraits<circle::Int32Vector>
{
  static const SparseIndexVector enum_value = SparseIndexVector_Int32Vector;
};

template <> struct SparseIndexVectorTraits<circle::Uint16Vector>
{
  static const SparseIndexVector enum_value = SparseIndexVector_Uint16Vector;
};

template <> struct SparseIndexVectorTraits<circle::Uint8Vector>
{
  static const SparseIndexVector enum_value = SparseIndexVector_Uint8Vector;
};

struct SparseIndexVectorUnion
{
  SparseIndexVector type;
  void *value;

  SparseIndexVectorUnion() : type(SparseIndexVector_NONE), value(nullptr) {}
  SparseIndexVectorUnion(SparseIndexVectorUnion &&u) FLATBUFFERS_NOEXCEPT
    : type(SparseIndexVector_NONE),
      value(nullptr)
  {
    std::swap(type, u.type);
    std::swap(value, u.value);
  }
  SparseIndexVectorUnion(const SparseIndexVectorUnion &);
  SparseIndexVectorUnion &operator=(const SparseIndexVectorUnion &u)
  {
    SparseIndexVectorUnion t(u);
    std::swap(type, t.type);
    std::swap(value, t.value);
    return *this;
  }
  SparseIndexVectorUnion &operator=(SparseIndexVectorUnion &&u) FLATBUFFERS_NOEXCEPT
  {
    std::swap(type, u.type);
    std::swap(value, u.value);
    return *this;
  }
  ~SparseIndexVectorUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T> void Set(T &&val)
  {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = SparseIndexVectorTraits<typename RT::TableType>::enum_value;
    if (type != SparseIndexVector_NONE)
    {
      value = new RT(std::forward<T>(val));
    }
  }
#endif // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, SparseIndexVector type,
                      const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  circle::Int32VectorT *AsInt32Vector()
  {
    return type == SparseIndexVector_Int32Vector ? reinterpret_cast<circle::Int32VectorT *>(value)
                                                 : nullptr;
  }
  const circle::Int32VectorT *AsInt32Vector() const
  {
    return type == SparseIndexVector_Int32Vector
             ? reinterpret_cast<const circle::Int32VectorT *>(value)
             : nullptr;
  }
  circle::Uint16VectorT *AsUint16Vector()
  {
    return type == SparseIndexVector_Uint16Vector ? reinterpret_cast<circle::Uint16VectorT *>(value)
                                                  : nullptr;
  }
  const circle::Uint16VectorT *AsUint16Vector() const
  {
    return type == SparseIndexVector_Uint16Vector
             ? reinterpret_cast<const circle::Uint16VectorT *>(value)
             : nullptr;
  }
  circle::Uint8VectorT *AsUint8Vector()
  {
    return type == SparseIndexVector_Uint8Vector ? reinterpret_cast<circle::Uint8VectorT *>(value)
                                                 : nullptr;
  }
  const circle::Uint8VectorT *AsUint8Vector() const
  {
    return type == SparseIndexVector_Uint8Vector
             ? reinterpret_cast<const circle::Uint8VectorT *>(value)
             : nullptr;
  }
};

bool VerifySparseIndexVector(flatbuffers::Verifier &verifier, const void *obj,
                             SparseIndexVector type);
bool VerifySparseIndexVectorVector(flatbuffers::Verifier &verifier,
                                   const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
                                   const flatbuffers::Vector<uint8_t> *types);

enum BuiltinOperator : int32_t
{
  BuiltinOperator_BCQ_GATHER = -4,
  BuiltinOperator_BCQ_FULLY_CONNECTED = -3,
  BuiltinOperator_INSTANCE_NORM = -2,
  BuiltinOperator_ADD = 0,
  BuiltinOperator_AVERAGE_POOL_2D = 1,
  BuiltinOperator_CONCATENATION = 2,
  BuiltinOperator_CONV_2D = 3,
  BuiltinOperator_DEPTHWISE_CONV_2D = 4,
  BuiltinOperator_DEPTH_TO_SPACE = 5,
  BuiltinOperator_DEQUANTIZE = 6,
  BuiltinOperator_EMBEDDING_LOOKUP = 7,
  BuiltinOperator_FLOOR = 8,
  BuiltinOperator_FULLY_CONNECTED = 9,
  BuiltinOperator_HASHTABLE_LOOKUP = 10,
  BuiltinOperator_L2_NORMALIZATION = 11,
  BuiltinOperator_L2_POOL_2D = 12,
  BuiltinOperator_LOCAL_RESPONSE_NORMALIZATION = 13,
  BuiltinOperator_LOGISTIC = 14,
  BuiltinOperator_LSH_PROJECTION = 15,
  BuiltinOperator_LSTM = 16,
  BuiltinOperator_MAX_POOL_2D = 17,
  BuiltinOperator_MUL = 18,
  BuiltinOperator_RELU = 19,
  BuiltinOperator_RELU_N1_TO_1 = 20,
  BuiltinOperator_RELU6 = 21,
  BuiltinOperator_RESHAPE = 22,
  BuiltinOperator_RESIZE_BILINEAR = 23,
  BuiltinOperator_RNN = 24,
  BuiltinOperator_SOFTMAX = 25,
  BuiltinOperator_SPACE_TO_DEPTH = 26,
  BuiltinOperator_SVDF = 27,
  BuiltinOperator_TANH = 28,
  BuiltinOperator_CONCAT_EMBEDDINGS = 29,
  BuiltinOperator_SKIP_GRAM = 30,
  BuiltinOperator_CALL = 31,
  BuiltinOperator_CUSTOM = 32,
  BuiltinOperator_EMBEDDING_LOOKUP_SPARSE = 33,
  BuiltinOperator_PAD = 34,
  BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_RNN = 35,
  BuiltinOperator_GATHER = 36,
  BuiltinOperator_BATCH_TO_SPACE_ND = 37,
  BuiltinOperator_SPACE_TO_BATCH_ND = 38,
  BuiltinOperator_TRANSPOSE = 39,
  BuiltinOperator_MEAN = 40,
  BuiltinOperator_SUB = 41,
  BuiltinOperator_DIV = 42,
  BuiltinOperator_SQUEEZE = 43,
  BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_LSTM = 44,
  BuiltinOperator_STRIDED_SLICE = 45,
  BuiltinOperator_BIDIRECTIONAL_SEQUENCE_RNN = 46,
  BuiltinOperator_EXP = 47,
  BuiltinOperator_TOPK_V2 = 48,
  BuiltinOperator_SPLIT = 49,
  BuiltinOperator_LOG_SOFTMAX = 50,
  BuiltinOperator_DELEGATE = 51,
  BuiltinOperator_BIDIRECTIONAL_SEQUENCE_LSTM = 52,
  BuiltinOperator_CAST = 53,
  BuiltinOperator_PRELU = 54,
  BuiltinOperator_MAXIMUM = 55,
  BuiltinOperator_ARG_MAX = 56,
  BuiltinOperator_MINIMUM = 57,
  BuiltinOperator_LESS = 58,
  BuiltinOperator_NEG = 59,
  BuiltinOperator_PADV2 = 60,
  BuiltinOperator_GREATER = 61,
  BuiltinOperator_GREATER_EQUAL = 62,
  BuiltinOperator_LESS_EQUAL = 63,
  BuiltinOperator_SELECT = 64,
  BuiltinOperator_SLICE = 65,
  BuiltinOperator_SIN = 66,
  BuiltinOperator_TRANSPOSE_CONV = 67,
  BuiltinOperator_SPARSE_TO_DENSE = 68,
  BuiltinOperator_TILE = 69,
  BuiltinOperator_EXPAND_DIMS = 70,
  BuiltinOperator_EQUAL = 71,
  BuiltinOperator_NOT_EQUAL = 72,
  BuiltinOperator_LOG = 73,
  BuiltinOperator_SUM = 74,
  BuiltinOperator_SQRT = 75,
  BuiltinOperator_RSQRT = 76,
  BuiltinOperator_SHAPE = 77,
  BuiltinOperator_POW = 78,
  BuiltinOperator_ARG_MIN = 79,
  BuiltinOperator_FAKE_QUANT = 80,
  BuiltinOperator_REDUCE_PROD = 81,
  BuiltinOperator_REDUCE_MAX = 82,
  BuiltinOperator_PACK = 83,
  BuiltinOperator_LOGICAL_OR = 84,
  BuiltinOperator_ONE_HOT = 85,
  BuiltinOperator_LOGICAL_AND = 86,
  BuiltinOperator_LOGICAL_NOT = 87,
  BuiltinOperator_UNPACK = 88,
  BuiltinOperator_REDUCE_MIN = 89,
  BuiltinOperator_FLOOR_DIV = 90,
  BuiltinOperator_REDUCE_ANY = 91,
  BuiltinOperator_SQUARE = 92,
  BuiltinOperator_ZEROS_LIKE = 93,
  BuiltinOperator_FILL = 94,
  BuiltinOperator_FLOOR_MOD = 95,
  BuiltinOperator_RANGE = 96,
  BuiltinOperator_RESIZE_NEAREST_NEIGHBOR = 97,
  BuiltinOperator_LEAKY_RELU = 98,
  BuiltinOperator_SQUARED_DIFFERENCE = 99,
  BuiltinOperator_MIRROR_PAD = 100,
  BuiltinOperator_ABS = 101,
  BuiltinOperator_SPLIT_V = 102,
  BuiltinOperator_UNIQUE = 103,
  BuiltinOperator_CEIL = 104,
  BuiltinOperator_REVERSE_V2 = 105,
  BuiltinOperator_ADD_N = 106,
  BuiltinOperator_GATHER_ND = 107,
  BuiltinOperator_COS = 108,
  BuiltinOperator_WHERE = 109,
  BuiltinOperator_RANK = 110,
  BuiltinOperator_ELU = 111,
  BuiltinOperator_REVERSE_SEQUENCE = 112,
  BuiltinOperator_MATRIX_DIAG = 113,
  BuiltinOperator_QUANTIZE = 114,
  BuiltinOperator_MATRIX_SET_DIAG = 115,
  BuiltinOperator_ROUND = 116,
  BuiltinOperator_HARD_SWISH = 117,
  BuiltinOperator_IF = 118,
  BuiltinOperator_WHILE = 119,
  BuiltinOperator_NON_MAX_SUPPRESSION_V4 = 120,
  BuiltinOperator_NON_MAX_SUPPRESSION_V5 = 121,
  BuiltinOperator_SCATTER_ND = 122,
  BuiltinOperator_SELECT_V2 = 123,
  BuiltinOperator_DENSIFY = 124,
  BuiltinOperator_SEGMENT_SUM = 125,
  BuiltinOperator_BATCH_MATMUL = 126,
  BuiltinOperator_PLACEHOLDER_FOR_GREATER_OP_CODES = 127,
  BuiltinOperator_CUMSUM = 128,
  BuiltinOperator_CALL_ONCE = 129,
  BuiltinOperator_BROADCAST_TO = 130,
  BuiltinOperator_RFFT2D = 131,
  BuiltinOperator_CONV_3D = 132,
  BuiltinOperator_IMAG = 133,
  BuiltinOperator_REAL = 134,
  BuiltinOperator_COMPLEX_ABS = 135,
  BuiltinOperator_HASHTABLE = 136,
  BuiltinOperator_HASHTABLE_FIND = 137,
  BuiltinOperator_HASHTABLE_IMPORT = 138,
  BuiltinOperator_HASHTABLE_SIZE = 139,
  BuiltinOperator_REDUCE_ALL = 140,
  BuiltinOperator_CONV_3D_TRANSPOSE = 141,
  BuiltinOperator_VAR_HANDLE = 142,
  BuiltinOperator_READ_VARIABLE = 143,
  BuiltinOperator_ASSIGN_VARIABLE = 144,
  BuiltinOperator_BROADCAST_ARGS = 145,
  BuiltinOperator_RANDOM_STANDARD_NORMAL = 146,
  BuiltinOperator_MIN = BuiltinOperator_BCQ_GATHER,
  BuiltinOperator_MAX = BuiltinOperator_RANDOM_STANDARD_NORMAL
};

inline const BuiltinOperator (&EnumValuesBuiltinOperator())[150]
{
  static const BuiltinOperator values[] = {BuiltinOperator_BCQ_GATHER,
                                           BuiltinOperator_BCQ_FULLY_CONNECTED,
                                           BuiltinOperator_INSTANCE_NORM,
                                           BuiltinOperator_ADD,
                                           BuiltinOperator_AVERAGE_POOL_2D,
                                           BuiltinOperator_CONCATENATION,
                                           BuiltinOperator_CONV_2D,
                                           BuiltinOperator_DEPTHWISE_CONV_2D,
                                           BuiltinOperator_DEPTH_TO_SPACE,
                                           BuiltinOperator_DEQUANTIZE,
                                           BuiltinOperator_EMBEDDING_LOOKUP,
                                           BuiltinOperator_FLOOR,
                                           BuiltinOperator_FULLY_CONNECTED,
                                           BuiltinOperator_HASHTABLE_LOOKUP,
                                           BuiltinOperator_L2_NORMALIZATION,
                                           BuiltinOperator_L2_POOL_2D,
                                           BuiltinOperator_LOCAL_RESPONSE_NORMALIZATION,
                                           BuiltinOperator_LOGISTIC,
                                           BuiltinOperator_LSH_PROJECTION,
                                           BuiltinOperator_LSTM,
                                           BuiltinOperator_MAX_POOL_2D,
                                           BuiltinOperator_MUL,
                                           BuiltinOperator_RELU,
                                           BuiltinOperator_RELU_N1_TO_1,
                                           BuiltinOperator_RELU6,
                                           BuiltinOperator_RESHAPE,
                                           BuiltinOperator_RESIZE_BILINEAR,
                                           BuiltinOperator_RNN,
                                           BuiltinOperator_SOFTMAX,
                                           BuiltinOperator_SPACE_TO_DEPTH,
                                           BuiltinOperator_SVDF,
                                           BuiltinOperator_TANH,
                                           BuiltinOperator_CONCAT_EMBEDDINGS,
                                           BuiltinOperator_SKIP_GRAM,
                                           BuiltinOperator_CALL,
                                           BuiltinOperator_CUSTOM,
                                           BuiltinOperator_EMBEDDING_LOOKUP_SPARSE,
                                           BuiltinOperator_PAD,
                                           BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_RNN,
                                           BuiltinOperator_GATHER,
                                           BuiltinOperator_BATCH_TO_SPACE_ND,
                                           BuiltinOperator_SPACE_TO_BATCH_ND,
                                           BuiltinOperator_TRANSPOSE,
                                           BuiltinOperator_MEAN,
                                           BuiltinOperator_SUB,
                                           BuiltinOperator_DIV,
                                           BuiltinOperator_SQUEEZE,
                                           BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_LSTM,
                                           BuiltinOperator_STRIDED_SLICE,
                                           BuiltinOperator_BIDIRECTIONAL_SEQUENCE_RNN,
                                           BuiltinOperator_EXP,
                                           BuiltinOperator_TOPK_V2,
                                           BuiltinOperator_SPLIT,
                                           BuiltinOperator_LOG_SOFTMAX,
                                           BuiltinOperator_DELEGATE,
                                           BuiltinOperator_BIDIRECTIONAL_SEQUENCE_LSTM,
                                           BuiltinOperator_CAST,
                                           BuiltinOperator_PRELU,
                                           BuiltinOperator_MAXIMUM,
                                           BuiltinOperator_ARG_MAX,
                                           BuiltinOperator_MINIMUM,
                                           BuiltinOperator_LESS,
                                           BuiltinOperator_NEG,
                                           BuiltinOperator_PADV2,
                                           BuiltinOperator_GREATER,
                                           BuiltinOperator_GREATER_EQUAL,
                                           BuiltinOperator_LESS_EQUAL,
                                           BuiltinOperator_SELECT,
                                           BuiltinOperator_SLICE,
                                           BuiltinOperator_SIN,
                                           BuiltinOperator_TRANSPOSE_CONV,
                                           BuiltinOperator_SPARSE_TO_DENSE,
                                           BuiltinOperator_TILE,
                                           BuiltinOperator_EXPAND_DIMS,
                                           BuiltinOperator_EQUAL,
                                           BuiltinOperator_NOT_EQUAL,
                                           BuiltinOperator_LOG,
                                           BuiltinOperator_SUM,
                                           BuiltinOperator_SQRT,
                                           BuiltinOperator_RSQRT,
                                           BuiltinOperator_SHAPE,
                                           BuiltinOperator_POW,
                                           BuiltinOperator_ARG_MIN,
                                           BuiltinOperator_FAKE_QUANT,
                                           BuiltinOperator_REDUCE_PROD,
                                           BuiltinOperator_REDUCE_MAX,
                                           BuiltinOperator_PACK,
                                           BuiltinOperator_LOGICAL_OR,
                                           BuiltinOperator_ONE_HOT,
                                           BuiltinOperator_LOGICAL_AND,
                                           BuiltinOperator_LOGICAL_NOT,
                                           BuiltinOperator_UNPACK,
                                           BuiltinOperator_REDUCE_MIN,
                                           BuiltinOperator_FLOOR_DIV,
                                           BuiltinOperator_REDUCE_ANY,
                                           BuiltinOperator_SQUARE,
                                           BuiltinOperator_ZEROS_LIKE,
                                           BuiltinOperator_FILL,
                                           BuiltinOperator_FLOOR_MOD,
                                           BuiltinOperator_RANGE,
                                           BuiltinOperator_RESIZE_NEAREST_NEIGHBOR,
                                           BuiltinOperator_LEAKY_RELU,
                                           BuiltinOperator_SQUARED_DIFFERENCE,
                                           BuiltinOperator_MIRROR_PAD,
                                           BuiltinOperator_ABS,
                                           BuiltinOperator_SPLIT_V,
                                           BuiltinOperator_UNIQUE,
                                           BuiltinOperator_CEIL,
                                           BuiltinOperator_REVERSE_V2,
                                           BuiltinOperator_ADD_N,
                                           BuiltinOperator_GATHER_ND,
                                           BuiltinOperator_COS,
                                           BuiltinOperator_WHERE,
                                           BuiltinOperator_RANK,
                                           BuiltinOperator_ELU,
                                           BuiltinOperator_REVERSE_SEQUENCE,
                                           BuiltinOperator_MATRIX_DIAG,
                                           BuiltinOperator_QUANTIZE,
                                           BuiltinOperator_MATRIX_SET_DIAG,
                                           BuiltinOperator_ROUND,
                                           BuiltinOperator_HARD_SWISH,
                                           BuiltinOperator_IF,
                                           BuiltinOperator_WHILE,
                                           BuiltinOperator_NON_MAX_SUPPRESSION_V4,
                                           BuiltinOperator_NON_MAX_SUPPRESSION_V5,
                                           BuiltinOperator_SCATTER_ND,
                                           BuiltinOperator_SELECT_V2,
                                           BuiltinOperator_DENSIFY,
                                           BuiltinOperator_SEGMENT_SUM,
                                           BuiltinOperator_BATCH_MATMUL,
                                           BuiltinOperator_PLACEHOLDER_FOR_GREATER_OP_CODES,
                                           BuiltinOperator_CUMSUM,
                                           BuiltinOperator_CALL_ONCE,
                                           BuiltinOperator_BROADCAST_TO,
                                           BuiltinOperator_RFFT2D,
                                           BuiltinOperator_CONV_3D,
                                           BuiltinOperator_IMAG,
                                           BuiltinOperator_REAL,
                                           BuiltinOperator_COMPLEX_ABS,
                                           BuiltinOperator_HASHTABLE,
                                           BuiltinOperator_HASHTABLE_FIND,
                                           BuiltinOperator_HASHTABLE_IMPORT,
                                           BuiltinOperator_HASHTABLE_SIZE,
                                           BuiltinOperator_REDUCE_ALL,
                                           BuiltinOperator_CONV_3D_TRANSPOSE,
                                           BuiltinOperator_VAR_HANDLE,
                                           BuiltinOperator_READ_VARIABLE,
                                           BuiltinOperator_ASSIGN_VARIABLE,
                                           BuiltinOperator_BROADCAST_ARGS,
                                           BuiltinOperator_RANDOM_STANDARD_NORMAL};
  return values;
}

inline const char *const *EnumNamesBuiltinOperator()
{
  static const char *const names[152] = {"BCQ_GATHER",
                                         "BCQ_FULLY_CONNECTED",
                                         "INSTANCE_NORM",
                                         "",
                                         "ADD",
                                         "AVERAGE_POOL_2D",
                                         "CONCATENATION",
                                         "CONV_2D",
                                         "DEPTHWISE_CONV_2D",
                                         "DEPTH_TO_SPACE",
                                         "DEQUANTIZE",
                                         "EMBEDDING_LOOKUP",
                                         "FLOOR",
                                         "FULLY_CONNECTED",
                                         "HASHTABLE_LOOKUP",
                                         "L2_NORMALIZATION",
                                         "L2_POOL_2D",
                                         "LOCAL_RESPONSE_NORMALIZATION",
                                         "LOGISTIC",
                                         "LSH_PROJECTION",
                                         "LSTM",
                                         "MAX_POOL_2D",
                                         "MUL",
                                         "RELU",
                                         "RELU_N1_TO_1",
                                         "RELU6",
                                         "RESHAPE",
                                         "RESIZE_BILINEAR",
                                         "RNN",
                                         "SOFTMAX",
                                         "SPACE_TO_DEPTH",
                                         "SVDF",
                                         "TANH",
                                         "CONCAT_EMBEDDINGS",
                                         "SKIP_GRAM",
                                         "CALL",
                                         "CUSTOM",
                                         "EMBEDDING_LOOKUP_SPARSE",
                                         "PAD",
                                         "UNIDIRECTIONAL_SEQUENCE_RNN",
                                         "GATHER",
                                         "BATCH_TO_SPACE_ND",
                                         "SPACE_TO_BATCH_ND",
                                         "TRANSPOSE",
                                         "MEAN",
                                         "SUB",
                                         "DIV",
                                         "SQUEEZE",
                                         "UNIDIRECTIONAL_SEQUENCE_LSTM",
                                         "STRIDED_SLICE",
                                         "BIDIRECTIONAL_SEQUENCE_RNN",
                                         "EXP",
                                         "TOPK_V2",
                                         "SPLIT",
                                         "LOG_SOFTMAX",
                                         "DELEGATE",
                                         "BIDIRECTIONAL_SEQUENCE_LSTM",
                                         "CAST",
                                         "PRELU",
                                         "MAXIMUM",
                                         "ARG_MAX",
                                         "MINIMUM",
                                         "LESS",
                                         "NEG",
                                         "PADV2",
                                         "GREATER",
                                         "GREATER_EQUAL",
                                         "LESS_EQUAL",
                                         "SELECT",
                                         "SLICE",
                                         "SIN",
                                         "TRANSPOSE_CONV",
                                         "SPARSE_TO_DENSE",
                                         "TILE",
                                         "EXPAND_DIMS",
                                         "EQUAL",
                                         "NOT_EQUAL",
                                         "LOG",
                                         "SUM",
                                         "SQRT",
                                         "RSQRT",
                                         "SHAPE",
                                         "POW",
                                         "ARG_MIN",
                                         "FAKE_QUANT",
                                         "REDUCE_PROD",
                                         "REDUCE_MAX",
                                         "PACK",
                                         "LOGICAL_OR",
                                         "ONE_HOT",
                                         "LOGICAL_AND",
                                         "LOGICAL_NOT",
                                         "UNPACK",
                                         "REDUCE_MIN",
                                         "FLOOR_DIV",
                                         "REDUCE_ANY",
                                         "SQUARE",
                                         "ZEROS_LIKE",
                                         "FILL",
                                         "FLOOR_MOD",
                                         "RANGE",
                                         "RESIZE_NEAREST_NEIGHBOR",
                                         "LEAKY_RELU",
                                         "SQUARED_DIFFERENCE",
                                         "MIRROR_PAD",
                                         "ABS",
                                         "SPLIT_V",
                                         "UNIQUE",
                                         "CEIL",
                                         "REVERSE_V2",
                                         "ADD_N",
                                         "GATHER_ND",
                                         "COS",
                                         "WHERE",
                                         "RANK",
                                         "ELU",
                                         "REVERSE_SEQUENCE",
                                         "MATRIX_DIAG",
                                         "QUANTIZE",
                                         "MATRIX_SET_DIAG",
                                         "ROUND",
                                         "HARD_SWISH",
                                         "IF",
                                         "WHILE",
                                         "NON_MAX_SUPPRESSION_V4",
                                         "NON_MAX_SUPPRESSION_V5",
                                         "SCATTER_ND",
                                         "SELECT_V2",
                                         "DENSIFY",
                                         "SEGMENT_SUM",
                                         "BATCH_MATMUL",
                                         "PLACEHOLDER_FOR_GREATER_OP_CODES",
                                         "CUMSUM",
                                         "CALL_ONCE",
                                         "BROADCAST_TO",
                                         "RFFT2D",
                                         "CONV_3D",
                                         "IMAG",
                                         "REAL",
                                         "COMPLEX_ABS",
                                         "HASHTABLE",
                                         "HASHTABLE_FIND",
                                         "HASHTABLE_IMPORT",
                                         "HASHTABLE_SIZE",
                                         "REDUCE_ALL",
                                         "CONV_3D_TRANSPOSE",
                                         "VAR_HANDLE",
                                         "READ_VARIABLE",
                                         "ASSIGN_VARIABLE",
                                         "BROADCAST_ARGS",
                                         "RANDOM_STANDARD_NORMAL",
                                         nullptr};
  return names;
}

inline const char *EnumNameBuiltinOperator(BuiltinOperator e)
{
  if (flatbuffers::IsOutRange(e, BuiltinOperator_BCQ_GATHER,
                              BuiltinOperator_RANDOM_STANDARD_NORMAL))
    return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(BuiltinOperator_BCQ_GATHER);
  return EnumNamesBuiltinOperator()[index];
}

enum BuiltinOptions : uint8_t
{
  BuiltinOptions_NONE = 0,
  BuiltinOptions_Conv2DOptions = 1,
  BuiltinOptions_DepthwiseConv2DOptions = 2,
  BuiltinOptions_ConcatEmbeddingsOptions = 3,
  BuiltinOptions_LSHProjectionOptions = 4,
  BuiltinOptions_Pool2DOptions = 5,
  BuiltinOptions_SVDFOptions = 6,
  BuiltinOptions_RNNOptions = 7,
  BuiltinOptions_FullyConnectedOptions = 8,
  BuiltinOptions_SoftmaxOptions = 9,
  BuiltinOptions_ConcatenationOptions = 10,
  BuiltinOptions_AddOptions = 11,
  BuiltinOptions_L2NormOptions = 12,
  BuiltinOptions_LocalResponseNormalizationOptions = 13,
  BuiltinOptions_LSTMOptions = 14,
  BuiltinOptions_ResizeBilinearOptions = 15,
  BuiltinOptions_CallOptions = 16,
  BuiltinOptions_ReshapeOptions = 17,
  BuiltinOptions_SkipGramOptions = 18,
  BuiltinOptions_SpaceToDepthOptions = 19,
  BuiltinOptions_EmbeddingLookupSparseOptions = 20,
  BuiltinOptions_MulOptions = 21,
  BuiltinOptions_PadOptions = 22,
  BuiltinOptions_GatherOptions = 23,
  BuiltinOptions_BatchToSpaceNDOptions = 24,
  BuiltinOptions_SpaceToBatchNDOptions = 25,
  BuiltinOptions_TransposeOptions = 26,
  BuiltinOptions_ReducerOptions = 27,
  BuiltinOptions_SubOptions = 28,
  BuiltinOptions_DivOptions = 29,
  BuiltinOptions_SqueezeOptions = 30,
  BuiltinOptions_SequenceRNNOptions = 31,
  BuiltinOptions_StridedSliceOptions = 32,
  BuiltinOptions_ExpOptions = 33,
  BuiltinOptions_TopKV2Options = 34,
  BuiltinOptions_SplitOptions = 35,
  BuiltinOptions_LogSoftmaxOptions = 36,
  BuiltinOptions_CastOptions = 37,
  BuiltinOptions_DequantizeOptions = 38,
  BuiltinOptions_MaximumMinimumOptions = 39,
  BuiltinOptions_ArgMaxOptions = 40,
  BuiltinOptions_LessOptions = 41,
  BuiltinOptions_NegOptions = 42,
  BuiltinOptions_PadV2Options = 43,
  BuiltinOptions_GreaterOptions = 44,
  BuiltinOptions_GreaterEqualOptions = 45,
  BuiltinOptions_LessEqualOptions = 46,
  BuiltinOptions_SelectOptions = 47,
  BuiltinOptions_SliceOptions = 48,
  BuiltinOptions_TransposeConvOptions = 49,
  BuiltinOptions_SparseToDenseOptions = 50,
  BuiltinOptions_TileOptions = 51,
  BuiltinOptions_ExpandDimsOptions = 52,
  BuiltinOptions_EqualOptions = 53,
  BuiltinOptions_NotEqualOptions = 54,
  BuiltinOptions_ShapeOptions = 55,
  BuiltinOptions_PowOptions = 56,
  BuiltinOptions_ArgMinOptions = 57,
  BuiltinOptions_FakeQuantOptions = 58,
  BuiltinOptions_PackOptions = 59,
  BuiltinOptions_LogicalOrOptions = 60,
  BuiltinOptions_OneHotOptions = 61,
  BuiltinOptions_LogicalAndOptions = 62,
  BuiltinOptions_LogicalNotOptions = 63,
  BuiltinOptions_UnpackOptions = 64,
  BuiltinOptions_FloorDivOptions = 65,
  BuiltinOptions_SquareOptions = 66,
  BuiltinOptions_ZerosLikeOptions = 67,
  BuiltinOptions_FillOptions = 68,
  BuiltinOptions_BidirectionalSequenceLSTMOptions = 69,
  BuiltinOptions_BidirectionalSequenceRNNOptions = 70,
  BuiltinOptions_UnidirectionalSequenceLSTMOptions = 71,
  BuiltinOptions_FloorModOptions = 72,
  BuiltinOptions_RangeOptions = 73,
  BuiltinOptions_ResizeNearestNeighborOptions = 74,
  BuiltinOptions_LeakyReluOptions = 75,
  BuiltinOptions_SquaredDifferenceOptions = 76,
  BuiltinOptions_MirrorPadOptions = 77,
  BuiltinOptions_AbsOptions = 78,
  BuiltinOptions_SplitVOptions = 79,
  BuiltinOptions_UniqueOptions = 80,
  BuiltinOptions_ReverseV2Options = 81,
  BuiltinOptions_AddNOptions = 82,
  BuiltinOptions_GatherNdOptions = 83,
  BuiltinOptions_CosOptions = 84,
  BuiltinOptions_WhereOptions = 85,
  BuiltinOptions_RankOptions = 86,
  BuiltinOptions_ReverseSequenceOptions = 87,
  BuiltinOptions_MatrixDiagOptions = 88,
  BuiltinOptions_QuantizeOptions = 89,
  BuiltinOptions_MatrixSetDiagOptions = 90,
  BuiltinOptions_HardSwishOptions = 91,
  BuiltinOptions_IfOptions = 92,
  BuiltinOptions_WhileOptions = 93,
  BuiltinOptions_DepthToSpaceOptions = 94,
  BuiltinOptions_NonMaxSuppressionV4Options = 95,
  BuiltinOptions_NonMaxSuppressionV5Options = 96,
  BuiltinOptions_ScatterNdOptions = 97,
  BuiltinOptions_SelectV2Options = 98,
  BuiltinOptions_DensifyOptions = 99,
  BuiltinOptions_SegmentSumOptions = 100,
  BuiltinOptions_BatchMatMulOptions = 101,
  BuiltinOptions_CumsumOptions = 102,
  BuiltinOptions_CallOnceOptions = 103,
  BuiltinOptions_BroadcastToOptions = 104,
  BuiltinOptions_Rfft2dOptions = 105,
  BuiltinOptions_Conv3DOptions = 106,
  BuiltinOptions_HashtableOptions = 107,
  BuiltinOptions_HashtableFindOptions = 108,
  BuiltinOptions_HashtableImportOptions = 109,
  BuiltinOptions_HashtableSizeOptions = 110,
  BuiltinOptions_VarHandleOptions = 111,
  BuiltinOptions_ReadVariableOptions = 112,
  BuiltinOptions_AssignVariableOptions = 113,
  BuiltinOptions_RandomOptions = 114,
  BuiltinOptions_BCQGatherOptions = 252,
  BuiltinOptions_BCQFullyConnectedOptions = 253,
  BuiltinOptions_InstanceNormOptions = 254,
  BuiltinOptions_MIN = BuiltinOptions_NONE,
  BuiltinOptions_MAX = BuiltinOptions_InstanceNormOptions
};

inline const BuiltinOptions (&EnumValuesBuiltinOptions())[118]
{
  static const BuiltinOptions values[] = {BuiltinOptions_NONE,
                                          BuiltinOptions_Conv2DOptions,
                                          BuiltinOptions_DepthwiseConv2DOptions,
                                          BuiltinOptions_ConcatEmbeddingsOptions,
                                          BuiltinOptions_LSHProjectionOptions,
                                          BuiltinOptions_Pool2DOptions,
                                          BuiltinOptions_SVDFOptions,
                                          BuiltinOptions_RNNOptions,
                                          BuiltinOptions_FullyConnectedOptions,
                                          BuiltinOptions_SoftmaxOptions,
                                          BuiltinOptions_ConcatenationOptions,
                                          BuiltinOptions_AddOptions,
                                          BuiltinOptions_L2NormOptions,
                                          BuiltinOptions_LocalResponseNormalizationOptions,
                                          BuiltinOptions_LSTMOptions,
                                          BuiltinOptions_ResizeBilinearOptions,
                                          BuiltinOptions_CallOptions,
                                          BuiltinOptions_ReshapeOptions,
                                          BuiltinOptions_SkipGramOptions,
                                          BuiltinOptions_SpaceToDepthOptions,
                                          BuiltinOptions_EmbeddingLookupSparseOptions,
                                          BuiltinOptions_MulOptions,
                                          BuiltinOptions_PadOptions,
                                          BuiltinOptions_GatherOptions,
                                          BuiltinOptions_BatchToSpaceNDOptions,
                                          BuiltinOptions_SpaceToBatchNDOptions,
                                          BuiltinOptions_TransposeOptions,
                                          BuiltinOptions_ReducerOptions,
                                          BuiltinOptions_SubOptions,
                                          BuiltinOptions_DivOptions,
                                          BuiltinOptions_SqueezeOptions,
                                          BuiltinOptions_SequenceRNNOptions,
                                          BuiltinOptions_StridedSliceOptions,
                                          BuiltinOptions_ExpOptions,
                                          BuiltinOptions_TopKV2Options,
                                          BuiltinOptions_SplitOptions,
                                          BuiltinOptions_LogSoftmaxOptions,
                                          BuiltinOptions_CastOptions,
                                          BuiltinOptions_DequantizeOptions,
                                          BuiltinOptions_MaximumMinimumOptions,
                                          BuiltinOptions_ArgMaxOptions,
                                          BuiltinOptions_LessOptions,
                                          BuiltinOptions_NegOptions,
                                          BuiltinOptions_PadV2Options,
                                          BuiltinOptions_GreaterOptions,
                                          BuiltinOptions_GreaterEqualOptions,
                                          BuiltinOptions_LessEqualOptions,
                                          BuiltinOptions_SelectOptions,
                                          BuiltinOptions_SliceOptions,
                                          BuiltinOptions_TransposeConvOptions,
                                          BuiltinOptions_SparseToDenseOptions,
                                          BuiltinOptions_TileOptions,
                                          BuiltinOptions_ExpandDimsOptions,
                                          BuiltinOptions_EqualOptions,
                                          BuiltinOptions_NotEqualOptions,
                                          BuiltinOptions_ShapeOptions,
                                          BuiltinOptions_PowOptions,
                                          BuiltinOptions_ArgMinOptions,
                                          BuiltinOptions_FakeQuantOptions,
                                          BuiltinOptions_PackOptions,
                                          BuiltinOptions_LogicalOrOptions,
                                          BuiltinOptions_OneHotOptions,
                                          BuiltinOptions_LogicalAndOptions,
                                          BuiltinOptions_LogicalNotOptions,
                                          BuiltinOptions_UnpackOptions,
                                          BuiltinOptions_FloorDivOptions,
                                          BuiltinOptions_SquareOptions,
                                          BuiltinOptions_ZerosLikeOptions,
                                          BuiltinOptions_FillOptions,
                                          BuiltinOptions_BidirectionalSequenceLSTMOptions,
                                          BuiltinOptions_BidirectionalSequenceRNNOptions,
                                          BuiltinOptions_UnidirectionalSequenceLSTMOptions,
                                          BuiltinOptions_FloorModOptions,
                                          BuiltinOptions_RangeOptions,
                                          BuiltinOptions_ResizeNearestNeighborOptions,
                                          BuiltinOptions_LeakyReluOptions,
                                          BuiltinOptions_SquaredDifferenceOptions,
                                          BuiltinOptions_MirrorPadOptions,
                                          BuiltinOptions_AbsOptions,
                                          BuiltinOptions_SplitVOptions,
                                          BuiltinOptions_UniqueOptions,
                                          BuiltinOptions_ReverseV2Options,
                                          BuiltinOptions_AddNOptions,
                                          BuiltinOptions_GatherNdOptions,
                                          BuiltinOptions_CosOptions,
                                          BuiltinOptions_WhereOptions,
                                          BuiltinOptions_RankOptions,
                                          BuiltinOptions_ReverseSequenceOptions,
                                          BuiltinOptions_MatrixDiagOptions,
                                          BuiltinOptions_QuantizeOptions,
                                          BuiltinOptions_MatrixSetDiagOptions,
                                          BuiltinOptions_HardSwishOptions,
                                          BuiltinOptions_IfOptions,
                                          BuiltinOptions_WhileOptions,
                                          BuiltinOptions_DepthToSpaceOptions,
                                          BuiltinOptions_NonMaxSuppressionV4Options,
                                          BuiltinOptions_NonMaxSuppressionV5Options,
                                          BuiltinOptions_ScatterNdOptions,
                                          BuiltinOptions_SelectV2Options,
                                          BuiltinOptions_DensifyOptions,
                                          BuiltinOptions_SegmentSumOptions,
                                          BuiltinOptions_BatchMatMulOptions,
                                          BuiltinOptions_CumsumOptions,
                                          BuiltinOptions_CallOnceOptions,
                                          BuiltinOptions_BroadcastToOptions,
                                          BuiltinOptions_Rfft2dOptions,
                                          BuiltinOptions_Conv3DOptions,
                                          BuiltinOptions_HashtableOptions,
                                          BuiltinOptions_HashtableFindOptions,
                                          BuiltinOptions_HashtableImportOptions,
                                          BuiltinOptions_HashtableSizeOptions,
                                          BuiltinOptions_VarHandleOptions,
                                          BuiltinOptions_ReadVariableOptions,
                                          BuiltinOptions_AssignVariableOptions,
                                          BuiltinOptions_RandomOptions,
                                          BuiltinOptions_BCQGatherOptions,
                                          BuiltinOptions_BCQFullyConnectedOptions,
                                          BuiltinOptions_InstanceNormOptions};
  return values;
}

inline const char *const *EnumNamesBuiltinOptions()
{
  static const char *const names[256] = {"NONE",
                                         "Conv2DOptions",
                                         "DepthwiseConv2DOptions",
                                         "ConcatEmbeddingsOptions",
                                         "LSHProjectionOptions",
                                         "Pool2DOptions",
                                         "SVDFOptions",
                                         "RNNOptions",
                                         "FullyConnectedOptions",
                                         "SoftmaxOptions",
                                         "ConcatenationOptions",
                                         "AddOptions",
                                         "L2NormOptions",
                                         "LocalResponseNormalizationOptions",
                                         "LSTMOptions",
                                         "ResizeBilinearOptions",
                                         "CallOptions",
                                         "ReshapeOptions",
                                         "SkipGramOptions",
                                         "SpaceToDepthOptions",
                                         "EmbeddingLookupSparseOptions",
                                         "MulOptions",
                                         "PadOptions",
                                         "GatherOptions",
                                         "BatchToSpaceNDOptions",
                                         "SpaceToBatchNDOptions",
                                         "TransposeOptions",
                                         "ReducerOptions",
                                         "SubOptions",
                                         "DivOptions",
                                         "SqueezeOptions",
                                         "SequenceRNNOptions",
                                         "StridedSliceOptions",
                                         "ExpOptions",
                                         "TopKV2Options",
                                         "SplitOptions",
                                         "LogSoftmaxOptions",
                                         "CastOptions",
                                         "DequantizeOptions",
                                         "MaximumMinimumOptions",
                                         "ArgMaxOptions",
                                         "LessOptions",
                                         "NegOptions",
                                         "PadV2Options",
                                         "GreaterOptions",
                                         "GreaterEqualOptions",
                                         "LessEqualOptions",
                                         "SelectOptions",
                                         "SliceOptions",
                                         "TransposeConvOptions",
                                         "SparseToDenseOptions",
                                         "TileOptions",
                                         "ExpandDimsOptions",
                                         "EqualOptions",
                                         "NotEqualOptions",
                                         "ShapeOptions",
                                         "PowOptions",
                                         "ArgMinOptions",
                                         "FakeQuantOptions",
                                         "PackOptions",
                                         "LogicalOrOptions",
                                         "OneHotOptions",
                                         "LogicalAndOptions",
                                         "LogicalNotOptions",
                                         "UnpackOptions",
                                         "FloorDivOptions",
                                         "SquareOptions",
                                         "ZerosLikeOptions",
                                         "FillOptions",
                                         "BidirectionalSequenceLSTMOptions",
                                         "BidirectionalSequenceRNNOptions",
                                         "UnidirectionalSequenceLSTMOptions",
                                         "FloorModOptions",
                                         "RangeOptions",
                                         "ResizeNearestNeighborOptions",
                                         "LeakyReluOptions",
                                         "SquaredDifferenceOptions",
                                         "MirrorPadOptions",
                                         "AbsOptions",
                                         "SplitVOptions",
                                         "UniqueOptions",
                                         "ReverseV2Options",
                                         "AddNOptions",
                                         "GatherNdOptions",
                                         "CosOptions",
                                         "WhereOptions",
                                         "RankOptions",
                                         "ReverseSequenceOptions",
                                         "MatrixDiagOptions",
                                         "QuantizeOptions",
                                         "MatrixSetDiagOptions",
                                         "HardSwishOptions",
                                         "IfOptions",
                                         "WhileOptions",
                                         "DepthToSpaceOptions",
                                         "NonMaxSuppressionV4Options",
                                         "NonMaxSuppressionV5Options",
                                         "ScatterNdOptions",
                                         "SelectV2Options",
                                         "DensifyOptions",
                                         "SegmentSumOptions",
                                         "BatchMatMulOptions",
                                         "CumsumOptions",
                                         "CallOnceOptions",
                                         "BroadcastToOptions",
                                         "Rfft2dOptions",
                                         "Conv3DOptions",
                                         "HashtableOptions",
                                         "HashtableFindOptions",
                                         "HashtableImportOptions",
                                         "HashtableSizeOptions",
                                         "VarHandleOptions",
                                         "ReadVariableOptions",
                                         "AssignVariableOptions",
                                         "RandomOptions",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "",
                                         "BCQGatherOptions",
                                         "BCQFullyConnectedOptions",
                                         "InstanceNormOptions",
                                         nullptr};
  return names;
}

inline const char *EnumNameBuiltinOptions(BuiltinOptions e)
{
  if (flatbuffers::IsOutRange(e, BuiltinOptions_NONE, BuiltinOptions_InstanceNormOptions))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBuiltinOptions()[index];
}

template <typename T> struct BuiltinOptionsTraits
{
  static const BuiltinOptions enum_value = BuiltinOptions_NONE;
};

template <> struct BuiltinOptionsTraits<circle::Conv2DOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_Conv2DOptions;
};

template <> struct BuiltinOptionsTraits<circle::DepthwiseConv2DOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_DepthwiseConv2DOptions;
};

template <> struct BuiltinOptionsTraits<circle::ConcatEmbeddingsOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_ConcatEmbeddingsOptions;
};

template <> struct BuiltinOptionsTraits<circle::LSHProjectionOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_LSHProjectionOptions;
};

template <> struct BuiltinOptionsTraits<circle::Pool2DOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_Pool2DOptions;
};

template <> struct BuiltinOptionsTraits<circle::SVDFOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_SVDFOptions;
};

template <> struct BuiltinOptionsTraits<circle::RNNOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_RNNOptions;
};

template <> struct BuiltinOptionsTraits<circle::FullyConnectedOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_FullyConnectedOptions;
};

template <> struct BuiltinOptionsTraits<circle::SoftmaxOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_SoftmaxOptions;
};

template <> struct BuiltinOptionsTraits<circle::ConcatenationOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_ConcatenationOptions;
};

template <> struct BuiltinOptionsTraits<circle::AddOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_AddOptions;
};

template <> struct BuiltinOptionsTraits<circle::L2NormOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_L2NormOptions;
};

template <> struct BuiltinOptionsTraits<circle::LocalResponseNormalizationOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_LocalResponseNormalizationOptions;
};

template <> struct BuiltinOptionsTraits<circle::LSTMOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_LSTMOptions;
};

template <> struct BuiltinOptionsTraits<circle::ResizeBilinearOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_ResizeBilinearOptions;
};

template <> struct BuiltinOptionsTraits<circle::CallOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_CallOptions;
};

template <> struct BuiltinOptionsTraits<circle::ReshapeOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_ReshapeOptions;
};

template <> struct BuiltinOptionsTraits<circle::SkipGramOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_SkipGramOptions;
};

template <> struct BuiltinOptionsTraits<circle::SpaceToDepthOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_SpaceToDepthOptions;
};

template <> struct BuiltinOptionsTraits<circle::EmbeddingLookupSparseOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_EmbeddingLookupSparseOptions;
};

template <> struct BuiltinOptionsTraits<circle::MulOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_MulOptions;
};

template <> struct BuiltinOptionsTraits<circle::PadOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_PadOptions;
};

template <> struct BuiltinOptionsTraits<circle::GatherOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_GatherOptions;
};

template <> struct BuiltinOptionsTraits<circle::BatchToSpaceNDOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_BatchToSpaceNDOptions;
};

template <> struct BuiltinOptionsTraits<circle::SpaceToBatchNDOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_SpaceToBatchNDOptions;
};

template <> struct BuiltinOptionsTraits<circle::TransposeOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_TransposeOptions;
};

template <> struct BuiltinOptionsTraits<circle::ReducerOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_ReducerOptions;
};

template <> struct BuiltinOptionsTraits<circle::SubOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_SubOptions;
};

template <> struct BuiltinOptionsTraits<circle::DivOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_DivOptions;
};

template <> struct BuiltinOptionsTraits<circle::SqueezeOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_SqueezeOptions;
};

template <> struct BuiltinOptionsTraits<circle::SequenceRNNOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_SequenceRNNOptions;
};

template <> struct BuiltinOptionsTraits<circle::StridedSliceOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_StridedSliceOptions;
};

template <> struct BuiltinOptionsTraits<circle::ExpOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_ExpOptions;
};

template <> struct BuiltinOptionsTraits<circle::TopKV2Options>
{
  static const BuiltinOptions enum_value = BuiltinOptions_TopKV2Options;
};

template <> struct BuiltinOptionsTraits<circle::SplitOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_SplitOptions;
};

template <> struct BuiltinOptionsTraits<circle::LogSoftmaxOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_LogSoftmaxOptions;
};

template <> struct BuiltinOptionsTraits<circle::CastOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_CastOptions;
};

template <> struct BuiltinOptionsTraits<circle::DequantizeOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_DequantizeOptions;
};

template <> struct BuiltinOptionsTraits<circle::MaximumMinimumOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_MaximumMinimumOptions;
};

template <> struct BuiltinOptionsTraits<circle::ArgMaxOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_ArgMaxOptions;
};

template <> struct BuiltinOptionsTraits<circle::LessOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_LessOptions;
};

template <> struct BuiltinOptionsTraits<circle::NegOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_NegOptions;
};

template <> struct BuiltinOptionsTraits<circle::PadV2Options>
{
  static const BuiltinOptions enum_value = BuiltinOptions_PadV2Options;
};

template <> struct BuiltinOptionsTraits<circle::GreaterOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_GreaterOptions;
};

template <> struct BuiltinOptionsTraits<circle::GreaterEqualOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_GreaterEqualOptions;
};

template <> struct BuiltinOptionsTraits<circle::LessEqualOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_LessEqualOptions;
};

template <> struct BuiltinOptionsTraits<circle::SelectOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_SelectOptions;
};

template <> struct BuiltinOptionsTraits<circle::SliceOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_SliceOptions;
};

template <> struct BuiltinOptionsTraits<circle::TransposeConvOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_TransposeConvOptions;
};

template <> struct BuiltinOptionsTraits<circle::SparseToDenseOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_SparseToDenseOptions;
};

template <> struct BuiltinOptionsTraits<circle::TileOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_TileOptions;
};

template <> struct BuiltinOptionsTraits<circle::ExpandDimsOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_ExpandDimsOptions;
};

template <> struct BuiltinOptionsTraits<circle::EqualOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_EqualOptions;
};

template <> struct BuiltinOptionsTraits<circle::NotEqualOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_NotEqualOptions;
};

template <> struct BuiltinOptionsTraits<circle::ShapeOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_ShapeOptions;
};

template <> struct BuiltinOptionsTraits<circle::PowOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_PowOptions;
};

template <> struct BuiltinOptionsTraits<circle::ArgMinOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_ArgMinOptions;
};

template <> struct BuiltinOptionsTraits<circle::FakeQuantOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_FakeQuantOptions;
};

template <> struct BuiltinOptionsTraits<circle::PackOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_PackOptions;
};

template <> struct BuiltinOptionsTraits<circle::LogicalOrOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_LogicalOrOptions;
};

template <> struct BuiltinOptionsTraits<circle::OneHotOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_OneHotOptions;
};

template <> struct BuiltinOptionsTraits<circle::LogicalAndOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_LogicalAndOptions;
};

template <> struct BuiltinOptionsTraits<circle::LogicalNotOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_LogicalNotOptions;
};

template <> struct BuiltinOptionsTraits<circle::UnpackOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_UnpackOptions;
};

template <> struct BuiltinOptionsTraits<circle::FloorDivOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_FloorDivOptions;
};

template <> struct BuiltinOptionsTraits<circle::SquareOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_SquareOptions;
};

template <> struct BuiltinOptionsTraits<circle::ZerosLikeOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_ZerosLikeOptions;
};

template <> struct BuiltinOptionsTraits<circle::FillOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_FillOptions;
};

template <> struct BuiltinOptionsTraits<circle::BidirectionalSequenceLSTMOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_BidirectionalSequenceLSTMOptions;
};

template <> struct BuiltinOptionsTraits<circle::BidirectionalSequenceRNNOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_BidirectionalSequenceRNNOptions;
};

template <> struct BuiltinOptionsTraits<circle::UnidirectionalSequenceLSTMOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_UnidirectionalSequenceLSTMOptions;
};

template <> struct BuiltinOptionsTraits<circle::FloorModOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_FloorModOptions;
};

template <> struct BuiltinOptionsTraits<circle::RangeOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_RangeOptions;
};

template <> struct BuiltinOptionsTraits<circle::ResizeNearestNeighborOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_ResizeNearestNeighborOptions;
};

template <> struct BuiltinOptionsTraits<circle::LeakyReluOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_LeakyReluOptions;
};

template <> struct BuiltinOptionsTraits<circle::SquaredDifferenceOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_SquaredDifferenceOptions;
};

template <> struct BuiltinOptionsTraits<circle::MirrorPadOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_MirrorPadOptions;
};

template <> struct BuiltinOptionsTraits<circle::AbsOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_AbsOptions;
};

template <> struct BuiltinOptionsTraits<circle::SplitVOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_SplitVOptions;
};

template <> struct BuiltinOptionsTraits<circle::UniqueOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_UniqueOptions;
};

template <> struct BuiltinOptionsTraits<circle::ReverseV2Options>
{
  static const BuiltinOptions enum_value = BuiltinOptions_ReverseV2Options;
};

template <> struct BuiltinOptionsTraits<circle::AddNOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_AddNOptions;
};

template <> struct BuiltinOptionsTraits<circle::GatherNdOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_GatherNdOptions;
};

template <> struct BuiltinOptionsTraits<circle::CosOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_CosOptions;
};

template <> struct BuiltinOptionsTraits<circle::WhereOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_WhereOptions;
};

template <> struct BuiltinOptionsTraits<circle::RankOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_RankOptions;
};

template <> struct BuiltinOptionsTraits<circle::ReverseSequenceOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_ReverseSequenceOptions;
};

template <> struct BuiltinOptionsTraits<circle::MatrixDiagOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_MatrixDiagOptions;
};

template <> struct BuiltinOptionsTraits<circle::QuantizeOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_QuantizeOptions;
};

template <> struct BuiltinOptionsTraits<circle::MatrixSetDiagOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_MatrixSetDiagOptions;
};

template <> struct BuiltinOptionsTraits<circle::HardSwishOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_HardSwishOptions;
};

template <> struct BuiltinOptionsTraits<circle::IfOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_IfOptions;
};

template <> struct BuiltinOptionsTraits<circle::WhileOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_WhileOptions;
};

template <> struct BuiltinOptionsTraits<circle::DepthToSpaceOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_DepthToSpaceOptions;
};

template <> struct BuiltinOptionsTraits<circle::NonMaxSuppressionV4Options>
{
  static const BuiltinOptions enum_value = BuiltinOptions_NonMaxSuppressionV4Options;
};

template <> struct BuiltinOptionsTraits<circle::NonMaxSuppressionV5Options>
{
  static const BuiltinOptions enum_value = BuiltinOptions_NonMaxSuppressionV5Options;
};

template <> struct BuiltinOptionsTraits<circle::ScatterNdOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_ScatterNdOptions;
};

template <> struct BuiltinOptionsTraits<circle::SelectV2Options>
{
  static const BuiltinOptions enum_value = BuiltinOptions_SelectV2Options;
};

template <> struct BuiltinOptionsTraits<circle::DensifyOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_DensifyOptions;
};

template <> struct BuiltinOptionsTraits<circle::SegmentSumOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_SegmentSumOptions;
};

template <> struct BuiltinOptionsTraits<circle::BatchMatMulOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_BatchMatMulOptions;
};

template <> struct BuiltinOptionsTraits<circle::CumsumOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_CumsumOptions;
};

template <> struct BuiltinOptionsTraits<circle::CallOnceOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_CallOnceOptions;
};

template <> struct BuiltinOptionsTraits<circle::BroadcastToOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_BroadcastToOptions;
};

template <> struct BuiltinOptionsTraits<circle::Rfft2dOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_Rfft2dOptions;
};

template <> struct BuiltinOptionsTraits<circle::Conv3DOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_Conv3DOptions;
};

template <> struct BuiltinOptionsTraits<circle::HashtableOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_HashtableOptions;
};

template <> struct BuiltinOptionsTraits<circle::HashtableFindOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_HashtableFindOptions;
};

template <> struct BuiltinOptionsTraits<circle::HashtableImportOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_HashtableImportOptions;
};

template <> struct BuiltinOptionsTraits<circle::HashtableSizeOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_HashtableSizeOptions;
};

template <> struct BuiltinOptionsTraits<circle::VarHandleOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_VarHandleOptions;
};

template <> struct BuiltinOptionsTraits<circle::ReadVariableOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_ReadVariableOptions;
};

template <> struct BuiltinOptionsTraits<circle::AssignVariableOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_AssignVariableOptions;
};

template <> struct BuiltinOptionsTraits<circle::RandomOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_RandomOptions;
};

template <> struct BuiltinOptionsTraits<circle::BCQGatherOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_BCQGatherOptions;
};

template <> struct BuiltinOptionsTraits<circle::BCQFullyConnectedOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_BCQFullyConnectedOptions;
};

template <> struct BuiltinOptionsTraits<circle::InstanceNormOptions>
{
  static const BuiltinOptions enum_value = BuiltinOptions_InstanceNormOptions;
};

struct BuiltinOptionsUnion
{
  BuiltinOptions type;
  void *value;

  BuiltinOptionsUnion() : type(BuiltinOptions_NONE), value(nullptr) {}
  BuiltinOptionsUnion(BuiltinOptionsUnion &&u) FLATBUFFERS_NOEXCEPT : type(BuiltinOptions_NONE),
                                                                      value(nullptr)
  {
    std::swap(type, u.type);
    std::swap(value, u.value);
  }
  BuiltinOptionsUnion(const BuiltinOptionsUnion &);
  BuiltinOptionsUnion &operator=(const BuiltinOptionsUnion &u)
  {
    BuiltinOptionsUnion t(u);
    std::swap(type, t.type);
    std::swap(value, t.value);
    return *this;
  }
  BuiltinOptionsUnion &operator=(BuiltinOptionsUnion &&u) FLATBUFFERS_NOEXCEPT
  {
    std::swap(type, u.type);
    std::swap(value, u.value);
    return *this;
  }
  ~BuiltinOptionsUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T> void Set(T &&val)
  {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = BuiltinOptionsTraits<typename RT::TableType>::enum_value;
    if (type != BuiltinOptions_NONE)
    {
      value = new RT(std::forward<T>(val));
    }
  }
#endif // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, BuiltinOptions type,
                      const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  circle::Conv2DOptionsT *AsConv2DOptions()
  {
    return type == BuiltinOptions_Conv2DOptions ? reinterpret_cast<circle::Conv2DOptionsT *>(value)
                                                : nullptr;
  }
  const circle::Conv2DOptionsT *AsConv2DOptions() const
  {
    return type == BuiltinOptions_Conv2DOptions
             ? reinterpret_cast<const circle::Conv2DOptionsT *>(value)
             : nullptr;
  }
  circle::DepthwiseConv2DOptionsT *AsDepthwiseConv2DOptions()
  {
    return type == BuiltinOptions_DepthwiseConv2DOptions
             ? reinterpret_cast<circle::DepthwiseConv2DOptionsT *>(value)
             : nullptr;
  }
  const circle::DepthwiseConv2DOptionsT *AsDepthwiseConv2DOptions() const
  {
    return type == BuiltinOptions_DepthwiseConv2DOptions
             ? reinterpret_cast<const circle::DepthwiseConv2DOptionsT *>(value)
             : nullptr;
  }
  circle::ConcatEmbeddingsOptionsT *AsConcatEmbeddingsOptions()
  {
    return type == BuiltinOptions_ConcatEmbeddingsOptions
             ? reinterpret_cast<circle::ConcatEmbeddingsOptionsT *>(value)
             : nullptr;
  }
  const circle::ConcatEmbeddingsOptionsT *AsConcatEmbeddingsOptions() const
  {
    return type == BuiltinOptions_ConcatEmbeddingsOptions
             ? reinterpret_cast<const circle::ConcatEmbeddingsOptionsT *>(value)
             : nullptr;
  }
  circle::LSHProjectionOptionsT *AsLSHProjectionOptions()
  {
    return type == BuiltinOptions_LSHProjectionOptions
             ? reinterpret_cast<circle::LSHProjectionOptionsT *>(value)
             : nullptr;
  }
  const circle::LSHProjectionOptionsT *AsLSHProjectionOptions() const
  {
    return type == BuiltinOptions_LSHProjectionOptions
             ? reinterpret_cast<const circle::LSHProjectionOptionsT *>(value)
             : nullptr;
  }
  circle::Pool2DOptionsT *AsPool2DOptions()
  {
    return type == BuiltinOptions_Pool2DOptions ? reinterpret_cast<circle::Pool2DOptionsT *>(value)
                                                : nullptr;
  }
  const circle::Pool2DOptionsT *AsPool2DOptions() const
  {
    return type == BuiltinOptions_Pool2DOptions
             ? reinterpret_cast<const circle::Pool2DOptionsT *>(value)
             : nullptr;
  }
  circle::SVDFOptionsT *AsSVDFOptions()
  {
    return type == BuiltinOptions_SVDFOptions ? reinterpret_cast<circle::SVDFOptionsT *>(value)
                                              : nullptr;
  }
  const circle::SVDFOptionsT *AsSVDFOptions() const
  {
    return type == BuiltinOptions_SVDFOptions
             ? reinterpret_cast<const circle::SVDFOptionsT *>(value)
             : nullptr;
  }
  circle::RNNOptionsT *AsRNNOptions()
  {
    return type == BuiltinOptions_RNNOptions ? reinterpret_cast<circle::RNNOptionsT *>(value)
                                             : nullptr;
  }
  const circle::RNNOptionsT *AsRNNOptions() const
  {
    return type == BuiltinOptions_RNNOptions ? reinterpret_cast<const circle::RNNOptionsT *>(value)
                                             : nullptr;
  }
  circle::FullyConnectedOptionsT *AsFullyConnectedOptions()
  {
    return type == BuiltinOptions_FullyConnectedOptions
             ? reinterpret_cast<circle::FullyConnectedOptionsT *>(value)
             : nullptr;
  }
  const circle::FullyConnectedOptionsT *AsFullyConnectedOptions() const
  {
    return type == BuiltinOptions_FullyConnectedOptions
             ? reinterpret_cast<const circle::FullyConnectedOptionsT *>(value)
             : nullptr;
  }
  circle::SoftmaxOptionsT *AsSoftmaxOptions()
  {
    return type == BuiltinOptions_SoftmaxOptions
             ? reinterpret_cast<circle::SoftmaxOptionsT *>(value)
             : nullptr;
  }
  const circle::SoftmaxOptionsT *AsSoftmaxOptions() const
  {
    return type == BuiltinOptions_SoftmaxOptions
             ? reinterpret_cast<const circle::SoftmaxOptionsT *>(value)
             : nullptr;
  }
  circle::ConcatenationOptionsT *AsConcatenationOptions()
  {
    return type == BuiltinOptions_ConcatenationOptions
             ? reinterpret_cast<circle::ConcatenationOptionsT *>(value)
             : nullptr;
  }
  const circle::ConcatenationOptionsT *AsConcatenationOptions() const
  {
    return type == BuiltinOptions_ConcatenationOptions
             ? reinterpret_cast<const circle::ConcatenationOptionsT *>(value)
             : nullptr;
  }
  circle::AddOptionsT *AsAddOptions()
  {
    return type == BuiltinOptions_AddOptions ? reinterpret_cast<circle::AddOptionsT *>(value)
                                             : nullptr;
  }
  const circle::AddOptionsT *AsAddOptions() const
  {
    return type == BuiltinOptions_AddOptions ? reinterpret_cast<const circle::AddOptionsT *>(value)
                                             : nullptr;
  }
  circle::L2NormOptionsT *AsL2NormOptions()
  {
    return type == BuiltinOptions_L2NormOptions ? reinterpret_cast<circle::L2NormOptionsT *>(value)
                                                : nullptr;
  }
  const circle::L2NormOptionsT *AsL2NormOptions() const
  {
    return type == BuiltinOptions_L2NormOptions
             ? reinterpret_cast<const circle::L2NormOptionsT *>(value)
             : nullptr;
  }
  circle::LocalResponseNormalizationOptionsT *AsLocalResponseNormalizationOptions()
  {
    return type == BuiltinOptions_LocalResponseNormalizationOptions
             ? reinterpret_cast<circle::LocalResponseNormalizationOptionsT *>(value)
             : nullptr;
  }
  const circle::LocalResponseNormalizationOptionsT *AsLocalResponseNormalizationOptions() const
  {
    return type == BuiltinOptions_LocalResponseNormalizationOptions
             ? reinterpret_cast<const circle::LocalResponseNormalizationOptionsT *>(value)
             : nullptr;
  }
  circle::LSTMOptionsT *AsLSTMOptions()
  {
    return type == BuiltinOptions_LSTMOptions ? reinterpret_cast<circle::LSTMOptionsT *>(value)
                                              : nullptr;
  }
  const circle::LSTMOptionsT *AsLSTMOptions() const
  {
    return type == BuiltinOptions_LSTMOptions
             ? reinterpret_cast<const circle::LSTMOptionsT *>(value)
             : nullptr;
  }
  circle::ResizeBilinearOptionsT *AsResizeBilinearOptions()
  {
    return type == BuiltinOptions_ResizeBilinearOptions
             ? reinterpret_cast<circle::ResizeBilinearOptionsT *>(value)
             : nullptr;
  }
  const circle::ResizeBilinearOptionsT *AsResizeBilinearOptions() const
  {
    return type == BuiltinOptions_ResizeBilinearOptions
             ? reinterpret_cast<const circle::ResizeBilinearOptionsT *>(value)
             : nullptr;
  }
  circle::CallOptionsT *AsCallOptions()
  {
    return type == BuiltinOptions_CallOptions ? reinterpret_cast<circle::CallOptionsT *>(value)
                                              : nullptr;
  }
  const circle::CallOptionsT *AsCallOptions() const
  {
    return type == BuiltinOptions_CallOptions
             ? reinterpret_cast<const circle::CallOptionsT *>(value)
             : nullptr;
  }
  circle::ReshapeOptionsT *AsReshapeOptions()
  {
    return type == BuiltinOptions_ReshapeOptions
             ? reinterpret_cast<circle::ReshapeOptionsT *>(value)
             : nullptr;
  }
  const circle::ReshapeOptionsT *AsReshapeOptions() const
  {
    return type == BuiltinOptions_ReshapeOptions
             ? reinterpret_cast<const circle::ReshapeOptionsT *>(value)
             : nullptr;
  }
  circle::SkipGramOptionsT *AsSkipGramOptions()
  {
    return type == BuiltinOptions_SkipGramOptions
             ? reinterpret_cast<circle::SkipGramOptionsT *>(value)
             : nullptr;
  }
  const circle::SkipGramOptionsT *AsSkipGramOptions() const
  {
    return type == BuiltinOptions_SkipGramOptions
             ? reinterpret_cast<const circle::SkipGramOptionsT *>(value)
             : nullptr;
  }
  circle::SpaceToDepthOptionsT *AsSpaceToDepthOptions()
  {
    return type == BuiltinOptions_SpaceToDepthOptions
             ? reinterpret_cast<circle::SpaceToDepthOptionsT *>(value)
             : nullptr;
  }
  const circle::SpaceToDepthOptionsT *AsSpaceToDepthOptions() const
  {
    return type == BuiltinOptions_SpaceToDepthOptions
             ? reinterpret_cast<const circle::SpaceToDepthOptionsT *>(value)
             : nullptr;
  }
  circle::EmbeddingLookupSparseOptionsT *AsEmbeddingLookupSparseOptions()
  {
    return type == BuiltinOptions_EmbeddingLookupSparseOptions
             ? reinterpret_cast<circle::EmbeddingLookupSparseOptionsT *>(value)
             : nullptr;
  }
  const circle::EmbeddingLookupSparseOptionsT *AsEmbeddingLookupSparseOptions() const
  {
    return type == BuiltinOptions_EmbeddingLookupSparseOptions
             ? reinterpret_cast<const circle::EmbeddingLookupSparseOptionsT *>(value)
             : nullptr;
  }
  circle::MulOptionsT *AsMulOptions()
  {
    return type == BuiltinOptions_MulOptions ? reinterpret_cast<circle::MulOptionsT *>(value)
                                             : nullptr;
  }
  const circle::MulOptionsT *AsMulOptions() const
  {
    return type == BuiltinOptions_MulOptions ? reinterpret_cast<const circle::MulOptionsT *>(value)
                                             : nullptr;
  }
  circle::PadOptionsT *AsPadOptions()
  {
    return type == BuiltinOptions_PadOptions ? reinterpret_cast<circle::PadOptionsT *>(value)
                                             : nullptr;
  }
  const circle::PadOptionsT *AsPadOptions() const
  {
    return type == BuiltinOptions_PadOptions ? reinterpret_cast<const circle::PadOptionsT *>(value)
                                             : nullptr;
  }
  circle::GatherOptionsT *AsGatherOptions()
  {
    return type == BuiltinOptions_GatherOptions ? reinterpret_cast<circle::GatherOptionsT *>(value)
                                                : nullptr;
  }
  const circle::GatherOptionsT *AsGatherOptions() const
  {
    return type == BuiltinOptions_GatherOptions
             ? reinterpret_cast<const circle::GatherOptionsT *>(value)
             : nullptr;
  }
  circle::BatchToSpaceNDOptionsT *AsBatchToSpaceNDOptions()
  {
    return type == BuiltinOptions_BatchToSpaceNDOptions
             ? reinterpret_cast<circle::BatchToSpaceNDOptionsT *>(value)
             : nullptr;
  }
  const circle::BatchToSpaceNDOptionsT *AsBatchToSpaceNDOptions() const
  {
    return type == BuiltinOptions_BatchToSpaceNDOptions
             ? reinterpret_cast<const circle::BatchToSpaceNDOptionsT *>(value)
             : nullptr;
  }
  circle::SpaceToBatchNDOptionsT *AsSpaceToBatchNDOptions()
  {
    return type == BuiltinOptions_SpaceToBatchNDOptions
             ? reinterpret_cast<circle::SpaceToBatchNDOptionsT *>(value)
             : nullptr;
  }
  const circle::SpaceToBatchNDOptionsT *AsSpaceToBatchNDOptions() const
  {
    return type == BuiltinOptions_SpaceToBatchNDOptions
             ? reinterpret_cast<const circle::SpaceToBatchNDOptionsT *>(value)
             : nullptr;
  }
  circle::TransposeOptionsT *AsTransposeOptions()
  {
    return type == BuiltinOptions_TransposeOptions
             ? reinterpret_cast<circle::TransposeOptionsT *>(value)
             : nullptr;
  }
  const circle::TransposeOptionsT *AsTransposeOptions() const
  {
    return type == BuiltinOptions_TransposeOptions
             ? reinterpret_cast<const circle::TransposeOptionsT *>(value)
             : nullptr;
  }
  circle::ReducerOptionsT *AsReducerOptions()
  {
    return type == BuiltinOptions_ReducerOptions
             ? reinterpret_cast<circle::ReducerOptionsT *>(value)
             : nullptr;
  }
  const circle::ReducerOptionsT *AsReducerOptions() const
  {
    return type == BuiltinOptions_ReducerOptions
             ? reinterpret_cast<const circle::ReducerOptionsT *>(value)
             : nullptr;
  }
  circle::SubOptionsT *AsSubOptions()
  {
    return type == BuiltinOptions_SubOptions ? reinterpret_cast<circle::SubOptionsT *>(value)
                                             : nullptr;
  }
  const circle::SubOptionsT *AsSubOptions() const
  {
    return type == BuiltinOptions_SubOptions ? reinterpret_cast<const circle::SubOptionsT *>(value)
                                             : nullptr;
  }
  circle::DivOptionsT *AsDivOptions()
  {
    return type == BuiltinOptions_DivOptions ? reinterpret_cast<circle::DivOptionsT *>(value)
                                             : nullptr;
  }
  const circle::DivOptionsT *AsDivOptions() const
  {
    return type == BuiltinOptions_DivOptions ? reinterpret_cast<const circle::DivOptionsT *>(value)
                                             : nullptr;
  }
  circle::SqueezeOptionsT *AsSqueezeOptions()
  {
    return type == BuiltinOptions_SqueezeOptions
             ? reinterpret_cast<circle::SqueezeOptionsT *>(value)
             : nullptr;
  }
  const circle::SqueezeOptionsT *AsSqueezeOptions() const
  {
    return type == BuiltinOptions_SqueezeOptions
             ? reinterpret_cast<const circle::SqueezeOptionsT *>(value)
             : nullptr;
  }
  circle::SequenceRNNOptionsT *AsSequenceRNNOptions()
  {
    return type == BuiltinOptions_SequenceRNNOptions
             ? reinterpret_cast<circle::SequenceRNNOptionsT *>(value)
             : nullptr;
  }
  const circle::SequenceRNNOptionsT *AsSequenceRNNOptions() const
  {
    return type == BuiltinOptions_SequenceRNNOptions
             ? reinterpret_cast<const circle::SequenceRNNOptionsT *>(value)
             : nullptr;
  }
  circle::StridedSliceOptionsT *AsStridedSliceOptions()
  {
    return type == BuiltinOptions_StridedSliceOptions
             ? reinterpret_cast<circle::StridedSliceOptionsT *>(value)
             : nullptr;
  }
  const circle::StridedSliceOptionsT *AsStridedSliceOptions() const
  {
    return type == BuiltinOptions_StridedSliceOptions
             ? reinterpret_cast<const circle::StridedSliceOptionsT *>(value)
             : nullptr;
  }
  circle::ExpOptionsT *AsExpOptions()
  {
    return type == BuiltinOptions_ExpOptions ? reinterpret_cast<circle::ExpOptionsT *>(value)
                                             : nullptr;
  }
  const circle::ExpOptionsT *AsExpOptions() const
  {
    return type == BuiltinOptions_ExpOptions ? reinterpret_cast<const circle::ExpOptionsT *>(value)
                                             : nullptr;
  }
  circle::TopKV2OptionsT *AsTopKV2Options()
  {
    return type == BuiltinOptions_TopKV2Options ? reinterpret_cast<circle::TopKV2OptionsT *>(value)
                                                : nullptr;
  }
  const circle::TopKV2OptionsT *AsTopKV2Options() const
  {
    return type == BuiltinOptions_TopKV2Options
             ? reinterpret_cast<const circle::TopKV2OptionsT *>(value)
             : nullptr;
  }
  circle::SplitOptionsT *AsSplitOptions()
  {
    return type == BuiltinOptions_SplitOptions ? reinterpret_cast<circle::SplitOptionsT *>(value)
                                               : nullptr;
  }
  const circle::SplitOptionsT *AsSplitOptions() const
  {
    return type == BuiltinOptions_SplitOptions
             ? reinterpret_cast<const circle::SplitOptionsT *>(value)
             : nullptr;
  }
  circle::LogSoftmaxOptionsT *AsLogSoftmaxOptions()
  {
    return type == BuiltinOptions_LogSoftmaxOptions
             ? reinterpret_cast<circle::LogSoftmaxOptionsT *>(value)
             : nullptr;
  }
  const circle::LogSoftmaxOptionsT *AsLogSoftmaxOptions() const
  {
    return type == BuiltinOptions_LogSoftmaxOptions
             ? reinterpret_cast<const circle::LogSoftmaxOptionsT *>(value)
             : nullptr;
  }
  circle::CastOptionsT *AsCastOptions()
  {
    return type == BuiltinOptions_CastOptions ? reinterpret_cast<circle::CastOptionsT *>(value)
                                              : nullptr;
  }
  const circle::CastOptionsT *AsCastOptions() const
  {
    return type == BuiltinOptions_CastOptions
             ? reinterpret_cast<const circle::CastOptionsT *>(value)
             : nullptr;
  }
  circle::DequantizeOptionsT *AsDequantizeOptions()
  {
    return type == BuiltinOptions_DequantizeOptions
             ? reinterpret_cast<circle::DequantizeOptionsT *>(value)
             : nullptr;
  }
  const circle::DequantizeOptionsT *AsDequantizeOptions() const
  {
    return type == BuiltinOptions_DequantizeOptions
             ? reinterpret_cast<const circle::DequantizeOptionsT *>(value)
             : nullptr;
  }
  circle::MaximumMinimumOptionsT *AsMaximumMinimumOptions()
  {
    return type == BuiltinOptions_MaximumMinimumOptions
             ? reinterpret_cast<circle::MaximumMinimumOptionsT *>(value)
             : nullptr;
  }
  const circle::MaximumMinimumOptionsT *AsMaximumMinimumOptions() const
  {
    return type == BuiltinOptions_MaximumMinimumOptions
             ? reinterpret_cast<const circle::MaximumMinimumOptionsT *>(value)
             : nullptr;
  }
  circle::ArgMaxOptionsT *AsArgMaxOptions()
  {
    return type == BuiltinOptions_ArgMaxOptions ? reinterpret_cast<circle::ArgMaxOptionsT *>(value)
                                                : nullptr;
  }
  const circle::ArgMaxOptionsT *AsArgMaxOptions() const
  {
    return type == BuiltinOptions_ArgMaxOptions
             ? reinterpret_cast<const circle::ArgMaxOptionsT *>(value)
             : nullptr;
  }
  circle::LessOptionsT *AsLessOptions()
  {
    return type == BuiltinOptions_LessOptions ? reinterpret_cast<circle::LessOptionsT *>(value)
                                              : nullptr;
  }
  const circle::LessOptionsT *AsLessOptions() const
  {
    return type == BuiltinOptions_LessOptions
             ? reinterpret_cast<const circle::LessOptionsT *>(value)
             : nullptr;
  }
  circle::NegOptionsT *AsNegOptions()
  {
    return type == BuiltinOptions_NegOptions ? reinterpret_cast<circle::NegOptionsT *>(value)
                                             : nullptr;
  }
  const circle::NegOptionsT *AsNegOptions() const
  {
    return type == BuiltinOptions_NegOptions ? reinterpret_cast<const circle::NegOptionsT *>(value)
                                             : nullptr;
  }
  circle::PadV2OptionsT *AsPadV2Options()
  {
    return type == BuiltinOptions_PadV2Options ? reinterpret_cast<circle::PadV2OptionsT *>(value)
                                               : nullptr;
  }
  const circle::PadV2OptionsT *AsPadV2Options() const
  {
    return type == BuiltinOptions_PadV2Options
             ? reinterpret_cast<const circle::PadV2OptionsT *>(value)
             : nullptr;
  }
  circle::GreaterOptionsT *AsGreaterOptions()
  {
    return type == BuiltinOptions_GreaterOptions
             ? reinterpret_cast<circle::GreaterOptionsT *>(value)
             : nullptr;
  }
  const circle::GreaterOptionsT *AsGreaterOptions() const
  {
    return type == BuiltinOptions_GreaterOptions
             ? reinterpret_cast<const circle::GreaterOptionsT *>(value)
             : nullptr;
  }
  circle::GreaterEqualOptionsT *AsGreaterEqualOptions()
  {
    return type == BuiltinOptions_GreaterEqualOptions
             ? reinterpret_cast<circle::GreaterEqualOptionsT *>(value)
             : nullptr;
  }
  const circle::GreaterEqualOptionsT *AsGreaterEqualOptions() const
  {
    return type == BuiltinOptions_GreaterEqualOptions
             ? reinterpret_cast<const circle::GreaterEqualOptionsT *>(value)
             : nullptr;
  }
  circle::LessEqualOptionsT *AsLessEqualOptions()
  {
    return type == BuiltinOptions_LessEqualOptions
             ? reinterpret_cast<circle::LessEqualOptionsT *>(value)
             : nullptr;
  }
  const circle::LessEqualOptionsT *AsLessEqualOptions() const
  {
    return type == BuiltinOptions_LessEqualOptions
             ? reinterpret_cast<const circle::LessEqualOptionsT *>(value)
             : nullptr;
  }
  circle::SelectOptionsT *AsSelectOptions()
  {
    return type == BuiltinOptions_SelectOptions ? reinterpret_cast<circle::SelectOptionsT *>(value)
                                                : nullptr;
  }
  const circle::SelectOptionsT *AsSelectOptions() const
  {
    return type == BuiltinOptions_SelectOptions
             ? reinterpret_cast<const circle::SelectOptionsT *>(value)
             : nullptr;
  }
  circle::SliceOptionsT *AsSliceOptions()
  {
    return type == BuiltinOptions_SliceOptions ? reinterpret_cast<circle::SliceOptionsT *>(value)
                                               : nullptr;
  }
  const circle::SliceOptionsT *AsSliceOptions() const
  {
    return type == BuiltinOptions_SliceOptions
             ? reinterpret_cast<const circle::SliceOptionsT *>(value)
             : nullptr;
  }
  circle::TransposeConvOptionsT *AsTransposeConvOptions()
  {
    return type == BuiltinOptions_TransposeConvOptions
             ? reinterpret_cast<circle::TransposeConvOptionsT *>(value)
             : nullptr;
  }
  const circle::TransposeConvOptionsT *AsTransposeConvOptions() const
  {
    return type == BuiltinOptions_TransposeConvOptions
             ? reinterpret_cast<const circle::TransposeConvOptionsT *>(value)
             : nullptr;
  }
  circle::SparseToDenseOptionsT *AsSparseToDenseOptions()
  {
    return type == BuiltinOptions_SparseToDenseOptions
             ? reinterpret_cast<circle::SparseToDenseOptionsT *>(value)
             : nullptr;
  }
  const circle::SparseToDenseOptionsT *AsSparseToDenseOptions() const
  {
    return type == BuiltinOptions_SparseToDenseOptions
             ? reinterpret_cast<const circle::SparseToDenseOptionsT *>(value)
             : nullptr;
  }
  circle::TileOptionsT *AsTileOptions()
  {
    return type == BuiltinOptions_TileOptions ? reinterpret_cast<circle::TileOptionsT *>(value)
                                              : nullptr;
  }
  const circle::TileOptionsT *AsTileOptions() const
  {
    return type == BuiltinOptions_TileOptions
             ? reinterpret_cast<const circle::TileOptionsT *>(value)
             : nullptr;
  }
  circle::ExpandDimsOptionsT *AsExpandDimsOptions()
  {
    return type == BuiltinOptions_ExpandDimsOptions
             ? reinterpret_cast<circle::ExpandDimsOptionsT *>(value)
             : nullptr;
  }
  const circle::ExpandDimsOptionsT *AsExpandDimsOptions() const
  {
    return type == BuiltinOptions_ExpandDimsOptions
             ? reinterpret_cast<const circle::ExpandDimsOptionsT *>(value)
             : nullptr;
  }
  circle::EqualOptionsT *AsEqualOptions()
  {
    return type == BuiltinOptions_EqualOptions ? reinterpret_cast<circle::EqualOptionsT *>(value)
                                               : nullptr;
  }
  const circle::EqualOptionsT *AsEqualOptions() const
  {
    return type == BuiltinOptions_EqualOptions
             ? reinterpret_cast<const circle::EqualOptionsT *>(value)
             : nullptr;
  }
  circle::NotEqualOptionsT *AsNotEqualOptions()
  {
    return type == BuiltinOptions_NotEqualOptions
             ? reinterpret_cast<circle::NotEqualOptionsT *>(value)
             : nullptr;
  }
  const circle::NotEqualOptionsT *AsNotEqualOptions() const
  {
    return type == BuiltinOptions_NotEqualOptions
             ? reinterpret_cast<const circle::NotEqualOptionsT *>(value)
             : nullptr;
  }
  circle::ShapeOptionsT *AsShapeOptions()
  {
    return type == BuiltinOptions_ShapeOptions ? reinterpret_cast<circle::ShapeOptionsT *>(value)
                                               : nullptr;
  }
  const circle::ShapeOptionsT *AsShapeOptions() const
  {
    return type == BuiltinOptions_ShapeOptions
             ? reinterpret_cast<const circle::ShapeOptionsT *>(value)
             : nullptr;
  }
  circle::PowOptionsT *AsPowOptions()
  {
    return type == BuiltinOptions_PowOptions ? reinterpret_cast<circle::PowOptionsT *>(value)
                                             : nullptr;
  }
  const circle::PowOptionsT *AsPowOptions() const
  {
    return type == BuiltinOptions_PowOptions ? reinterpret_cast<const circle::PowOptionsT *>(value)
                                             : nullptr;
  }
  circle::ArgMinOptionsT *AsArgMinOptions()
  {
    return type == BuiltinOptions_ArgMinOptions ? reinterpret_cast<circle::ArgMinOptionsT *>(value)
                                                : nullptr;
  }
  const circle::ArgMinOptionsT *AsArgMinOptions() const
  {
    return type == BuiltinOptions_ArgMinOptions
             ? reinterpret_cast<const circle::ArgMinOptionsT *>(value)
             : nullptr;
  }
  circle::FakeQuantOptionsT *AsFakeQuantOptions()
  {
    return type == BuiltinOptions_FakeQuantOptions
             ? reinterpret_cast<circle::FakeQuantOptionsT *>(value)
             : nullptr;
  }
  const circle::FakeQuantOptionsT *AsFakeQuantOptions() const
  {
    return type == BuiltinOptions_FakeQuantOptions
             ? reinterpret_cast<const circle::FakeQuantOptionsT *>(value)
             : nullptr;
  }
  circle::PackOptionsT *AsPackOptions()
  {
    return type == BuiltinOptions_PackOptions ? reinterpret_cast<circle::PackOptionsT *>(value)
                                              : nullptr;
  }
  const circle::PackOptionsT *AsPackOptions() const
  {
    return type == BuiltinOptions_PackOptions
             ? reinterpret_cast<const circle::PackOptionsT *>(value)
             : nullptr;
  }
  circle::LogicalOrOptionsT *AsLogicalOrOptions()
  {
    return type == BuiltinOptions_LogicalOrOptions
             ? reinterpret_cast<circle::LogicalOrOptionsT *>(value)
             : nullptr;
  }
  const circle::LogicalOrOptionsT *AsLogicalOrOptions() const
  {
    return type == BuiltinOptions_LogicalOrOptions
             ? reinterpret_cast<const circle::LogicalOrOptionsT *>(value)
             : nullptr;
  }
  circle::OneHotOptionsT *AsOneHotOptions()
  {
    return type == BuiltinOptions_OneHotOptions ? reinterpret_cast<circle::OneHotOptionsT *>(value)
                                                : nullptr;
  }
  const circle::OneHotOptionsT *AsOneHotOptions() const
  {
    return type == BuiltinOptions_OneHotOptions
             ? reinterpret_cast<const circle::OneHotOptionsT *>(value)
             : nullptr;
  }
  circle::LogicalAndOptionsT *AsLogicalAndOptions()
  {
    return type == BuiltinOptions_LogicalAndOptions
             ? reinterpret_cast<circle::LogicalAndOptionsT *>(value)
             : nullptr;
  }
  const circle::LogicalAndOptionsT *AsLogicalAndOptions() const
  {
    return type == BuiltinOptions_LogicalAndOptions
             ? reinterpret_cast<const circle::LogicalAndOptionsT *>(value)
             : nullptr;
  }
  circle::LogicalNotOptionsT *AsLogicalNotOptions()
  {
    return type == BuiltinOptions_LogicalNotOptions
             ? reinterpret_cast<circle::LogicalNotOptionsT *>(value)
             : nullptr;
  }
  const circle::LogicalNotOptionsT *AsLogicalNotOptions() const
  {
    return type == BuiltinOptions_LogicalNotOptions
             ? reinterpret_cast<const circle::LogicalNotOptionsT *>(value)
             : nullptr;
  }
  circle::UnpackOptionsT *AsUnpackOptions()
  {
    return type == BuiltinOptions_UnpackOptions ? reinterpret_cast<circle::UnpackOptionsT *>(value)
                                                : nullptr;
  }
  const circle::UnpackOptionsT *AsUnpackOptions() const
  {
    return type == BuiltinOptions_UnpackOptions
             ? reinterpret_cast<const circle::UnpackOptionsT *>(value)
             : nullptr;
  }
  circle::FloorDivOptionsT *AsFloorDivOptions()
  {
    return type == BuiltinOptions_FloorDivOptions
             ? reinterpret_cast<circle::FloorDivOptionsT *>(value)
             : nullptr;
  }
  const circle::FloorDivOptionsT *AsFloorDivOptions() const
  {
    return type == BuiltinOptions_FloorDivOptions
             ? reinterpret_cast<const circle::FloorDivOptionsT *>(value)
             : nullptr;
  }
  circle::SquareOptionsT *AsSquareOptions()
  {
    return type == BuiltinOptions_SquareOptions ? reinterpret_cast<circle::SquareOptionsT *>(value)
                                                : nullptr;
  }
  const circle::SquareOptionsT *AsSquareOptions() const
  {
    return type == BuiltinOptions_SquareOptions
             ? reinterpret_cast<const circle::SquareOptionsT *>(value)
             : nullptr;
  }
  circle::ZerosLikeOptionsT *AsZerosLikeOptions()
  {
    return type == BuiltinOptions_ZerosLikeOptions
             ? reinterpret_cast<circle::ZerosLikeOptionsT *>(value)
             : nullptr;
  }
  const circle::ZerosLikeOptionsT *AsZerosLikeOptions() const
  {
    return type == BuiltinOptions_ZerosLikeOptions
             ? reinterpret_cast<const circle::ZerosLikeOptionsT *>(value)
             : nullptr;
  }
  circle::FillOptionsT *AsFillOptions()
  {
    return type == BuiltinOptions_FillOptions ? reinterpret_cast<circle::FillOptionsT *>(value)
                                              : nullptr;
  }
  const circle::FillOptionsT *AsFillOptions() const
  {
    return type == BuiltinOptions_FillOptions
             ? reinterpret_cast<const circle::FillOptionsT *>(value)
             : nullptr;
  }
  circle::BidirectionalSequenceLSTMOptionsT *AsBidirectionalSequenceLSTMOptions()
  {
    return type == BuiltinOptions_BidirectionalSequenceLSTMOptions
             ? reinterpret_cast<circle::BidirectionalSequenceLSTMOptionsT *>(value)
             : nullptr;
  }
  const circle::BidirectionalSequenceLSTMOptionsT *AsBidirectionalSequenceLSTMOptions() const
  {
    return type == BuiltinOptions_BidirectionalSequenceLSTMOptions
             ? reinterpret_cast<const circle::BidirectionalSequenceLSTMOptionsT *>(value)
             : nullptr;
  }
  circle::BidirectionalSequenceRNNOptionsT *AsBidirectionalSequenceRNNOptions()
  {
    return type == BuiltinOptions_BidirectionalSequenceRNNOptions
             ? reinterpret_cast<circle::BidirectionalSequenceRNNOptionsT *>(value)
             : nullptr;
  }
  const circle::BidirectionalSequenceRNNOptionsT *AsBidirectionalSequenceRNNOptions() const
  {
    return type == BuiltinOptions_BidirectionalSequenceRNNOptions
             ? reinterpret_cast<const circle::BidirectionalSequenceRNNOptionsT *>(value)
             : nullptr;
  }
  circle::UnidirectionalSequenceLSTMOptionsT *AsUnidirectionalSequenceLSTMOptions()
  {
    return type == BuiltinOptions_UnidirectionalSequenceLSTMOptions
             ? reinterpret_cast<circle::UnidirectionalSequenceLSTMOptionsT *>(value)
             : nullptr;
  }
  const circle::UnidirectionalSequenceLSTMOptionsT *AsUnidirectionalSequenceLSTMOptions() const
  {
    return type == BuiltinOptions_UnidirectionalSequenceLSTMOptions
             ? reinterpret_cast<const circle::UnidirectionalSequenceLSTMOptionsT *>(value)
             : nullptr;
  }
  circle::FloorModOptionsT *AsFloorModOptions()
  {
    return type == BuiltinOptions_FloorModOptions
             ? reinterpret_cast<circle::FloorModOptionsT *>(value)
             : nullptr;
  }
  const circle::FloorModOptionsT *AsFloorModOptions() const
  {
    return type == BuiltinOptions_FloorModOptions
             ? reinterpret_cast<const circle::FloorModOptionsT *>(value)
             : nullptr;
  }
  circle::RangeOptionsT *AsRangeOptions()
  {
    return type == BuiltinOptions_RangeOptions ? reinterpret_cast<circle::RangeOptionsT *>(value)
                                               : nullptr;
  }
  const circle::RangeOptionsT *AsRangeOptions() const
  {
    return type == BuiltinOptions_RangeOptions
             ? reinterpret_cast<const circle::RangeOptionsT *>(value)
             : nullptr;
  }
  circle::ResizeNearestNeighborOptionsT *AsResizeNearestNeighborOptions()
  {
    return type == BuiltinOptions_ResizeNearestNeighborOptions
             ? reinterpret_cast<circle::ResizeNearestNeighborOptionsT *>(value)
             : nullptr;
  }
  const circle::ResizeNearestNeighborOptionsT *AsResizeNearestNeighborOptions() const
  {
    return type == BuiltinOptions_ResizeNearestNeighborOptions
             ? reinterpret_cast<const circle::ResizeNearestNeighborOptionsT *>(value)
             : nullptr;
  }
  circle::LeakyReluOptionsT *AsLeakyReluOptions()
  {
    return type == BuiltinOptions_LeakyReluOptions
             ? reinterpret_cast<circle::LeakyReluOptionsT *>(value)
             : nullptr;
  }
  const circle::LeakyReluOptionsT *AsLeakyReluOptions() const
  {
    return type == BuiltinOptions_LeakyReluOptions
             ? reinterpret_cast<const circle::LeakyReluOptionsT *>(value)
             : nullptr;
  }
  circle::SquaredDifferenceOptionsT *AsSquaredDifferenceOptions()
  {
    return type == BuiltinOptions_SquaredDifferenceOptions
             ? reinterpret_cast<circle::SquaredDifferenceOptionsT *>(value)
             : nullptr;
  }
  const circle::SquaredDifferenceOptionsT *AsSquaredDifferenceOptions() const
  {
    return type == BuiltinOptions_SquaredDifferenceOptions
             ? reinterpret_cast<const circle::SquaredDifferenceOptionsT *>(value)
             : nullptr;
  }
  circle::MirrorPadOptionsT *AsMirrorPadOptions()
  {
    return type == BuiltinOptions_MirrorPadOptions
             ? reinterpret_cast<circle::MirrorPadOptionsT *>(value)
             : nullptr;
  }
  const circle::MirrorPadOptionsT *AsMirrorPadOptions() const
  {
    return type == BuiltinOptions_MirrorPadOptions
             ? reinterpret_cast<const circle::MirrorPadOptionsT *>(value)
             : nullptr;
  }
  circle::AbsOptionsT *AsAbsOptions()
  {
    return type == BuiltinOptions_AbsOptions ? reinterpret_cast<circle::AbsOptionsT *>(value)
                                             : nullptr;
  }
  const circle::AbsOptionsT *AsAbsOptions() const
  {
    return type == BuiltinOptions_AbsOptions ? reinterpret_cast<const circle::AbsOptionsT *>(value)
                                             : nullptr;
  }
  circle::SplitVOptionsT *AsSplitVOptions()
  {
    return type == BuiltinOptions_SplitVOptions ? reinterpret_cast<circle::SplitVOptionsT *>(value)
                                                : nullptr;
  }
  const circle::SplitVOptionsT *AsSplitVOptions() const
  {
    return type == BuiltinOptions_SplitVOptions
             ? reinterpret_cast<const circle::SplitVOptionsT *>(value)
             : nullptr;
  }
  circle::UniqueOptionsT *AsUniqueOptions()
  {
    return type == BuiltinOptions_UniqueOptions ? reinterpret_cast<circle::UniqueOptionsT *>(value)
                                                : nullptr;
  }
  const circle::UniqueOptionsT *AsUniqueOptions() const
  {
    return type == BuiltinOptions_UniqueOptions
             ? reinterpret_cast<const circle::UniqueOptionsT *>(value)
             : nullptr;
  }
  circle::ReverseV2OptionsT *AsReverseV2Options()
  {
    return type == BuiltinOptions_ReverseV2Options
             ? reinterpret_cast<circle::ReverseV2OptionsT *>(value)
             : nullptr;
  }
  const circle::ReverseV2OptionsT *AsReverseV2Options() const
  {
    return type == BuiltinOptions_ReverseV2Options
             ? reinterpret_cast<const circle::ReverseV2OptionsT *>(value)
             : nullptr;
  }
  circle::AddNOptionsT *AsAddNOptions()
  {
    return type == BuiltinOptions_AddNOptions ? reinterpret_cast<circle::AddNOptionsT *>(value)
                                              : nullptr;
  }
  const circle::AddNOptionsT *AsAddNOptions() const
  {
    return type == BuiltinOptions_AddNOptions
             ? reinterpret_cast<const circle::AddNOptionsT *>(value)
             : nullptr;
  }
  circle::GatherNdOptionsT *AsGatherNdOptions()
  {
    return type == BuiltinOptions_GatherNdOptions
             ? reinterpret_cast<circle::GatherNdOptionsT *>(value)
             : nullptr;
  }
  const circle::GatherNdOptionsT *AsGatherNdOptions() const
  {
    return type == BuiltinOptions_GatherNdOptions
             ? reinterpret_cast<const circle::GatherNdOptionsT *>(value)
             : nullptr;
  }
  circle::CosOptionsT *AsCosOptions()
  {
    return type == BuiltinOptions_CosOptions ? reinterpret_cast<circle::CosOptionsT *>(value)
                                             : nullptr;
  }
  const circle::CosOptionsT *AsCosOptions() const
  {
    return type == BuiltinOptions_CosOptions ? reinterpret_cast<const circle::CosOptionsT *>(value)
                                             : nullptr;
  }
  circle::WhereOptionsT *AsWhereOptions()
  {
    return type == BuiltinOptions_WhereOptions ? reinterpret_cast<circle::WhereOptionsT *>(value)
                                               : nullptr;
  }
  const circle::WhereOptionsT *AsWhereOptions() const
  {
    return type == BuiltinOptions_WhereOptions
             ? reinterpret_cast<const circle::WhereOptionsT *>(value)
             : nullptr;
  }
  circle::RankOptionsT *AsRankOptions()
  {
    return type == BuiltinOptions_RankOptions ? reinterpret_cast<circle::RankOptionsT *>(value)
                                              : nullptr;
  }
  const circle::RankOptionsT *AsRankOptions() const
  {
    return type == BuiltinOptions_RankOptions
             ? reinterpret_cast<const circle::RankOptionsT *>(value)
             : nullptr;
  }
  circle::ReverseSequenceOptionsT *AsReverseSequenceOptions()
  {
    return type == BuiltinOptions_ReverseSequenceOptions
             ? reinterpret_cast<circle::ReverseSequenceOptionsT *>(value)
             : nullptr;
  }
  const circle::ReverseSequenceOptionsT *AsReverseSequenceOptions() const
  {
    return type == BuiltinOptions_ReverseSequenceOptions
             ? reinterpret_cast<const circle::ReverseSequenceOptionsT *>(value)
             : nullptr;
  }
  circle::MatrixDiagOptionsT *AsMatrixDiagOptions()
  {
    return type == BuiltinOptions_MatrixDiagOptions
             ? reinterpret_cast<circle::MatrixDiagOptionsT *>(value)
             : nullptr;
  }
  const circle::MatrixDiagOptionsT *AsMatrixDiagOptions() const
  {
    return type == BuiltinOptions_MatrixDiagOptions
             ? reinterpret_cast<const circle::MatrixDiagOptionsT *>(value)
             : nullptr;
  }
  circle::QuantizeOptionsT *AsQuantizeOptions()
  {
    return type == BuiltinOptions_QuantizeOptions
             ? reinterpret_cast<circle::QuantizeOptionsT *>(value)
             : nullptr;
  }
  const circle::QuantizeOptionsT *AsQuantizeOptions() const
  {
    return type == BuiltinOptions_QuantizeOptions
             ? reinterpret_cast<const circle::QuantizeOptionsT *>(value)
             : nullptr;
  }
  circle::MatrixSetDiagOptionsT *AsMatrixSetDiagOptions()
  {
    return type == BuiltinOptions_MatrixSetDiagOptions
             ? reinterpret_cast<circle::MatrixSetDiagOptionsT *>(value)
             : nullptr;
  }
  const circle::MatrixSetDiagOptionsT *AsMatrixSetDiagOptions() const
  {
    return type == BuiltinOptions_MatrixSetDiagOptions
             ? reinterpret_cast<const circle::MatrixSetDiagOptionsT *>(value)
             : nullptr;
  }
  circle::HardSwishOptionsT *AsHardSwishOptions()
  {
    return type == BuiltinOptions_HardSwishOptions
             ? reinterpret_cast<circle::HardSwishOptionsT *>(value)
             : nullptr;
  }
  const circle::HardSwishOptionsT *AsHardSwishOptions() const
  {
    return type == BuiltinOptions_HardSwishOptions
             ? reinterpret_cast<const circle::HardSwishOptionsT *>(value)
             : nullptr;
  }
  circle::IfOptionsT *AsIfOptions()
  {
    return type == BuiltinOptions_IfOptions ? reinterpret_cast<circle::IfOptionsT *>(value)
                                            : nullptr;
  }
  const circle::IfOptionsT *AsIfOptions() const
  {
    return type == BuiltinOptions_IfOptions ? reinterpret_cast<const circle::IfOptionsT *>(value)
                                            : nullptr;
  }
  circle::WhileOptionsT *AsWhileOptions()
  {
    return type == BuiltinOptions_WhileOptions ? reinterpret_cast<circle::WhileOptionsT *>(value)
                                               : nullptr;
  }
  const circle::WhileOptionsT *AsWhileOptions() const
  {
    return type == BuiltinOptions_WhileOptions
             ? reinterpret_cast<const circle::WhileOptionsT *>(value)
             : nullptr;
  }
  circle::DepthToSpaceOptionsT *AsDepthToSpaceOptions()
  {
    return type == BuiltinOptions_DepthToSpaceOptions
             ? reinterpret_cast<circle::DepthToSpaceOptionsT *>(value)
             : nullptr;
  }
  const circle::DepthToSpaceOptionsT *AsDepthToSpaceOptions() const
  {
    return type == BuiltinOptions_DepthToSpaceOptions
             ? reinterpret_cast<const circle::DepthToSpaceOptionsT *>(value)
             : nullptr;
  }
  circle::NonMaxSuppressionV4OptionsT *AsNonMaxSuppressionV4Options()
  {
    return type == BuiltinOptions_NonMaxSuppressionV4Options
             ? reinterpret_cast<circle::NonMaxSuppressionV4OptionsT *>(value)
             : nullptr;
  }
  const circle::NonMaxSuppressionV4OptionsT *AsNonMaxSuppressionV4Options() const
  {
    return type == BuiltinOptions_NonMaxSuppressionV4Options
             ? reinterpret_cast<const circle::NonMaxSuppressionV4OptionsT *>(value)
             : nullptr;
  }
  circle::NonMaxSuppressionV5OptionsT *AsNonMaxSuppressionV5Options()
  {
    return type == BuiltinOptions_NonMaxSuppressionV5Options
             ? reinterpret_cast<circle::NonMaxSuppressionV5OptionsT *>(value)
             : nullptr;
  }
  const circle::NonMaxSuppressionV5OptionsT *AsNonMaxSuppressionV5Options() const
  {
    return type == BuiltinOptions_NonMaxSuppressionV5Options
             ? reinterpret_cast<const circle::NonMaxSuppressionV5OptionsT *>(value)
             : nullptr;
  }
  circle::ScatterNdOptionsT *AsScatterNdOptions()
  {
    return type == BuiltinOptions_ScatterNdOptions
             ? reinterpret_cast<circle::ScatterNdOptionsT *>(value)
             : nullptr;
  }
  const circle::ScatterNdOptionsT *AsScatterNdOptions() const
  {
    return type == BuiltinOptions_ScatterNdOptions
             ? reinterpret_cast<const circle::ScatterNdOptionsT *>(value)
             : nullptr;
  }
  circle::SelectV2OptionsT *AsSelectV2Options()
  {
    return type == BuiltinOptions_SelectV2Options
             ? reinterpret_cast<circle::SelectV2OptionsT *>(value)
             : nullptr;
  }
  const circle::SelectV2OptionsT *AsSelectV2Options() const
  {
    return type == BuiltinOptions_SelectV2Options
             ? reinterpret_cast<const circle::SelectV2OptionsT *>(value)
             : nullptr;
  }
  circle::DensifyOptionsT *AsDensifyOptions()
  {
    return type == BuiltinOptions_DensifyOptions
             ? reinterpret_cast<circle::DensifyOptionsT *>(value)
             : nullptr;
  }
  const circle::DensifyOptionsT *AsDensifyOptions() const
  {
    return type == BuiltinOptions_DensifyOptions
             ? reinterpret_cast<const circle::DensifyOptionsT *>(value)
             : nullptr;
  }
  circle::SegmentSumOptionsT *AsSegmentSumOptions()
  {
    return type == BuiltinOptions_SegmentSumOptions
             ? reinterpret_cast<circle::SegmentSumOptionsT *>(value)
             : nullptr;
  }
  const circle::SegmentSumOptionsT *AsSegmentSumOptions() const
  {
    return type == BuiltinOptions_SegmentSumOptions
             ? reinterpret_cast<const circle::SegmentSumOptionsT *>(value)
             : nullptr;
  }
  circle::BatchMatMulOptionsT *AsBatchMatMulOptions()
  {
    return type == BuiltinOptions_BatchMatMulOptions
             ? reinterpret_cast<circle::BatchMatMulOptionsT *>(value)
             : nullptr;
  }
  const circle::BatchMatMulOptionsT *AsBatchMatMulOptions() const
  {
    return type == BuiltinOptions_BatchMatMulOptions
             ? reinterpret_cast<const circle::BatchMatMulOptionsT *>(value)
             : nullptr;
  }
  circle::CumsumOptionsT *AsCumsumOptions()
  {
    return type == BuiltinOptions_CumsumOptions ? reinterpret_cast<circle::CumsumOptionsT *>(value)
                                                : nullptr;
  }
  const circle::CumsumOptionsT *AsCumsumOptions() const
  {
    return type == BuiltinOptions_CumsumOptions
             ? reinterpret_cast<const circle::CumsumOptionsT *>(value)
             : nullptr;
  }
  circle::CallOnceOptionsT *AsCallOnceOptions()
  {
    return type == BuiltinOptions_CallOnceOptions
             ? reinterpret_cast<circle::CallOnceOptionsT *>(value)
             : nullptr;
  }
  const circle::CallOnceOptionsT *AsCallOnceOptions() const
  {
    return type == BuiltinOptions_CallOnceOptions
             ? reinterpret_cast<const circle::CallOnceOptionsT *>(value)
             : nullptr;
  }
  circle::BroadcastToOptionsT *AsBroadcastToOptions()
  {
    return type == BuiltinOptions_BroadcastToOptions
             ? reinterpret_cast<circle::BroadcastToOptionsT *>(value)
             : nullptr;
  }
  const circle::BroadcastToOptionsT *AsBroadcastToOptions() const
  {
    return type == BuiltinOptions_BroadcastToOptions
             ? reinterpret_cast<const circle::BroadcastToOptionsT *>(value)
             : nullptr;
  }
  circle::Rfft2dOptionsT *AsRfft2dOptions()
  {
    return type == BuiltinOptions_Rfft2dOptions ? reinterpret_cast<circle::Rfft2dOptionsT *>(value)
                                                : nullptr;
  }
  const circle::Rfft2dOptionsT *AsRfft2dOptions() const
  {
    return type == BuiltinOptions_Rfft2dOptions
             ? reinterpret_cast<const circle::Rfft2dOptionsT *>(value)
             : nullptr;
  }
  circle::Conv3DOptionsT *AsConv3DOptions()
  {
    return type == BuiltinOptions_Conv3DOptions ? reinterpret_cast<circle::Conv3DOptionsT *>(value)
                                                : nullptr;
  }
  const circle::Conv3DOptionsT *AsConv3DOptions() const
  {
    return type == BuiltinOptions_Conv3DOptions
             ? reinterpret_cast<const circle::Conv3DOptionsT *>(value)
             : nullptr;
  }
  circle::HashtableOptionsT *AsHashtableOptions()
  {
    return type == BuiltinOptions_HashtableOptions
             ? reinterpret_cast<circle::HashtableOptionsT *>(value)
             : nullptr;
  }
  const circle::HashtableOptionsT *AsHashtableOptions() const
  {
    return type == BuiltinOptions_HashtableOptions
             ? reinterpret_cast<const circle::HashtableOptionsT *>(value)
             : nullptr;
  }
  circle::HashtableFindOptionsT *AsHashtableFindOptions()
  {
    return type == BuiltinOptions_HashtableFindOptions
             ? reinterpret_cast<circle::HashtableFindOptionsT *>(value)
             : nullptr;
  }
  const circle::HashtableFindOptionsT *AsHashtableFindOptions() const
  {
    return type == BuiltinOptions_HashtableFindOptions
             ? reinterpret_cast<const circle::HashtableFindOptionsT *>(value)
             : nullptr;
  }
  circle::HashtableImportOptionsT *AsHashtableImportOptions()
  {
    return type == BuiltinOptions_HashtableImportOptions
             ? reinterpret_cast<circle::HashtableImportOptionsT *>(value)
             : nullptr;
  }
  const circle::HashtableImportOptionsT *AsHashtableImportOptions() const
  {
    return type == BuiltinOptions_HashtableImportOptions
             ? reinterpret_cast<const circle::HashtableImportOptionsT *>(value)
             : nullptr;
  }
  circle::HashtableSizeOptionsT *AsHashtableSizeOptions()
  {
    return type == BuiltinOptions_HashtableSizeOptions
             ? reinterpret_cast<circle::HashtableSizeOptionsT *>(value)
             : nullptr;
  }
  const circle::HashtableSizeOptionsT *AsHashtableSizeOptions() const
  {
    return type == BuiltinOptions_HashtableSizeOptions
             ? reinterpret_cast<const circle::HashtableSizeOptionsT *>(value)
             : nullptr;
  }
  circle::VarHandleOptionsT *AsVarHandleOptions()
  {
    return type == BuiltinOptions_VarHandleOptions
             ? reinterpret_cast<circle::VarHandleOptionsT *>(value)
             : nullptr;
  }
  const circle::VarHandleOptionsT *AsVarHandleOptions() const
  {
    return type == BuiltinOptions_VarHandleOptions
             ? reinterpret_cast<const circle::VarHandleOptionsT *>(value)
             : nullptr;
  }
  circle::ReadVariableOptionsT *AsReadVariableOptions()
  {
    return type == BuiltinOptions_ReadVariableOptions
             ? reinterpret_cast<circle::ReadVariableOptionsT *>(value)
             : nullptr;
  }
  const circle::ReadVariableOptionsT *AsReadVariableOptions() const
  {
    return type == BuiltinOptions_ReadVariableOptions
             ? reinterpret_cast<const circle::ReadVariableOptionsT *>(value)
             : nullptr;
  }
  circle::AssignVariableOptionsT *AsAssignVariableOptions()
  {
    return type == BuiltinOptions_AssignVariableOptions
             ? reinterpret_cast<circle::AssignVariableOptionsT *>(value)
             : nullptr;
  }
  const circle::AssignVariableOptionsT *AsAssignVariableOptions() const
  {
    return type == BuiltinOptions_AssignVariableOptions
             ? reinterpret_cast<const circle::AssignVariableOptionsT *>(value)
             : nullptr;
  }
  circle::RandomOptionsT *AsRandomOptions()
  {
    return type == BuiltinOptions_RandomOptions ? reinterpret_cast<circle::RandomOptionsT *>(value)
                                                : nullptr;
  }
  const circle::RandomOptionsT *AsRandomOptions() const
  {
    return type == BuiltinOptions_RandomOptions
             ? reinterpret_cast<const circle::RandomOptionsT *>(value)
             : nullptr;
  }
  circle::BCQGatherOptionsT *AsBCQGatherOptions()
  {
    return type == BuiltinOptions_BCQGatherOptions
             ? reinterpret_cast<circle::BCQGatherOptionsT *>(value)
             : nullptr;
  }
  const circle::BCQGatherOptionsT *AsBCQGatherOptions() const
  {
    return type == BuiltinOptions_BCQGatherOptions
             ? reinterpret_cast<const circle::BCQGatherOptionsT *>(value)
             : nullptr;
  }
  circle::BCQFullyConnectedOptionsT *AsBCQFullyConnectedOptions()
  {
    return type == BuiltinOptions_BCQFullyConnectedOptions
             ? reinterpret_cast<circle::BCQFullyConnectedOptionsT *>(value)
             : nullptr;
  }
  const circle::BCQFullyConnectedOptionsT *AsBCQFullyConnectedOptions() const
  {
    return type == BuiltinOptions_BCQFullyConnectedOptions
             ? reinterpret_cast<const circle::BCQFullyConnectedOptionsT *>(value)
             : nullptr;
  }
  circle::InstanceNormOptionsT *AsInstanceNormOptions()
  {
    return type == BuiltinOptions_InstanceNormOptions
             ? reinterpret_cast<circle::InstanceNormOptionsT *>(value)
             : nullptr;
  }
  const circle::InstanceNormOptionsT *AsInstanceNormOptions() const
  {
    return type == BuiltinOptions_InstanceNormOptions
             ? reinterpret_cast<const circle::InstanceNormOptionsT *>(value)
             : nullptr;
  }
};

bool VerifyBuiltinOptions(flatbuffers::Verifier &verifier, const void *obj, BuiltinOptions type);
bool VerifyBuiltinOptionsVector(flatbuffers::Verifier &verifier,
                                const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
                                const flatbuffers::Vector<uint8_t> *types);

enum Padding : int8_t
{
  Padding_SAME = 0,
  Padding_VALID = 1,
  Padding_MIN = Padding_SAME,
  Padding_MAX = Padding_VALID
};

inline const Padding (&EnumValuesPadding())[2]
{
  static const Padding values[] = {Padding_SAME, Padding_VALID};
  return values;
}

inline const char *const *EnumNamesPadding()
{
  static const char *const names[3] = {"SAME", "VALID", nullptr};
  return names;
}

inline const char *EnumNamePadding(Padding e)
{
  if (flatbuffers::IsOutRange(e, Padding_SAME, Padding_VALID))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPadding()[index];
}

enum ActivationFunctionType : int8_t
{
  ActivationFunctionType_NONE = 0,
  ActivationFunctionType_RELU = 1,
  ActivationFunctionType_RELU_N1_TO_1 = 2,
  ActivationFunctionType_RELU6 = 3,
  ActivationFunctionType_TANH = 4,
  ActivationFunctionType_SIGN_BIT = 5,
  ActivationFunctionType_MIN = ActivationFunctionType_NONE,
  ActivationFunctionType_MAX = ActivationFunctionType_SIGN_BIT
};

inline const ActivationFunctionType (&EnumValuesActivationFunctionType())[6]
{
  static const ActivationFunctionType values[] = {
    ActivationFunctionType_NONE,  ActivationFunctionType_RELU, ActivationFunctionType_RELU_N1_TO_1,
    ActivationFunctionType_RELU6, ActivationFunctionType_TANH, ActivationFunctionType_SIGN_BIT};
  return values;
}

inline const char *const *EnumNamesActivationFunctionType()
{
  static const char *const names[7] = {"NONE", "RELU",     "RELU_N1_TO_1", "RELU6",
                                       "TANH", "SIGN_BIT", nullptr};
  return names;
}

inline const char *EnumNameActivationFunctionType(ActivationFunctionType e)
{
  if (flatbuffers::IsOutRange(e, ActivationFunctionType_NONE, ActivationFunctionType_SIGN_BIT))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesActivationFunctionType()[index];
}

enum LSHProjectionType : int8_t
{
  LSHProjectionType_UNKNOWN = 0,
  LSHProjectionType_SPARSE = 1,
  LSHProjectionType_DENSE = 2,
  LSHProjectionType_MIN = LSHProjectionType_UNKNOWN,
  LSHProjectionType_MAX = LSHProjectionType_DENSE
};

inline const LSHProjectionType (&EnumValuesLSHProjectionType())[3]
{
  static const LSHProjectionType values[] = {LSHProjectionType_UNKNOWN, LSHProjectionType_SPARSE,
                                             LSHProjectionType_DENSE};
  return values;
}

inline const char *const *EnumNamesLSHProjectionType()
{
  static const char *const names[4] = {"UNKNOWN", "SPARSE", "DENSE", nullptr};
  return names;
}

inline const char *EnumNameLSHProjectionType(LSHProjectionType e)
{
  if (flatbuffers::IsOutRange(e, LSHProjectionType_UNKNOWN, LSHProjectionType_DENSE))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLSHProjectionType()[index];
}

enum FullyConnectedOptionsWeightsFormat : int8_t
{
  FullyConnectedOptionsWeightsFormat_DEFAULT = 0,
  FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8 = 1,
  FullyConnectedOptionsWeightsFormat_SHUFFLED16x1FLOAT32 = 127,
  FullyConnectedOptionsWeightsFormat_MIN = FullyConnectedOptionsWeightsFormat_DEFAULT,
  FullyConnectedOptionsWeightsFormat_MAX = FullyConnectedOptionsWeightsFormat_SHUFFLED16x1FLOAT32
};

inline const FullyConnectedOptionsWeightsFormat (&EnumValuesFullyConnectedOptionsWeightsFormat())[3]
{
  static const FullyConnectedOptionsWeightsFormat values[] = {
    FullyConnectedOptionsWeightsFormat_DEFAULT, FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8,
    FullyConnectedOptionsWeightsFormat_SHUFFLED16x1FLOAT32};
  return values;
}

inline const char *EnumNameFullyConnectedOptionsWeightsFormat(FullyConnectedOptionsWeightsFormat e)
{
  switch (e)
  {
    case FullyConnectedOptionsWeightsFormat_DEFAULT:
      return "DEFAULT";
    case FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8:
      return "SHUFFLED4x16INT8";
    case FullyConnectedOptionsWeightsFormat_SHUFFLED16x1FLOAT32:
      return "SHUFFLED16x1FLOAT32";
    default:
      return "";
  }
}

enum LSTMKernelType : int8_t
{
  LSTMKernelType_FULL = 0,
  LSTMKernelType_BASIC = 1,
  LSTMKernelType_MIN = LSTMKernelType_FULL,
  LSTMKernelType_MAX = LSTMKernelType_BASIC
};

inline const LSTMKernelType (&EnumValuesLSTMKernelType())[2]
{
  static const LSTMKernelType values[] = {LSTMKernelType_FULL, LSTMKernelType_BASIC};
  return values;
}

inline const char *const *EnumNamesLSTMKernelType()
{
  static const char *const names[3] = {"FULL", "BASIC", nullptr};
  return names;
}

inline const char *EnumNameLSTMKernelType(LSTMKernelType e)
{
  if (flatbuffers::IsOutRange(e, LSTMKernelType_FULL, LSTMKernelType_BASIC))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLSTMKernelType()[index];
}

enum CombinerType : int8_t
{
  CombinerType_SUM = 0,
  CombinerType_MEAN = 1,
  CombinerType_SQRTN = 2,
  CombinerType_MIN = CombinerType_SUM,
  CombinerType_MAX = CombinerType_SQRTN
};

inline const CombinerType (&EnumValuesCombinerType())[3]
{
  static const CombinerType values[] = {CombinerType_SUM, CombinerType_MEAN, CombinerType_SQRTN};
  return values;
}

inline const char *const *EnumNamesCombinerType()
{
  static const char *const names[4] = {"SUM", "MEAN", "SQRTN", nullptr};
  return names;
}

inline const char *EnumNameCombinerType(CombinerType e)
{
  if (flatbuffers::IsOutRange(e, CombinerType_SUM, CombinerType_SQRTN))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCombinerType()[index];
}

enum MirrorPadMode : int8_t
{
  MirrorPadMode_REFLECT = 0,
  MirrorPadMode_SYMMETRIC = 1,
  MirrorPadMode_MIN = MirrorPadMode_REFLECT,
  MirrorPadMode_MAX = MirrorPadMode_SYMMETRIC
};

inline const MirrorPadMode (&EnumValuesMirrorPadMode())[2]
{
  static const MirrorPadMode values[] = {MirrorPadMode_REFLECT, MirrorPadMode_SYMMETRIC};
  return values;
}

inline const char *const *EnumNamesMirrorPadMode()
{
  static const char *const names[3] = {"REFLECT", "SYMMETRIC", nullptr};
  return names;
}

inline const char *EnumNameMirrorPadMode(MirrorPadMode e)
{
  if (flatbuffers::IsOutRange(e, MirrorPadMode_REFLECT, MirrorPadMode_SYMMETRIC))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMirrorPadMode()[index];
}

enum CustomOptionsFormat : int8_t
{
  CustomOptionsFormat_FLEXBUFFERS = 0,
  CustomOptionsFormat_MIN = CustomOptionsFormat_FLEXBUFFERS,
  CustomOptionsFormat_MAX = CustomOptionsFormat_FLEXBUFFERS
};

inline const CustomOptionsFormat (&EnumValuesCustomOptionsFormat())[1]
{
  static const CustomOptionsFormat values[] = {CustomOptionsFormat_FLEXBUFFERS};
  return values;
}

inline const char *const *EnumNamesCustomOptionsFormat()
{
  static const char *const names[2] = {"FLEXBUFFERS", nullptr};
  return names;
}

inline const char *EnumNameCustomOptionsFormat(CustomOptionsFormat e)
{
  if (flatbuffers::IsOutRange(e, CustomOptionsFormat_FLEXBUFFERS, CustomOptionsFormat_FLEXBUFFERS))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCustomOptionsFormat()[index];
}

enum DataFormat : int8_t
{
  DataFormat_CHANNELS_LAST = 0,
  DataFormat_CHANNELS_FIRST = 1,
  DataFormat_MIN = DataFormat_CHANNELS_LAST,
  DataFormat_MAX = DataFormat_CHANNELS_FIRST
};

inline const DataFormat (&EnumValuesDataFormat())[2]
{
  static const DataFormat values[] = {DataFormat_CHANNELS_LAST, DataFormat_CHANNELS_FIRST};
  return values;
}

inline const char *const *EnumNamesDataFormat()
{
  static const char *const names[3] = {"CHANNELS_LAST", "CHANNELS_FIRST", nullptr};
  return names;
}

inline const char *EnumNameDataFormat(DataFormat e)
{
  if (flatbuffers::IsOutRange(e, DataFormat_CHANNELS_LAST, DataFormat_CHANNELS_FIRST))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataFormat()[index];
}

struct CustomQuantizationT : public flatbuffers::NativeTable
{
  typedef CustomQuantization TableType;
  std::vector<uint8_t> custom{};
};

struct CustomQuantization FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef CustomQuantizationT NativeTableType;
  typedef CustomQuantizationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_CUSTOM = 4
  };
  const flatbuffers::Vector<uint8_t> *custom() const
  {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CUSTOM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_CUSTOM) &&
           verifier.VerifyVector(custom()) && verifier.EndTable();
  }
  CustomQuantizationT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CustomQuantizationT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CustomQuantization>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const CustomQuantizationT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CustomQuantizationBuilder
{
  typedef CustomQuantization Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_custom(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom)
  {
    fbb_.AddOffset(CustomQuantization::VT_CUSTOM, custom);
  }
  explicit CustomQuantizationBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CustomQuantization> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CustomQuantization>(end);
    return o;
  }
};

inline flatbuffers::Offset<CustomQuantization>
CreateCustomQuantization(flatbuffers::FlatBufferBuilder &_fbb,
                         flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom = 0)
{
  CustomQuantizationBuilder builder_(_fbb);
  builder_.add_custom(custom);
  return builder_.Finish();
}

inline flatbuffers::Offset<CustomQuantization>
CreateCustomQuantizationDirect(flatbuffers::FlatBufferBuilder &_fbb,
                               const std::vector<uint8_t> *custom = nullptr)
{
  if (custom)
  {
    _fbb.ForceVectorAlignment(custom->size(), sizeof(uint8_t), 16);
  }
  auto custom__ = custom ? _fbb.CreateVector<uint8_t>(*custom) : 0;
  return circle::CreateCustomQuantization(_fbb, custom__);
}

flatbuffers::Offset<CustomQuantization>
CreateCustomQuantization(flatbuffers::FlatBufferBuilder &_fbb, const CustomQuantizationT *_o,
                         const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct QuantizationParametersT : public flatbuffers::NativeTable
{
  typedef QuantizationParameters TableType;
  std::vector<float> min{};
  std::vector<float> max{};
  std::vector<float> scale{};
  std::vector<int64_t> zero_point{};
  circle::QuantizationDetailsUnion details{};
  int32_t quantized_dimension = 0;
};

struct QuantizationParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef QuantizationParametersT NativeTableType;
  typedef QuantizationParametersBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_MIN = 4,
    VT_MAX = 6,
    VT_SCALE = 8,
    VT_ZERO_POINT = 10,
    VT_DETAILS_TYPE = 12,
    VT_DETAILS = 14,
    VT_QUANTIZED_DIMENSION = 16
  };
  const flatbuffers::Vector<float> *min() const
  {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_MIN);
  }
  const flatbuffers::Vector<float> *max() const
  {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_MAX);
  }
  const flatbuffers::Vector<float> *scale() const
  {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SCALE);
  }
  const flatbuffers::Vector<int64_t> *zero_point() const
  {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_ZERO_POINT);
  }
  circle::QuantizationDetails details_type() const
  {
    return static_cast<circle::QuantizationDetails>(GetField<uint8_t>(VT_DETAILS_TYPE, 0));
  }
  const void *details() const { return GetPointer<const void *>(VT_DETAILS); }
  template <typename T> const T *details_as() const;
  const circle::CustomQuantization *details_as_CustomQuantization() const
  {
    return details_type() == circle::QuantizationDetails_CustomQuantization
             ? static_cast<const circle::CustomQuantization *>(details())
             : nullptr;
  }
  int32_t quantized_dimension() const { return GetField<int32_t>(VT_QUANTIZED_DIMENSION, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_MIN) &&
           verifier.VerifyVector(min()) && VerifyOffset(verifier, VT_MAX) &&
           verifier.VerifyVector(max()) && VerifyOffset(verifier, VT_SCALE) &&
           verifier.VerifyVector(scale()) && VerifyOffset(verifier, VT_ZERO_POINT) &&
           verifier.VerifyVector(zero_point()) && VerifyField<uint8_t>(verifier, VT_DETAILS_TYPE) &&
           VerifyOffset(verifier, VT_DETAILS) &&
           VerifyQuantizationDetails(verifier, details(), details_type()) &&
           VerifyField<int32_t>(verifier, VT_QUANTIZED_DIMENSION) && verifier.EndTable();
  }
  QuantizationParametersT *
  UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(QuantizationParametersT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<QuantizationParameters>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantizationParametersT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template <>
inline const circle::CustomQuantization *
QuantizationParameters::details_as<circle::CustomQuantization>() const
{
  return details_as_CustomQuantization();
}

struct QuantizationParametersBuilder
{
  typedef QuantizationParameters Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_min(flatbuffers::Offset<flatbuffers::Vector<float>> min)
  {
    fbb_.AddOffset(QuantizationParameters::VT_MIN, min);
  }
  void add_max(flatbuffers::Offset<flatbuffers::Vector<float>> max)
  {
    fbb_.AddOffset(QuantizationParameters::VT_MAX, max);
  }
  void add_scale(flatbuffers::Offset<flatbuffers::Vector<float>> scale)
  {
    fbb_.AddOffset(QuantizationParameters::VT_SCALE, scale);
  }
  void add_zero_point(flatbuffers::Offset<flatbuffers::Vector<int64_t>> zero_point)
  {
    fbb_.AddOffset(QuantizationParameters::VT_ZERO_POINT, zero_point);
  }
  void add_details_type(circle::QuantizationDetails details_type)
  {
    fbb_.AddElement<uint8_t>(QuantizationParameters::VT_DETAILS_TYPE,
                             static_cast<uint8_t>(details_type), 0);
  }
  void add_details(flatbuffers::Offset<void> details)
  {
    fbb_.AddOffset(QuantizationParameters::VT_DETAILS, details);
  }
  void add_quantized_dimension(int32_t quantized_dimension)
  {
    fbb_.AddElement<int32_t>(QuantizationParameters::VT_QUANTIZED_DIMENSION, quantized_dimension,
                             0);
  }
  explicit QuantizationParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<QuantizationParameters> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuantizationParameters>(end);
    return o;
  }
};

inline flatbuffers::Offset<QuantizationParameters> CreateQuantizationParameters(
  flatbuffers::FlatBufferBuilder &_fbb, flatbuffers::Offset<flatbuffers::Vector<float>> min = 0,
  flatbuffers::Offset<flatbuffers::Vector<float>> max = 0,
  flatbuffers::Offset<flatbuffers::Vector<float>> scale = 0,
  flatbuffers::Offset<flatbuffers::Vector<int64_t>> zero_point = 0,
  circle::QuantizationDetails details_type = circle::QuantizationDetails_NONE,
  flatbuffers::Offset<void> details = 0, int32_t quantized_dimension = 0)
{
  QuantizationParametersBuilder builder_(_fbb);
  builder_.add_quantized_dimension(quantized_dimension);
  builder_.add_details(details);
  builder_.add_zero_point(zero_point);
  builder_.add_scale(scale);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_details_type(details_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<QuantizationParameters> CreateQuantizationParametersDirect(
  flatbuffers::FlatBufferBuilder &_fbb, const std::vector<float> *min = nullptr,
  const std::vector<float> *max = nullptr, const std::vector<float> *scale = nullptr,
  const std::vector<int64_t> *zero_point = nullptr,
  circle::QuantizationDetails details_type = circle::QuantizationDetails_NONE,
  flatbuffers::Offset<void> details = 0, int32_t quantized_dimension = 0)
{
  auto min__ = min ? _fbb.CreateVector<float>(*min) : 0;
  auto max__ = max ? _fbb.CreateVector<float>(*max) : 0;
  auto scale__ = scale ? _fbb.CreateVector<float>(*scale) : 0;
  auto zero_point__ = zero_point ? _fbb.CreateVector<int64_t>(*zero_point) : 0;
  return circle::CreateQuantizationParameters(_fbb, min__, max__, scale__, zero_point__,
                                              details_type, details, quantized_dimension);
}

flatbuffers::Offset<QuantizationParameters>
CreateQuantizationParameters(flatbuffers::FlatBufferBuilder &_fbb,
                             const QuantizationParametersT *_o,
                             const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Int32VectorT : public flatbuffers::NativeTable
{
  typedef Int32Vector TableType;
  std::vector<int32_t> values{};
};

struct Int32Vector FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef Int32VectorT NativeTableType;
  typedef Int32VectorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_VALUES = 4
  };
  const flatbuffers::Vector<int32_t> *values() const
  {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_VALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) && verifier.EndTable();
  }
  Int32VectorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Int32VectorT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Int32Vector>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const Int32VectorT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Int32VectorBuilder
{
  typedef Int32Vector Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_values(flatbuffers::Offset<flatbuffers::Vector<int32_t>> values)
  {
    fbb_.AddOffset(Int32Vector::VT_VALUES, values);
  }
  explicit Int32VectorBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Int32Vector> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Int32Vector>(end);
    return o;
  }
};

inline flatbuffers::Offset<Int32Vector>
CreateInt32Vector(flatbuffers::FlatBufferBuilder &_fbb,
                  flatbuffers::Offset<flatbuffers::Vector<int32_t>> values = 0)
{
  Int32VectorBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

inline flatbuffers::Offset<Int32Vector>
CreateInt32VectorDirect(flatbuffers::FlatBufferBuilder &_fbb,
                        const std::vector<int32_t> *values = nullptr)
{
  auto values__ = values ? _fbb.CreateVector<int32_t>(*values) : 0;
  return circle::CreateInt32Vector(_fbb, values__);
}

flatbuffers::Offset<Int32Vector>
CreateInt32Vector(flatbuffers::FlatBufferBuilder &_fbb, const Int32VectorT *_o,
                  const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Uint16VectorT : public flatbuffers::NativeTable
{
  typedef Uint16Vector TableType;
  std::vector<uint16_t> values{};
};

struct Uint16Vector FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef Uint16VectorT NativeTableType;
  typedef Uint16VectorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_VALUES = 4
  };
  const flatbuffers::Vector<uint16_t> *values() const
  {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_VALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) && verifier.EndTable();
  }
  Uint16VectorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Uint16VectorT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Uint16Vector>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const Uint16VectorT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Uint16VectorBuilder
{
  typedef Uint16Vector Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_values(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> values)
  {
    fbb_.AddOffset(Uint16Vector::VT_VALUES, values);
  }
  explicit Uint16VectorBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Uint16Vector> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Uint16Vector>(end);
    return o;
  }
};

inline flatbuffers::Offset<Uint16Vector>
CreateUint16Vector(flatbuffers::FlatBufferBuilder &_fbb,
                   flatbuffers::Offset<flatbuffers::Vector<uint16_t>> values = 0)
{
  Uint16VectorBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

inline flatbuffers::Offset<Uint16Vector>
CreateUint16VectorDirect(flatbuffers::FlatBufferBuilder &_fbb,
                         const std::vector<uint16_t> *values = nullptr)
{
  if (values)
  {
    _fbb.ForceVectorAlignment(values->size(), sizeof(uint16_t), 4);
  }
  auto values__ = values ? _fbb.CreateVector<uint16_t>(*values) : 0;
  return circle::CreateUint16Vector(_fbb, values__);
}

flatbuffers::Offset<Uint16Vector>
CreateUint16Vector(flatbuffers::FlatBufferBuilder &_fbb, const Uint16VectorT *_o,
                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Uint8VectorT : public flatbuffers::NativeTable
{
  typedef Uint8Vector TableType;
  std::vector<uint8_t> values{};
};

struct Uint8Vector FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef Uint8VectorT NativeTableType;
  typedef Uint8VectorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_VALUES = 4
  };
  const flatbuffers::Vector<uint8_t> *values() const
  {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) && verifier.EndTable();
  }
  Uint8VectorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Uint8VectorT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Uint8Vector>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const Uint8VectorT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Uint8VectorBuilder
{
  typedef Uint8Vector Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_values(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> values)
  {
    fbb_.AddOffset(Uint8Vector::VT_VALUES, values);
  }
  explicit Uint8VectorBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Uint8Vector> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Uint8Vector>(end);
    return o;
  }
};

inline flatbuffers::Offset<Uint8Vector>
CreateUint8Vector(flatbuffers::FlatBufferBuilder &_fbb,
                  flatbuffers::Offset<flatbuffers::Vector<uint8_t>> values = 0)
{
  Uint8VectorBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

inline flatbuffers::Offset<Uint8Vector>
CreateUint8VectorDirect(flatbuffers::FlatBufferBuilder &_fbb,
                        const std::vector<uint8_t> *values = nullptr)
{
  if (values)
  {
    _fbb.ForceVectorAlignment(values->size(), sizeof(uint8_t), 4);
  }
  auto values__ = values ? _fbb.CreateVector<uint8_t>(*values) : 0;
  return circle::CreateUint8Vector(_fbb, values__);
}

flatbuffers::Offset<Uint8Vector>
CreateUint8Vector(flatbuffers::FlatBufferBuilder &_fbb, const Uint8VectorT *_o,
                  const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DimensionMetadataT : public flatbuffers::NativeTable
{
  typedef DimensionMetadata TableType;
  circle::DimensionType format = circle::DimensionType_DENSE;
  int32_t dense_size = 0;
  circle::SparseIndexVectorUnion array_segments{};
  circle::SparseIndexVectorUnion array_indices{};
};

struct DimensionMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef DimensionMetadataT NativeTableType;
  typedef DimensionMetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_FORMAT = 4,
    VT_DENSE_SIZE = 6,
    VT_ARRAY_SEGMENTS_TYPE = 8,
    VT_ARRAY_SEGMENTS = 10,
    VT_ARRAY_INDICES_TYPE = 12,
    VT_ARRAY_INDICES = 14
  };
  circle::DimensionType format() const
  {
    return static_cast<circle::DimensionType>(GetField<int8_t>(VT_FORMAT, 0));
  }
  int32_t dense_size() const { return GetField<int32_t>(VT_DENSE_SIZE, 0); }
  circle::SparseIndexVector array_segments_type() const
  {
    return static_cast<circle::SparseIndexVector>(GetField<uint8_t>(VT_ARRAY_SEGMENTS_TYPE, 0));
  }
  const void *array_segments() const { return GetPointer<const void *>(VT_ARRAY_SEGMENTS); }
  template <typename T> const T *array_segments_as() const;
  const circle::Int32Vector *array_segments_as_Int32Vector() const
  {
    return array_segments_type() == circle::SparseIndexVector_Int32Vector
             ? static_cast<const circle::Int32Vector *>(array_segments())
             : nullptr;
  }
  const circle::Uint16Vector *array_segments_as_Uint16Vector() const
  {
    return array_segments_type() == circle::SparseIndexVector_Uint16Vector
             ? static_cast<const circle::Uint16Vector *>(array_segments())
             : nullptr;
  }
  const circle::Uint8Vector *array_segments_as_Uint8Vector() const
  {
    return array_segments_type() == circle::SparseIndexVector_Uint8Vector
             ? static_cast<const circle::Uint8Vector *>(array_segments())
             : nullptr;
  }
  circle::SparseIndexVector array_indices_type() const
  {
    return static_cast<circle::SparseIndexVector>(GetField<uint8_t>(VT_ARRAY_INDICES_TYPE, 0));
  }
  const void *array_indices() const { return GetPointer<const void *>(VT_ARRAY_INDICES); }
  template <typename T> const T *array_indices_as() const;
  const circle::Int32Vector *array_indices_as_Int32Vector() const
  {
    return array_indices_type() == circle::SparseIndexVector_Int32Vector
             ? static_cast<const circle::Int32Vector *>(array_indices())
             : nullptr;
  }
  const circle::Uint16Vector *array_indices_as_Uint16Vector() const
  {
    return array_indices_type() == circle::SparseIndexVector_Uint16Vector
             ? static_cast<const circle::Uint16Vector *>(array_indices())
             : nullptr;
  }
  const circle::Uint8Vector *array_indices_as_Uint8Vector() const
  {
    return array_indices_type() == circle::SparseIndexVector_Uint8Vector
             ? static_cast<const circle::Uint8Vector *>(array_indices())
             : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_FORMAT) &&
           VerifyField<int32_t>(verifier, VT_DENSE_SIZE) &&
           VerifyField<uint8_t>(verifier, VT_ARRAY_SEGMENTS_TYPE) &&
           VerifyOffset(verifier, VT_ARRAY_SEGMENTS) &&
           VerifySparseIndexVector(verifier, array_segments(), array_segments_type()) &&
           VerifyField<uint8_t>(verifier, VT_ARRAY_INDICES_TYPE) &&
           VerifyOffset(verifier, VT_ARRAY_INDICES) &&
           VerifySparseIndexVector(verifier, array_indices(), array_indices_type()) &&
           verifier.EndTable();
  }
  DimensionMetadataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DimensionMetadataT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DimensionMetadata>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const DimensionMetadataT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template <>
inline const circle::Int32Vector *DimensionMetadata::array_segments_as<circle::Int32Vector>() const
{
  return array_segments_as_Int32Vector();
}

template <>
inline const circle::Uint16Vector *
DimensionMetadata::array_segments_as<circle::Uint16Vector>() const
{
  return array_segments_as_Uint16Vector();
}

template <>
inline const circle::Uint8Vector *DimensionMetadata::array_segments_as<circle::Uint8Vector>() const
{
  return array_segments_as_Uint8Vector();
}

template <>
inline const circle::Int32Vector *DimensionMetadata::array_indices_as<circle::Int32Vector>() const
{
  return array_indices_as_Int32Vector();
}

template <>
inline const circle::Uint16Vector *DimensionMetadata::array_indices_as<circle::Uint16Vector>() const
{
  return array_indices_as_Uint16Vector();
}

template <>
inline const circle::Uint8Vector *DimensionMetadata::array_indices_as<circle::Uint8Vector>() const
{
  return array_indices_as_Uint8Vector();
}

struct DimensionMetadataBuilder
{
  typedef DimensionMetadata Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(circle::DimensionType format)
  {
    fbb_.AddElement<int8_t>(DimensionMetadata::VT_FORMAT, static_cast<int8_t>(format), 0);
  }
  void add_dense_size(int32_t dense_size)
  {
    fbb_.AddElement<int32_t>(DimensionMetadata::VT_DENSE_SIZE, dense_size, 0);
  }
  void add_array_segments_type(circle::SparseIndexVector array_segments_type)
  {
    fbb_.AddElement<uint8_t>(DimensionMetadata::VT_ARRAY_SEGMENTS_TYPE,
                             static_cast<uint8_t>(array_segments_type), 0);
  }
  void add_array_segments(flatbuffers::Offset<void> array_segments)
  {
    fbb_.AddOffset(DimensionMetadata::VT_ARRAY_SEGMENTS, array_segments);
  }
  void add_array_indices_type(circle::SparseIndexVector array_indices_type)
  {
    fbb_.AddElement<uint8_t>(DimensionMetadata::VT_ARRAY_INDICES_TYPE,
                             static_cast<uint8_t>(array_indices_type), 0);
  }
  void add_array_indices(flatbuffers::Offset<void> array_indices)
  {
    fbb_.AddOffset(DimensionMetadata::VT_ARRAY_INDICES, array_indices);
  }
  explicit DimensionMetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DimensionMetadata> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DimensionMetadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<DimensionMetadata> CreateDimensionMetadata(
  flatbuffers::FlatBufferBuilder &_fbb, circle::DimensionType format = circle::DimensionType_DENSE,
  int32_t dense_size = 0,
  circle::SparseIndexVector array_segments_type = circle::SparseIndexVector_NONE,
  flatbuffers::Offset<void> array_segments = 0,
  circle::SparseIndexVector array_indices_type = circle::SparseIndexVector_NONE,
  flatbuffers::Offset<void> array_indices = 0)
{
  DimensionMetadataBuilder builder_(_fbb);
  builder_.add_array_indices(array_indices);
  builder_.add_array_segments(array_segments);
  builder_.add_dense_size(dense_size);
  builder_.add_array_indices_type(array_indices_type);
  builder_.add_array_segments_type(array_segments_type);
  builder_.add_format(format);
  return builder_.Finish();
}

flatbuffers::Offset<DimensionMetadata>
CreateDimensionMetadata(flatbuffers::FlatBufferBuilder &_fbb, const DimensionMetadataT *_o,
                        const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SparsityParametersT : public flatbuffers::NativeTable
{
  typedef SparsityParameters TableType;
  std::vector<int32_t> traversal_order{};
  std::vector<int32_t> block_map{};
  std::vector<std::unique_ptr<circle::DimensionMetadataT>> dim_metadata{};
};

struct SparsityParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef SparsityParametersT NativeTableType;
  typedef SparsityParametersBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_TRAVERSAL_ORDER = 4,
    VT_BLOCK_MAP = 6,
    VT_DIM_METADATA = 8
  };
  const flatbuffers::Vector<int32_t> *traversal_order() const
  {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_TRAVERSAL_ORDER);
  }
  const flatbuffers::Vector<int32_t> *block_map() const
  {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_BLOCK_MAP);
  }
  const flatbuffers::Vector<flatbuffers::Offset<circle::DimensionMetadata>> *dim_metadata() const
  {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<circle::DimensionMetadata>> *>(
      VT_DIM_METADATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_TRAVERSAL_ORDER) &&
           verifier.VerifyVector(traversal_order()) && VerifyOffset(verifier, VT_BLOCK_MAP) &&
           verifier.VerifyVector(block_map()) && VerifyOffset(verifier, VT_DIM_METADATA) &&
           verifier.VerifyVector(dim_metadata()) && verifier.VerifyVectorOfTables(dim_metadata()) &&
           verifier.EndTable();
  }
  SparsityParametersT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SparsityParametersT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SparsityParameters>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const SparsityParametersT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SparsityParametersBuilder
{
  typedef SparsityParameters Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_traversal_order(flatbuffers::Offset<flatbuffers::Vector<int32_t>> traversal_order)
  {
    fbb_.AddOffset(SparsityParameters::VT_TRAVERSAL_ORDER, traversal_order);
  }
  void add_block_map(flatbuffers::Offset<flatbuffers::Vector<int32_t>> block_map)
  {
    fbb_.AddOffset(SparsityParameters::VT_BLOCK_MAP, block_map);
  }
  void add_dim_metadata(
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<circle::DimensionMetadata>>>
      dim_metadata)
  {
    fbb_.AddOffset(SparsityParameters::VT_DIM_METADATA, dim_metadata);
  }
  explicit SparsityParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SparsityParameters> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SparsityParameters>(end);
    return o;
  }
};

inline flatbuffers::Offset<SparsityParameters> CreateSparsityParameters(
  flatbuffers::FlatBufferBuilder &_fbb,
  flatbuffers::Offset<flatbuffers::Vector<int32_t>> traversal_order = 0,
  flatbuffers::Offset<flatbuffers::Vector<int32_t>> block_map = 0,
  flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<circle::DimensionMetadata>>>
    dim_metadata = 0)
{
  SparsityParametersBuilder builder_(_fbb);
  builder_.add_dim_metadata(dim_metadata);
  builder_.add_block_map(block_map);
  builder_.add_traversal_order(traversal_order);
  return builder_.Finish();
}

inline flatbuffers::Offset<SparsityParameters> CreateSparsityParametersDirect(
  flatbuffers::FlatBufferBuilder &_fbb, const std::vector<int32_t> *traversal_order = nullptr,
  const std::vector<int32_t> *block_map = nullptr,
  const std::vector<flatbuffers::Offset<circle::DimensionMetadata>> *dim_metadata = nullptr)
{
  auto traversal_order__ = traversal_order ? _fbb.CreateVector<int32_t>(*traversal_order) : 0;
  auto block_map__ = block_map ? _fbb.CreateVector<int32_t>(*block_map) : 0;
  auto dim_metadata__ =
    dim_metadata ? _fbb.CreateVector<flatbuffers::Offset<circle::DimensionMetadata>>(*dim_metadata)
                 : 0;
  return circle::CreateSparsityParameters(_fbb, traversal_order__, block_map__, dim_metadata__);
}

flatbuffers::Offset<SparsityParameters>
CreateSparsityParameters(flatbuffers::FlatBufferBuilder &_fbb, const SparsityParametersT *_o,
                         const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TensorT : public flatbuffers::NativeTable
{
  typedef Tensor TableType;
  std::vector<int32_t> shape{};
  circle::TensorType type = circle::TensorType_FLOAT32;
  uint32_t buffer = 0;
  std::string name{};
  std::unique_ptr<circle::QuantizationParametersT> quantization{};
  bool is_variable = false;
  std::unique_ptr<circle::SparsityParametersT> sparsity{};
  std::vector<int32_t> shape_signature{};
};

struct Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef TensorT NativeTableType;
  typedef TensorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_SHAPE = 4,
    VT_TYPE = 6,
    VT_BUFFER = 8,
    VT_NAME = 10,
    VT_QUANTIZATION = 12,
    VT_IS_VARIABLE = 14,
    VT_SPARSITY = 16,
    VT_SHAPE_SIGNATURE = 18
  };
  const flatbuffers::Vector<int32_t> *shape() const
  {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SHAPE);
  }
  circle::TensorType type() const
  {
    return static_cast<circle::TensorType>(GetField<int8_t>(VT_TYPE, 0));
  }
  uint32_t buffer() const { return GetField<uint32_t>(VT_BUFFER, 0); }
  const flatbuffers::String *name() const
  {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const circle::QuantizationParameters *quantization() const
  {
    return GetPointer<const circle::QuantizationParameters *>(VT_QUANTIZATION);
  }
  bool is_variable() const { return GetField<uint8_t>(VT_IS_VARIABLE, 0) != 0; }
  const circle::SparsityParameters *sparsity() const
  {
    return GetPointer<const circle::SparsityParameters *>(VT_SPARSITY);
  }
  const flatbuffers::Vector<int32_t> *shape_signature() const
  {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SHAPE_SIGNATURE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) && VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<uint32_t>(verifier, VT_BUFFER) && VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) && VerifyOffset(verifier, VT_QUANTIZATION) &&
           verifier.VerifyTable(quantization()) && VerifyField<uint8_t>(verifier, VT_IS_VARIABLE) &&
           VerifyOffset(verifier, VT_SPARSITY) && verifier.VerifyTable(sparsity()) &&
           VerifyOffset(verifier, VT_SHAPE_SIGNATURE) && verifier.VerifyVector(shape_signature()) &&
           verifier.EndTable();
  }
  TensorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TensorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Tensor>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorBuilder
{
  typedef Tensor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape)
  {
    fbb_.AddOffset(Tensor::VT_SHAPE, shape);
  }
  void add_type(circle::TensorType type)
  {
    fbb_.AddElement<int8_t>(Tensor::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_buffer(uint32_t buffer) { fbb_.AddElement<uint32_t>(Tensor::VT_BUFFER, buffer, 0); }
  void add_name(flatbuffers::Offset<flatbuffers::String> name)
  {
    fbb_.AddOffset(Tensor::VT_NAME, name);
  }
  void add_quantization(flatbuffers::Offset<circle::QuantizationParameters> quantization)
  {
    fbb_.AddOffset(Tensor::VT_QUANTIZATION, quantization);
  }
  void add_is_variable(bool is_variable)
  {
    fbb_.AddElement<uint8_t>(Tensor::VT_IS_VARIABLE, static_cast<uint8_t>(is_variable), 0);
  }
  void add_sparsity(flatbuffers::Offset<circle::SparsityParameters> sparsity)
  {
    fbb_.AddOffset(Tensor::VT_SPARSITY, sparsity);
  }
  void add_shape_signature(flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape_signature)
  {
    fbb_.AddOffset(Tensor::VT_SHAPE_SIGNATURE, shape_signature);
  }
  explicit TensorBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Tensor> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tensor>
CreateTensor(flatbuffers::FlatBufferBuilder &_fbb,
             flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape = 0,
             circle::TensorType type = circle::TensorType_FLOAT32, uint32_t buffer = 0,
             flatbuffers::Offset<flatbuffers::String> name = 0,
             flatbuffers::Offset<circle::QuantizationParameters> quantization = 0,
             bool is_variable = false, flatbuffers::Offset<circle::SparsityParameters> sparsity = 0,
             flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape_signature = 0)
{
  TensorBuilder builder_(_fbb);
  builder_.add_shape_signature(shape_signature);
  builder_.add_sparsity(sparsity);
  builder_.add_quantization(quantization);
  builder_.add_name(name);
  builder_.add_buffer(buffer);
  builder_.add_shape(shape);
  builder_.add_is_variable(is_variable);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Tensor> CreateTensorDirect(
  flatbuffers::FlatBufferBuilder &_fbb, const std::vector<int32_t> *shape = nullptr,
  circle::TensorType type = circle::TensorType_FLOAT32, uint32_t buffer = 0,
  const char *name = nullptr, flatbuffers::Offset<circle::QuantizationParameters> quantization = 0,
  bool is_variable = false, flatbuffers::Offset<circle::SparsityParameters> sparsity = 0,
  const std::vector<int32_t> *shape_signature = nullptr)
{
  auto shape__ = shape ? _fbb.CreateVector<int32_t>(*shape) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto shape_signature__ = shape_signature ? _fbb.CreateVector<int32_t>(*shape_signature) : 0;
  return circle::CreateTensor(_fbb, shape__, type, buffer, name__, quantization, is_variable,
                              sparsity, shape_signature__);
}

flatbuffers::Offset<Tensor>
CreateTensor(flatbuffers::FlatBufferBuilder &_fbb, const TensorT *_o,
             const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Conv2DOptionsT : public flatbuffers::NativeTable
{
  typedef Conv2DOptions TableType;
  circle::Padding padding = circle::Padding_SAME;
  int32_t stride_w = 0;
  int32_t stride_h = 0;
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE;
  int32_t dilation_w_factor = 1;
  int32_t dilation_h_factor = 1;
};

struct Conv2DOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef Conv2DOptionsT NativeTableType;
  typedef Conv2DOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_PADDING = 4,
    VT_STRIDE_W = 6,
    VT_STRIDE_H = 8,
    VT_FUSED_ACTIVATION_FUNCTION = 10,
    VT_DILATION_W_FACTOR = 12,
    VT_DILATION_H_FACTOR = 14
  };
  circle::Padding padding() const
  {
    return static_cast<circle::Padding>(GetField<int8_t>(VT_PADDING, 0));
  }
  int32_t stride_w() const { return GetField<int32_t>(VT_STRIDE_W, 0); }
  int32_t stride_h() const { return GetField<int32_t>(VT_STRIDE_H, 0); }
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  int32_t dilation_w_factor() const { return GetField<int32_t>(VT_DILATION_W_FACTOR, 1); }
  int32_t dilation_h_factor() const { return GetField<int32_t>(VT_DILATION_H_FACTOR, 1); }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_PADDING) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_W) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_H) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<int32_t>(verifier, VT_DILATION_W_FACTOR) &&
           VerifyField<int32_t>(verifier, VT_DILATION_H_FACTOR) && verifier.EndTable();
  }
  Conv2DOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Conv2DOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Conv2DOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Conv2DOptionsBuilder
{
  typedef Conv2DOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padding(circle::Padding padding)
  {
    fbb_.AddElement<int8_t>(Conv2DOptions::VT_PADDING, static_cast<int8_t>(padding), 0);
  }
  void add_stride_w(int32_t stride_w)
  {
    fbb_.AddElement<int32_t>(Conv2DOptions::VT_STRIDE_W, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h)
  {
    fbb_.AddElement<int32_t>(Conv2DOptions::VT_STRIDE_H, stride_h, 0);
  }
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(Conv2DOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_dilation_w_factor(int32_t dilation_w_factor)
  {
    fbb_.AddElement<int32_t>(Conv2DOptions::VT_DILATION_W_FACTOR, dilation_w_factor, 1);
  }
  void add_dilation_h_factor(int32_t dilation_h_factor)
  {
    fbb_.AddElement<int32_t>(Conv2DOptions::VT_DILATION_H_FACTOR, dilation_h_factor, 1);
  }
  explicit Conv2DOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Conv2DOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Conv2DOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<Conv2DOptions> CreateConv2DOptions(
  flatbuffers::FlatBufferBuilder &_fbb, circle::Padding padding = circle::Padding_SAME,
  int32_t stride_w = 0, int32_t stride_h = 0,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE,
  int32_t dilation_w_factor = 1, int32_t dilation_h_factor = 1)
{
  Conv2DOptionsBuilder builder_(_fbb);
  builder_.add_dilation_h_factor(dilation_h_factor);
  builder_.add_dilation_w_factor(dilation_w_factor);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_padding(padding);
  return builder_.Finish();
}

flatbuffers::Offset<Conv2DOptions>
CreateConv2DOptions(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Conv3DOptionsT : public flatbuffers::NativeTable
{
  typedef Conv3DOptions TableType;
  circle::Padding padding = circle::Padding_SAME;
  int32_t stride_d = 0;
  int32_t stride_w = 0;
  int32_t stride_h = 0;
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE;
  int32_t dilation_d_factor = 1;
  int32_t dilation_w_factor = 1;
  int32_t dilation_h_factor = 1;
};

struct Conv3DOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef Conv3DOptionsT NativeTableType;
  typedef Conv3DOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_PADDING = 4,
    VT_STRIDE_D = 6,
    VT_STRIDE_W = 8,
    VT_STRIDE_H = 10,
    VT_FUSED_ACTIVATION_FUNCTION = 12,
    VT_DILATION_D_FACTOR = 14,
    VT_DILATION_W_FACTOR = 16,
    VT_DILATION_H_FACTOR = 18
  };
  circle::Padding padding() const
  {
    return static_cast<circle::Padding>(GetField<int8_t>(VT_PADDING, 0));
  }
  int32_t stride_d() const { return GetField<int32_t>(VT_STRIDE_D, 0); }
  int32_t stride_w() const { return GetField<int32_t>(VT_STRIDE_W, 0); }
  int32_t stride_h() const { return GetField<int32_t>(VT_STRIDE_H, 0); }
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  int32_t dilation_d_factor() const { return GetField<int32_t>(VT_DILATION_D_FACTOR, 1); }
  int32_t dilation_w_factor() const { return GetField<int32_t>(VT_DILATION_W_FACTOR, 1); }
  int32_t dilation_h_factor() const { return GetField<int32_t>(VT_DILATION_H_FACTOR, 1); }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_PADDING) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_D) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_W) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_H) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<int32_t>(verifier, VT_DILATION_D_FACTOR) &&
           VerifyField<int32_t>(verifier, VT_DILATION_W_FACTOR) &&
           VerifyField<int32_t>(verifier, VT_DILATION_H_FACTOR) && verifier.EndTable();
  }
  Conv3DOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Conv3DOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Conv3DOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv3DOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Conv3DOptionsBuilder
{
  typedef Conv3DOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padding(circle::Padding padding)
  {
    fbb_.AddElement<int8_t>(Conv3DOptions::VT_PADDING, static_cast<int8_t>(padding), 0);
  }
  void add_stride_d(int32_t stride_d)
  {
    fbb_.AddElement<int32_t>(Conv3DOptions::VT_STRIDE_D, stride_d, 0);
  }
  void add_stride_w(int32_t stride_w)
  {
    fbb_.AddElement<int32_t>(Conv3DOptions::VT_STRIDE_W, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h)
  {
    fbb_.AddElement<int32_t>(Conv3DOptions::VT_STRIDE_H, stride_h, 0);
  }
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(Conv3DOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_dilation_d_factor(int32_t dilation_d_factor)
  {
    fbb_.AddElement<int32_t>(Conv3DOptions::VT_DILATION_D_FACTOR, dilation_d_factor, 1);
  }
  void add_dilation_w_factor(int32_t dilation_w_factor)
  {
    fbb_.AddElement<int32_t>(Conv3DOptions::VT_DILATION_W_FACTOR, dilation_w_factor, 1);
  }
  void add_dilation_h_factor(int32_t dilation_h_factor)
  {
    fbb_.AddElement<int32_t>(Conv3DOptions::VT_DILATION_H_FACTOR, dilation_h_factor, 1);
  }
  explicit Conv3DOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Conv3DOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Conv3DOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<Conv3DOptions> CreateConv3DOptions(
  flatbuffers::FlatBufferBuilder &_fbb, circle::Padding padding = circle::Padding_SAME,
  int32_t stride_d = 0, int32_t stride_w = 0, int32_t stride_h = 0,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE,
  int32_t dilation_d_factor = 1, int32_t dilation_w_factor = 1, int32_t dilation_h_factor = 1)
{
  Conv3DOptionsBuilder builder_(_fbb);
  builder_.add_dilation_h_factor(dilation_h_factor);
  builder_.add_dilation_w_factor(dilation_w_factor);
  builder_.add_dilation_d_factor(dilation_d_factor);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_stride_d(stride_d);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_padding(padding);
  return builder_.Finish();
}

flatbuffers::Offset<Conv3DOptions>
CreateConv3DOptions(flatbuffers::FlatBufferBuilder &_fbb, const Conv3DOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Pool2DOptionsT : public flatbuffers::NativeTable
{
  typedef Pool2DOptions TableType;
  circle::Padding padding = circle::Padding_SAME;
  int32_t stride_w = 0;
  int32_t stride_h = 0;
  int32_t filter_width = 0;
  int32_t filter_height = 0;
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE;
};

struct Pool2DOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef Pool2DOptionsT NativeTableType;
  typedef Pool2DOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_PADDING = 4,
    VT_STRIDE_W = 6,
    VT_STRIDE_H = 8,
    VT_FILTER_WIDTH = 10,
    VT_FILTER_HEIGHT = 12,
    VT_FUSED_ACTIVATION_FUNCTION = 14
  };
  circle::Padding padding() const
  {
    return static_cast<circle::Padding>(GetField<int8_t>(VT_PADDING, 0));
  }
  int32_t stride_w() const { return GetField<int32_t>(VT_STRIDE_W, 0); }
  int32_t stride_h() const { return GetField<int32_t>(VT_STRIDE_H, 0); }
  int32_t filter_width() const { return GetField<int32_t>(VT_FILTER_WIDTH, 0); }
  int32_t filter_height() const { return GetField<int32_t>(VT_FILTER_HEIGHT, 0); }
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_PADDING) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_W) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_H) &&
           VerifyField<int32_t>(verifier, VT_FILTER_WIDTH) &&
           VerifyField<int32_t>(verifier, VT_FILTER_HEIGHT) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) && verifier.EndTable();
  }
  Pool2DOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Pool2DOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Pool2DOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const Pool2DOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Pool2DOptionsBuilder
{
  typedef Pool2DOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padding(circle::Padding padding)
  {
    fbb_.AddElement<int8_t>(Pool2DOptions::VT_PADDING, static_cast<int8_t>(padding), 0);
  }
  void add_stride_w(int32_t stride_w)
  {
    fbb_.AddElement<int32_t>(Pool2DOptions::VT_STRIDE_W, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h)
  {
    fbb_.AddElement<int32_t>(Pool2DOptions::VT_STRIDE_H, stride_h, 0);
  }
  void add_filter_width(int32_t filter_width)
  {
    fbb_.AddElement<int32_t>(Pool2DOptions::VT_FILTER_WIDTH, filter_width, 0);
  }
  void add_filter_height(int32_t filter_height)
  {
    fbb_.AddElement<int32_t>(Pool2DOptions::VT_FILTER_HEIGHT, filter_height, 0);
  }
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(Pool2DOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit Pool2DOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Pool2DOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pool2DOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pool2DOptions> CreatePool2DOptions(
  flatbuffers::FlatBufferBuilder &_fbb, circle::Padding padding = circle::Padding_SAME,
  int32_t stride_w = 0, int32_t stride_h = 0, int32_t filter_width = 0, int32_t filter_height = 0,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE)
{
  Pool2DOptionsBuilder builder_(_fbb);
  builder_.add_filter_height(filter_height);
  builder_.add_filter_width(filter_width);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_padding(padding);
  return builder_.Finish();
}

flatbuffers::Offset<Pool2DOptions>
CreatePool2DOptions(flatbuffers::FlatBufferBuilder &_fbb, const Pool2DOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DepthwiseConv2DOptionsT : public flatbuffers::NativeTable
{
  typedef DepthwiseConv2DOptions TableType;
  circle::Padding padding = circle::Padding_SAME;
  int32_t stride_w = 0;
  int32_t stride_h = 0;
  int32_t depth_multiplier = 0;
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE;
  int32_t dilation_w_factor = 1;
  int32_t dilation_h_factor = 1;
};

struct DepthwiseConv2DOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef DepthwiseConv2DOptionsT NativeTableType;
  typedef DepthwiseConv2DOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_PADDING = 4,
    VT_STRIDE_W = 6,
    VT_STRIDE_H = 8,
    VT_DEPTH_MULTIPLIER = 10,
    VT_FUSED_ACTIVATION_FUNCTION = 12,
    VT_DILATION_W_FACTOR = 14,
    VT_DILATION_H_FACTOR = 16
  };
  circle::Padding padding() const
  {
    return static_cast<circle::Padding>(GetField<int8_t>(VT_PADDING, 0));
  }
  int32_t stride_w() const { return GetField<int32_t>(VT_STRIDE_W, 0); }
  int32_t stride_h() const { return GetField<int32_t>(VT_STRIDE_H, 0); }
  int32_t depth_multiplier() const { return GetField<int32_t>(VT_DEPTH_MULTIPLIER, 0); }
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  int32_t dilation_w_factor() const { return GetField<int32_t>(VT_DILATION_W_FACTOR, 1); }
  int32_t dilation_h_factor() const { return GetField<int32_t>(VT_DILATION_H_FACTOR, 1); }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_PADDING) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_W) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_H) &&
           VerifyField<int32_t>(verifier, VT_DEPTH_MULTIPLIER) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<int32_t>(verifier, VT_DILATION_W_FACTOR) &&
           VerifyField<int32_t>(verifier, VT_DILATION_H_FACTOR) && verifier.EndTable();
  }
  DepthwiseConv2DOptionsT *
  UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DepthwiseConv2DOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DepthwiseConv2DOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const DepthwiseConv2DOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DepthwiseConv2DOptionsBuilder
{
  typedef DepthwiseConv2DOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padding(circle::Padding padding)
  {
    fbb_.AddElement<int8_t>(DepthwiseConv2DOptions::VT_PADDING, static_cast<int8_t>(padding), 0);
  }
  void add_stride_w(int32_t stride_w)
  {
    fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_STRIDE_W, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h)
  {
    fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_STRIDE_H, stride_h, 0);
  }
  void add_depth_multiplier(int32_t depth_multiplier)
  {
    fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_DEPTH_MULTIPLIER, depth_multiplier, 0);
  }
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(DepthwiseConv2DOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_dilation_w_factor(int32_t dilation_w_factor)
  {
    fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_DILATION_W_FACTOR, dilation_w_factor, 1);
  }
  void add_dilation_h_factor(int32_t dilation_h_factor)
  {
    fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_DILATION_H_FACTOR, dilation_h_factor, 1);
  }
  explicit DepthwiseConv2DOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DepthwiseConv2DOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DepthwiseConv2DOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<DepthwiseConv2DOptions> CreateDepthwiseConv2DOptions(
  flatbuffers::FlatBufferBuilder &_fbb, circle::Padding padding = circle::Padding_SAME,
  int32_t stride_w = 0, int32_t stride_h = 0, int32_t depth_multiplier = 0,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE,
  int32_t dilation_w_factor = 1, int32_t dilation_h_factor = 1)
{
  DepthwiseConv2DOptionsBuilder builder_(_fbb);
  builder_.add_dilation_h_factor(dilation_h_factor);
  builder_.add_dilation_w_factor(dilation_w_factor);
  builder_.add_depth_multiplier(depth_multiplier);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_padding(padding);
  return builder_.Finish();
}

flatbuffers::Offset<DepthwiseConv2DOptions>
CreateDepthwiseConv2DOptions(flatbuffers::FlatBufferBuilder &_fbb,
                             const DepthwiseConv2DOptionsT *_o,
                             const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ConcatEmbeddingsOptionsT : public flatbuffers::NativeTable
{
  typedef ConcatEmbeddingsOptions TableType;
  int32_t num_channels = 0;
  std::vector<int32_t> num_columns_per_channel{};
  std::vector<int32_t> embedding_dim_per_channel{};
};

struct ConcatEmbeddingsOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef ConcatEmbeddingsOptionsT NativeTableType;
  typedef ConcatEmbeddingsOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_NUM_CHANNELS = 4,
    VT_NUM_COLUMNS_PER_CHANNEL = 6,
    VT_EMBEDDING_DIM_PER_CHANNEL = 8
  };
  int32_t num_channels() const { return GetField<int32_t>(VT_NUM_CHANNELS, 0); }
  const flatbuffers::Vector<int32_t> *num_columns_per_channel() const
  {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_NUM_COLUMNS_PER_CHANNEL);
  }
  const flatbuffers::Vector<int32_t> *embedding_dim_per_channel() const
  {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_EMBEDDING_DIM_PER_CHANNEL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_NUM_CHANNELS) &&
           VerifyOffset(verifier, VT_NUM_COLUMNS_PER_CHANNEL) &&
           verifier.VerifyVector(num_columns_per_channel()) &&
           VerifyOffset(verifier, VT_EMBEDDING_DIM_PER_CHANNEL) &&
           verifier.VerifyVector(embedding_dim_per_channel()) && verifier.EndTable();
  }
  ConcatEmbeddingsOptionsT *
  UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ConcatEmbeddingsOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ConcatEmbeddingsOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConcatEmbeddingsOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ConcatEmbeddingsOptionsBuilder
{
  typedef ConcatEmbeddingsOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_channels(int32_t num_channels)
  {
    fbb_.AddElement<int32_t>(ConcatEmbeddingsOptions::VT_NUM_CHANNELS, num_channels, 0);
  }
  void add_num_columns_per_channel(
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> num_columns_per_channel)
  {
    fbb_.AddOffset(ConcatEmbeddingsOptions::VT_NUM_COLUMNS_PER_CHANNEL, num_columns_per_channel);
  }
  void add_embedding_dim_per_channel(
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> embedding_dim_per_channel)
  {
    fbb_.AddOffset(ConcatEmbeddingsOptions::VT_EMBEDDING_DIM_PER_CHANNEL,
                   embedding_dim_per_channel);
  }
  explicit ConcatEmbeddingsOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ConcatEmbeddingsOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConcatEmbeddingsOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConcatEmbeddingsOptions> CreateConcatEmbeddingsOptions(
  flatbuffers::FlatBufferBuilder &_fbb, int32_t num_channels = 0,
  flatbuffers::Offset<flatbuffers::Vector<int32_t>> num_columns_per_channel = 0,
  flatbuffers::Offset<flatbuffers::Vector<int32_t>> embedding_dim_per_channel = 0)
{
  ConcatEmbeddingsOptionsBuilder builder_(_fbb);
  builder_.add_embedding_dim_per_channel(embedding_dim_per_channel);
  builder_.add_num_columns_per_channel(num_columns_per_channel);
  builder_.add_num_channels(num_channels);
  return builder_.Finish();
}

inline flatbuffers::Offset<ConcatEmbeddingsOptions>
CreateConcatEmbeddingsOptionsDirect(flatbuffers::FlatBufferBuilder &_fbb, int32_t num_channels = 0,
                                    const std::vector<int32_t> *num_columns_per_channel = nullptr,
                                    const std::vector<int32_t> *embedding_dim_per_channel = nullptr)
{
  auto num_columns_per_channel__ =
    num_columns_per_channel ? _fbb.CreateVector<int32_t>(*num_columns_per_channel) : 0;
  auto embedding_dim_per_channel__ =
    embedding_dim_per_channel ? _fbb.CreateVector<int32_t>(*embedding_dim_per_channel) : 0;
  return circle::CreateConcatEmbeddingsOptions(_fbb, num_channels, num_columns_per_channel__,
                                               embedding_dim_per_channel__);
}

flatbuffers::Offset<ConcatEmbeddingsOptions>
CreateConcatEmbeddingsOptions(flatbuffers::FlatBufferBuilder &_fbb,
                              const ConcatEmbeddingsOptionsT *_o,
                              const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LSHProjectionOptionsT : public flatbuffers::NativeTable
{
  typedef LSHProjectionOptions TableType;
  circle::LSHProjectionType type = circle::LSHProjectionType_UNKNOWN;
};

struct LSHProjectionOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef LSHProjectionOptionsT NativeTableType;
  typedef LSHProjectionOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_TYPE = 4
  };
  circle::LSHProjectionType type() const
  {
    return static_cast<circle::LSHProjectionType>(GetField<int8_t>(VT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
  LSHProjectionOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LSHProjectionOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LSHProjectionOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSHProjectionOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LSHProjectionOptionsBuilder
{
  typedef LSHProjectionOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(circle::LSHProjectionType type)
  {
    fbb_.AddElement<int8_t>(LSHProjectionOptions::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  explicit LSHProjectionOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LSHProjectionOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LSHProjectionOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LSHProjectionOptions>
CreateLSHProjectionOptions(flatbuffers::FlatBufferBuilder &_fbb,
                           circle::LSHProjectionType type = circle::LSHProjectionType_UNKNOWN)
{
  LSHProjectionOptionsBuilder builder_(_fbb);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<LSHProjectionOptions>
CreateLSHProjectionOptions(flatbuffers::FlatBufferBuilder &_fbb, const LSHProjectionOptionsT *_o,
                           const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SVDFOptionsT : public flatbuffers::NativeTable
{
  typedef SVDFOptions TableType;
  int32_t rank = 0;
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE;
  bool asymmetric_quantize_inputs = false;
};

struct SVDFOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef SVDFOptionsT NativeTableType;
  typedef SVDFOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_RANK = 4,
    VT_FUSED_ACTIVATION_FUNCTION = 6,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 8
  };
  int32_t rank() const { return GetField<int32_t>(VT_RANK, 0); }
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool asymmetric_quantize_inputs() const
  {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_RANK) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) && verifier.EndTable();
  }
  SVDFOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SVDFOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SVDFOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const SVDFOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SVDFOptionsBuilder
{
  typedef SVDFOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rank(int32_t rank) { fbb_.AddElement<int32_t>(SVDFOptions::VT_RANK, rank, 0); }
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(SVDFOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs)
  {
    fbb_.AddElement<uint8_t>(SVDFOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                             static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit SVDFOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SVDFOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SVDFOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVDFOptions> CreateSVDFOptions(
  flatbuffers::FlatBufferBuilder &_fbb, int32_t rank = 0,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE,
  bool asymmetric_quantize_inputs = false)
{
  SVDFOptionsBuilder builder_(_fbb);
  builder_.add_rank(rank);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<SVDFOptions>
CreateSVDFOptions(flatbuffers::FlatBufferBuilder &_fbb, const SVDFOptionsT *_o,
                  const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RNNOptionsT : public flatbuffers::NativeTable
{
  typedef RNNOptions TableType;
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE;
  bool asymmetric_quantize_inputs = false;
};

struct RNNOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef RNNOptionsT NativeTableType;
  typedef RNNOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 6
  };
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool asymmetric_quantize_inputs() const
  {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) && verifier.EndTable();
  }
  RNNOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RNNOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RNNOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const RNNOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RNNOptionsBuilder
{
  typedef RNNOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(RNNOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs)
  {
    fbb_.AddElement<uint8_t>(RNNOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                             static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit RNNOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RNNOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RNNOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<RNNOptions> CreateRNNOptions(
  flatbuffers::FlatBufferBuilder &_fbb,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE,
  bool asymmetric_quantize_inputs = false)
{
  RNNOptionsBuilder builder_(_fbb);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<RNNOptions>
CreateRNNOptions(flatbuffers::FlatBufferBuilder &_fbb, const RNNOptionsT *_o,
                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SequenceRNNOptionsT : public flatbuffers::NativeTable
{
  typedef SequenceRNNOptions TableType;
  bool time_major = false;
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE;
  bool asymmetric_quantize_inputs = false;
};

struct SequenceRNNOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef SequenceRNNOptionsT NativeTableType;
  typedef SequenceRNNOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_TIME_MAJOR = 4,
    VT_FUSED_ACTIVATION_FUNCTION = 6,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 8
  };
  bool time_major() const { return GetField<uint8_t>(VT_TIME_MAJOR, 0) != 0; }
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool asymmetric_quantize_inputs() const
  {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_TIME_MAJOR) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) && verifier.EndTable();
  }
  SequenceRNNOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SequenceRNNOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SequenceRNNOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const SequenceRNNOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SequenceRNNOptionsBuilder
{
  typedef SequenceRNNOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time_major(bool time_major)
  {
    fbb_.AddElement<uint8_t>(SequenceRNNOptions::VT_TIME_MAJOR, static_cast<uint8_t>(time_major),
                             0);
  }
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(SequenceRNNOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs)
  {
    fbb_.AddElement<uint8_t>(SequenceRNNOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                             static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit SequenceRNNOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SequenceRNNOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SequenceRNNOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SequenceRNNOptions> CreateSequenceRNNOptions(
  flatbuffers::FlatBufferBuilder &_fbb, bool time_major = false,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE,
  bool asymmetric_quantize_inputs = false)
{
  SequenceRNNOptionsBuilder builder_(_fbb);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_time_major(time_major);
  return builder_.Finish();
}

flatbuffers::Offset<SequenceRNNOptions>
CreateSequenceRNNOptions(flatbuffers::FlatBufferBuilder &_fbb, const SequenceRNNOptionsT *_o,
                         const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BidirectionalSequenceRNNOptionsT : public flatbuffers::NativeTable
{
  typedef BidirectionalSequenceRNNOptions TableType;
  bool time_major = false;
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE;
  bool merge_outputs = false;
  bool asymmetric_quantize_inputs = false;
};

struct BidirectionalSequenceRNNOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef BidirectionalSequenceRNNOptionsT NativeTableType;
  typedef BidirectionalSequenceRNNOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_TIME_MAJOR = 4,
    VT_FUSED_ACTIVATION_FUNCTION = 6,
    VT_MERGE_OUTPUTS = 8,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 10
  };
  bool time_major() const { return GetField<uint8_t>(VT_TIME_MAJOR, 0) != 0; }
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool merge_outputs() const { return GetField<uint8_t>(VT_MERGE_OUTPUTS, 0) != 0; }
  bool asymmetric_quantize_inputs() const
  {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_TIME_MAJOR) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<uint8_t>(verifier, VT_MERGE_OUTPUTS) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) && verifier.EndTable();
  }
  BidirectionalSequenceRNNOptionsT *
  UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BidirectionalSequenceRNNOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BidirectionalSequenceRNNOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceRNNOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BidirectionalSequenceRNNOptionsBuilder
{
  typedef BidirectionalSequenceRNNOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time_major(bool time_major)
  {
    fbb_.AddElement<uint8_t>(BidirectionalSequenceRNNOptions::VT_TIME_MAJOR,
                             static_cast<uint8_t>(time_major), 0);
  }
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(BidirectionalSequenceRNNOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_merge_outputs(bool merge_outputs)
  {
    fbb_.AddElement<uint8_t>(BidirectionalSequenceRNNOptions::VT_MERGE_OUTPUTS,
                             static_cast<uint8_t>(merge_outputs), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs)
  {
    fbb_.AddElement<uint8_t>(BidirectionalSequenceRNNOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                             static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit BidirectionalSequenceRNNOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BidirectionalSequenceRNNOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BidirectionalSequenceRNNOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BidirectionalSequenceRNNOptions> CreateBidirectionalSequenceRNNOptions(
  flatbuffers::FlatBufferBuilder &_fbb, bool time_major = false,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE,
  bool merge_outputs = false, bool asymmetric_quantize_inputs = false)
{
  BidirectionalSequenceRNNOptionsBuilder builder_(_fbb);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_merge_outputs(merge_outputs);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_time_major(time_major);
  return builder_.Finish();
}

flatbuffers::Offset<BidirectionalSequenceRNNOptions>
CreateBidirectionalSequenceRNNOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                      const BidirectionalSequenceRNNOptionsT *_o,
                                      const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FullyConnectedOptionsT : public flatbuffers::NativeTable
{
  typedef FullyConnectedOptions TableType;
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE;
  circle::FullyConnectedOptionsWeightsFormat weights_format =
    circle::FullyConnectedOptionsWeightsFormat_DEFAULT;
  bool keep_num_dims = false;
  bool asymmetric_quantize_inputs = false;
};

struct FullyConnectedOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef FullyConnectedOptionsT NativeTableType;
  typedef FullyConnectedOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_WEIGHTS_FORMAT = 6,
    VT_KEEP_NUM_DIMS = 8,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 10
  };
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  circle::FullyConnectedOptionsWeightsFormat weights_format() const
  {
    return static_cast<circle::FullyConnectedOptionsWeightsFormat>(
      GetField<int8_t>(VT_WEIGHTS_FORMAT, 0));
  }
  bool keep_num_dims() const { return GetField<uint8_t>(VT_KEEP_NUM_DIMS, 0) != 0; }
  bool asymmetric_quantize_inputs() const
  {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<int8_t>(verifier, VT_WEIGHTS_FORMAT) &&
           VerifyField<uint8_t>(verifier, VT_KEEP_NUM_DIMS) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) && verifier.EndTable();
  }
  FullyConnectedOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FullyConnectedOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FullyConnectedOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const FullyConnectedOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FullyConnectedOptionsBuilder
{
  typedef FullyConnectedOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(FullyConnectedOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_weights_format(circle::FullyConnectedOptionsWeightsFormat weights_format)
  {
    fbb_.AddElement<int8_t>(FullyConnectedOptions::VT_WEIGHTS_FORMAT,
                            static_cast<int8_t>(weights_format), 0);
  }
  void add_keep_num_dims(bool keep_num_dims)
  {
    fbb_.AddElement<uint8_t>(FullyConnectedOptions::VT_KEEP_NUM_DIMS,
                             static_cast<uint8_t>(keep_num_dims), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs)
  {
    fbb_.AddElement<uint8_t>(FullyConnectedOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                             static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit FullyConnectedOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FullyConnectedOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FullyConnectedOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<FullyConnectedOptions> CreateFullyConnectedOptions(
  flatbuffers::FlatBufferBuilder &_fbb,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE,
  circle::FullyConnectedOptionsWeightsFormat weights_format =
    circle::FullyConnectedOptionsWeightsFormat_DEFAULT,
  bool keep_num_dims = false, bool asymmetric_quantize_inputs = false)
{
  FullyConnectedOptionsBuilder builder_(_fbb);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_keep_num_dims(keep_num_dims);
  builder_.add_weights_format(weights_format);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<FullyConnectedOptions>
CreateFullyConnectedOptions(flatbuffers::FlatBufferBuilder &_fbb, const FullyConnectedOptionsT *_o,
                            const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SoftmaxOptionsT : public flatbuffers::NativeTable
{
  typedef SoftmaxOptions TableType;
  float beta = 0.0f;
};

struct SoftmaxOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef SoftmaxOptionsT NativeTableType;
  typedef SoftmaxOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_BETA = 4
  };
  float beta() const { return GetField<float>(VT_BETA, 0.0f); }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<float>(verifier, VT_BETA) &&
           verifier.EndTable();
  }
  SoftmaxOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SoftmaxOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SoftmaxOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SoftmaxOptionsBuilder
{
  typedef SoftmaxOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_beta(float beta) { fbb_.AddElement<float>(SoftmaxOptions::VT_BETA, beta, 0.0f); }
  explicit SoftmaxOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SoftmaxOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SoftmaxOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SoftmaxOptions>
CreateSoftmaxOptions(flatbuffers::FlatBufferBuilder &_fbb, float beta = 0.0f)
{
  SoftmaxOptionsBuilder builder_(_fbb);
  builder_.add_beta(beta);
  return builder_.Finish();
}

flatbuffers::Offset<SoftmaxOptions>
CreateSoftmaxOptions(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxOptionsT *_o,
                     const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ConcatenationOptionsT : public flatbuffers::NativeTable
{
  typedef ConcatenationOptions TableType;
  int32_t axis = 0;
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE;
};

struct ConcatenationOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef ConcatenationOptionsT NativeTableType;
  typedef ConcatenationOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_AXIS = 4,
    VT_FUSED_ACTIVATION_FUNCTION = 6
  };
  int32_t axis() const { return GetField<int32_t>(VT_AXIS, 0); }
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) && verifier.EndTable();
  }
  ConcatenationOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ConcatenationOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ConcatenationOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConcatenationOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ConcatenationOptionsBuilder
{
  typedef ConcatenationOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) { fbb_.AddElement<int32_t>(ConcatenationOptions::VT_AXIS, axis, 0); }
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(ConcatenationOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit ConcatenationOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ConcatenationOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConcatenationOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConcatenationOptions> CreateConcatenationOptions(
  flatbuffers::FlatBufferBuilder &_fbb, int32_t axis = 0,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE)
{
  ConcatenationOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<ConcatenationOptions>
CreateConcatenationOptions(flatbuffers::FlatBufferBuilder &_fbb, const ConcatenationOptionsT *_o,
                           const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AddOptionsT : public flatbuffers::NativeTable
{
  typedef AddOptions TableType;
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE;
  bool pot_scale_int16 = true;
};

struct AddOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef AddOptionsT NativeTableType;
  typedef AddOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_POT_SCALE_INT16 = 6
  };
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool pot_scale_int16() const { return GetField<uint8_t>(VT_POT_SCALE_INT16, 1) != 0; }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<uint8_t>(verifier, VT_POT_SCALE_INT16) && verifier.EndTable();
  }
  AddOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AddOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AddOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AddOptionsBuilder
{
  typedef AddOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(AddOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_pot_scale_int16(bool pot_scale_int16)
  {
    fbb_.AddElement<uint8_t>(AddOptions::VT_POT_SCALE_INT16, static_cast<uint8_t>(pot_scale_int16),
                             1);
  }
  explicit AddOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AddOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddOptions> CreateAddOptions(
  flatbuffers::FlatBufferBuilder &_fbb,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE,
  bool pot_scale_int16 = true)
{
  AddOptionsBuilder builder_(_fbb);
  builder_.add_pot_scale_int16(pot_scale_int16);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<AddOptions>
CreateAddOptions(flatbuffers::FlatBufferBuilder &_fbb, const AddOptionsT *_o,
                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MulOptionsT : public flatbuffers::NativeTable
{
  typedef MulOptions TableType;
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE;
};

struct MulOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef MulOptionsT NativeTableType;
  typedef MulOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_FUSED_ACTIVATION_FUNCTION = 4
  };
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) && verifier.EndTable();
  }
  MulOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MulOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MulOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const MulOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MulOptionsBuilder
{
  typedef MulOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(MulOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit MulOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MulOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MulOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<MulOptions> CreateMulOptions(
  flatbuffers::FlatBufferBuilder &_fbb,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE)
{
  MulOptionsBuilder builder_(_fbb);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<MulOptions>
CreateMulOptions(flatbuffers::FlatBufferBuilder &_fbb, const MulOptionsT *_o,
                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct L2NormOptionsT : public flatbuffers::NativeTable
{
  typedef L2NormOptions TableType;
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE;
};

struct L2NormOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef L2NormOptionsT NativeTableType;
  typedef L2NormOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_FUSED_ACTIVATION_FUNCTION = 4
  };
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) && verifier.EndTable();
  }
  L2NormOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(L2NormOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<L2NormOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const L2NormOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct L2NormOptionsBuilder
{
  typedef L2NormOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(L2NormOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit L2NormOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<L2NormOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<L2NormOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<L2NormOptions> CreateL2NormOptions(
  flatbuffers::FlatBufferBuilder &_fbb,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE)
{
  L2NormOptionsBuilder builder_(_fbb);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<L2NormOptions>
CreateL2NormOptions(flatbuffers::FlatBufferBuilder &_fbb, const L2NormOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LocalResponseNormalizationOptionsT : public flatbuffers::NativeTable
{
  typedef LocalResponseNormalizationOptions TableType;
  int32_t radius = 0;
  float bias = 0.0f;
  float alpha = 0.0f;
  float beta = 0.0f;
};

struct LocalResponseNormalizationOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef LocalResponseNormalizationOptionsT NativeTableType;
  typedef LocalResponseNormalizationOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_RADIUS = 4,
    VT_BIAS = 6,
    VT_ALPHA = 8,
    VT_BETA = 10
  };
  int32_t radius() const { return GetField<int32_t>(VT_RADIUS, 0); }
  float bias() const { return GetField<float>(VT_BIAS, 0.0f); }
  float alpha() const { return GetField<float>(VT_ALPHA, 0.0f); }
  float beta() const { return GetField<float>(VT_BETA, 0.0f); }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_RADIUS) &&
           VerifyField<float>(verifier, VT_BIAS) && VerifyField<float>(verifier, VT_ALPHA) &&
           VerifyField<float>(verifier, VT_BETA) && verifier.EndTable();
  }
  LocalResponseNormalizationOptionsT *
  UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LocalResponseNormalizationOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LocalResponseNormalizationOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const LocalResponseNormalizationOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LocalResponseNormalizationOptionsBuilder
{
  typedef LocalResponseNormalizationOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_radius(int32_t radius)
  {
    fbb_.AddElement<int32_t>(LocalResponseNormalizationOptions::VT_RADIUS, radius, 0);
  }
  void add_bias(float bias)
  {
    fbb_.AddElement<float>(LocalResponseNormalizationOptions::VT_BIAS, bias, 0.0f);
  }
  void add_alpha(float alpha)
  {
    fbb_.AddElement<float>(LocalResponseNormalizationOptions::VT_ALPHA, alpha, 0.0f);
  }
  void add_beta(float beta)
  {
    fbb_.AddElement<float>(LocalResponseNormalizationOptions::VT_BETA, beta, 0.0f);
  }
  explicit LocalResponseNormalizationOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
    : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LocalResponseNormalizationOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LocalResponseNormalizationOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LocalResponseNormalizationOptions>
CreateLocalResponseNormalizationOptions(flatbuffers::FlatBufferBuilder &_fbb, int32_t radius = 0,
                                        float bias = 0.0f, float alpha = 0.0f, float beta = 0.0f)
{
  LocalResponseNormalizationOptionsBuilder builder_(_fbb);
  builder_.add_beta(beta);
  builder_.add_alpha(alpha);
  builder_.add_bias(bias);
  builder_.add_radius(radius);
  return builder_.Finish();
}

flatbuffers::Offset<LocalResponseNormalizationOptions> CreateLocalResponseNormalizationOptions(
  flatbuffers::FlatBufferBuilder &_fbb, const LocalResponseNormalizationOptionsT *_o,
  const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LSTMOptionsT : public flatbuffers::NativeTable
{
  typedef LSTMOptions TableType;
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE;
  float cell_clip = 0.0f;
  float proj_clip = 0.0f;
  circle::LSTMKernelType kernel_type = circle::LSTMKernelType_FULL;
  bool asymmetric_quantize_inputs = false;
};

struct LSTMOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef LSTMOptionsT NativeTableType;
  typedef LSTMOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_CELL_CLIP = 6,
    VT_PROJ_CLIP = 8,
    VT_KERNEL_TYPE = 10,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 12
  };
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  float cell_clip() const { return GetField<float>(VT_CELL_CLIP, 0.0f); }
  float proj_clip() const { return GetField<float>(VT_PROJ_CLIP, 0.0f); }
  circle::LSTMKernelType kernel_type() const
  {
    return static_cast<circle::LSTMKernelType>(GetField<int8_t>(VT_KERNEL_TYPE, 0));
  }
  bool asymmetric_quantize_inputs() const
  {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<float>(verifier, VT_CELL_CLIP) &&
           VerifyField<float>(verifier, VT_PROJ_CLIP) &&
           VerifyField<int8_t>(verifier, VT_KERNEL_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) && verifier.EndTable();
  }
  LSTMOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LSTMOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LSTMOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSTMOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LSTMOptionsBuilder
{
  typedef LSTMOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(LSTMOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_cell_clip(float cell_clip)
  {
    fbb_.AddElement<float>(LSTMOptions::VT_CELL_CLIP, cell_clip, 0.0f);
  }
  void add_proj_clip(float proj_clip)
  {
    fbb_.AddElement<float>(LSTMOptions::VT_PROJ_CLIP, proj_clip, 0.0f);
  }
  void add_kernel_type(circle::LSTMKernelType kernel_type)
  {
    fbb_.AddElement<int8_t>(LSTMOptions::VT_KERNEL_TYPE, static_cast<int8_t>(kernel_type), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs)
  {
    fbb_.AddElement<uint8_t>(LSTMOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                             static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit LSTMOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LSTMOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LSTMOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LSTMOptions> CreateLSTMOptions(
  flatbuffers::FlatBufferBuilder &_fbb,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE,
  float cell_clip = 0.0f, float proj_clip = 0.0f,
  circle::LSTMKernelType kernel_type = circle::LSTMKernelType_FULL,
  bool asymmetric_quantize_inputs = false)
{
  LSTMOptionsBuilder builder_(_fbb);
  builder_.add_proj_clip(proj_clip);
  builder_.add_cell_clip(cell_clip);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_kernel_type(kernel_type);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<LSTMOptions>
CreateLSTMOptions(flatbuffers::FlatBufferBuilder &_fbb, const LSTMOptionsT *_o,
                  const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnidirectionalSequenceLSTMOptionsT : public flatbuffers::NativeTable
{
  typedef UnidirectionalSequenceLSTMOptions TableType;
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE;
  float cell_clip = 0.0f;
  float proj_clip = 0.0f;
  bool time_major = false;
  bool asymmetric_quantize_inputs = false;
};

struct UnidirectionalSequenceLSTMOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef UnidirectionalSequenceLSTMOptionsT NativeTableType;
  typedef UnidirectionalSequenceLSTMOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_CELL_CLIP = 6,
    VT_PROJ_CLIP = 8,
    VT_TIME_MAJOR = 10,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 12
  };
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  float cell_clip() const { return GetField<float>(VT_CELL_CLIP, 0.0f); }
  float proj_clip() const { return GetField<float>(VT_PROJ_CLIP, 0.0f); }
  bool time_major() const { return GetField<uint8_t>(VT_TIME_MAJOR, 0) != 0; }
  bool asymmetric_quantize_inputs() const
  {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<float>(verifier, VT_CELL_CLIP) &&
           VerifyField<float>(verifier, VT_PROJ_CLIP) &&
           VerifyField<uint8_t>(verifier, VT_TIME_MAJOR) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) && verifier.EndTable();
  }
  UnidirectionalSequenceLSTMOptionsT *
  UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnidirectionalSequenceLSTMOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UnidirectionalSequenceLSTMOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnidirectionalSequenceLSTMOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnidirectionalSequenceLSTMOptionsBuilder
{
  typedef UnidirectionalSequenceLSTMOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(UnidirectionalSequenceLSTMOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_cell_clip(float cell_clip)
  {
    fbb_.AddElement<float>(UnidirectionalSequenceLSTMOptions::VT_CELL_CLIP, cell_clip, 0.0f);
  }
  void add_proj_clip(float proj_clip)
  {
    fbb_.AddElement<float>(UnidirectionalSequenceLSTMOptions::VT_PROJ_CLIP, proj_clip, 0.0f);
  }
  void add_time_major(bool time_major)
  {
    fbb_.AddElement<uint8_t>(UnidirectionalSequenceLSTMOptions::VT_TIME_MAJOR,
                             static_cast<uint8_t>(time_major), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs)
  {
    fbb_.AddElement<uint8_t>(UnidirectionalSequenceLSTMOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                             static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit UnidirectionalSequenceLSTMOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
    : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnidirectionalSequenceLSTMOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnidirectionalSequenceLSTMOptions>
CreateUnidirectionalSequenceLSTMOptions(
  flatbuffers::FlatBufferBuilder &_fbb,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE,
  float cell_clip = 0.0f, float proj_clip = 0.0f, bool time_major = false,
  bool asymmetric_quantize_inputs = false)
{
  UnidirectionalSequenceLSTMOptionsBuilder builder_(_fbb);
  builder_.add_proj_clip(proj_clip);
  builder_.add_cell_clip(cell_clip);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_time_major(time_major);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> CreateUnidirectionalSequenceLSTMOptions(
  flatbuffers::FlatBufferBuilder &_fbb, const UnidirectionalSequenceLSTMOptionsT *_o,
  const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BidirectionalSequenceLSTMOptionsT : public flatbuffers::NativeTable
{
  typedef BidirectionalSequenceLSTMOptions TableType;
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE;
  float cell_clip = 0.0f;
  float proj_clip = 0.0f;
  bool merge_outputs = false;
  bool time_major = true;
  bool asymmetric_quantize_inputs = false;
};

struct BidirectionalSequenceLSTMOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef BidirectionalSequenceLSTMOptionsT NativeTableType;
  typedef BidirectionalSequenceLSTMOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_CELL_CLIP = 6,
    VT_PROJ_CLIP = 8,
    VT_MERGE_OUTPUTS = 10,
    VT_TIME_MAJOR = 12,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 14
  };
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  float cell_clip() const { return GetField<float>(VT_CELL_CLIP, 0.0f); }
  float proj_clip() const { return GetField<float>(VT_PROJ_CLIP, 0.0f); }
  bool merge_outputs() const { return GetField<uint8_t>(VT_MERGE_OUTPUTS, 0) != 0; }
  bool time_major() const { return GetField<uint8_t>(VT_TIME_MAJOR, 1) != 0; }
  bool asymmetric_quantize_inputs() const
  {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<float>(verifier, VT_CELL_CLIP) &&
           VerifyField<float>(verifier, VT_PROJ_CLIP) &&
           VerifyField<uint8_t>(verifier, VT_MERGE_OUTPUTS) &&
           VerifyField<uint8_t>(verifier, VT_TIME_MAJOR) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) && verifier.EndTable();
  }
  BidirectionalSequenceLSTMOptionsT *
  UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BidirectionalSequenceLSTMOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BidirectionalSequenceLSTMOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceLSTMOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BidirectionalSequenceLSTMOptionsBuilder
{
  typedef BidirectionalSequenceLSTMOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(BidirectionalSequenceLSTMOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_cell_clip(float cell_clip)
  {
    fbb_.AddElement<float>(BidirectionalSequenceLSTMOptions::VT_CELL_CLIP, cell_clip, 0.0f);
  }
  void add_proj_clip(float proj_clip)
  {
    fbb_.AddElement<float>(BidirectionalSequenceLSTMOptions::VT_PROJ_CLIP, proj_clip, 0.0f);
  }
  void add_merge_outputs(bool merge_outputs)
  {
    fbb_.AddElement<uint8_t>(BidirectionalSequenceLSTMOptions::VT_MERGE_OUTPUTS,
                             static_cast<uint8_t>(merge_outputs), 0);
  }
  void add_time_major(bool time_major)
  {
    fbb_.AddElement<uint8_t>(BidirectionalSequenceLSTMOptions::VT_TIME_MAJOR,
                             static_cast<uint8_t>(time_major), 1);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs)
  {
    fbb_.AddElement<uint8_t>(BidirectionalSequenceLSTMOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                             static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit BidirectionalSequenceLSTMOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
    : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BidirectionalSequenceLSTMOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BidirectionalSequenceLSTMOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BidirectionalSequenceLSTMOptions> CreateBidirectionalSequenceLSTMOptions(
  flatbuffers::FlatBufferBuilder &_fbb,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE,
  float cell_clip = 0.0f, float proj_clip = 0.0f, bool merge_outputs = false,
  bool time_major = true, bool asymmetric_quantize_inputs = false)
{
  BidirectionalSequenceLSTMOptionsBuilder builder_(_fbb);
  builder_.add_proj_clip(proj_clip);
  builder_.add_cell_clip(cell_clip);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_time_major(time_major);
  builder_.add_merge_outputs(merge_outputs);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<BidirectionalSequenceLSTMOptions>
CreateBidirectionalSequenceLSTMOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                       const BidirectionalSequenceLSTMOptionsT *_o,
                                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ResizeBilinearOptionsT : public flatbuffers::NativeTable
{
  typedef ResizeBilinearOptions TableType;
  bool align_corners = false;
  bool half_pixel_centers = false;
};

struct ResizeBilinearOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef ResizeBilinearOptionsT NativeTableType;
  typedef ResizeBilinearOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_ALIGN_CORNERS = 8,
    VT_HALF_PIXEL_CENTERS = 10
  };
  bool align_corners() const { return GetField<uint8_t>(VT_ALIGN_CORNERS, 0) != 0; }
  bool half_pixel_centers() const { return GetField<uint8_t>(VT_HALF_PIXEL_CENTERS, 0) != 0; }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_ALIGN_CORNERS) &&
           VerifyField<uint8_t>(verifier, VT_HALF_PIXEL_CENTERS) && verifier.EndTable();
  }
  ResizeBilinearOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ResizeBilinearOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ResizeBilinearOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResizeBilinearOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ResizeBilinearOptionsBuilder
{
  typedef ResizeBilinearOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_align_corners(bool align_corners)
  {
    fbb_.AddElement<uint8_t>(ResizeBilinearOptions::VT_ALIGN_CORNERS,
                             static_cast<uint8_t>(align_corners), 0);
  }
  void add_half_pixel_centers(bool half_pixel_centers)
  {
    fbb_.AddElement<uint8_t>(ResizeBilinearOptions::VT_HALF_PIXEL_CENTERS,
                             static_cast<uint8_t>(half_pixel_centers), 0);
  }
  explicit ResizeBilinearOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ResizeBilinearOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResizeBilinearOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResizeBilinearOptions>
CreateResizeBilinearOptions(flatbuffers::FlatBufferBuilder &_fbb, bool align_corners = false,
                            bool half_pixel_centers = false)
{
  ResizeBilinearOptionsBuilder builder_(_fbb);
  builder_.add_half_pixel_centers(half_pixel_centers);
  builder_.add_align_corners(align_corners);
  return builder_.Finish();
}

flatbuffers::Offset<ResizeBilinearOptions>
CreateResizeBilinearOptions(flatbuffers::FlatBufferBuilder &_fbb, const ResizeBilinearOptionsT *_o,
                            const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ResizeNearestNeighborOptionsT : public flatbuffers::NativeTable
{
  typedef ResizeNearestNeighborOptions TableType;
  bool align_corners = false;
  bool half_pixel_centers = false;
};

struct ResizeNearestNeighborOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef ResizeNearestNeighborOptionsT NativeTableType;
  typedef ResizeNearestNeighborOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_ALIGN_CORNERS = 4,
    VT_HALF_PIXEL_CENTERS = 6
  };
  bool align_corners() const { return GetField<uint8_t>(VT_ALIGN_CORNERS, 0) != 0; }
  bool half_pixel_centers() const { return GetField<uint8_t>(VT_HALF_PIXEL_CENTERS, 0) != 0; }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_ALIGN_CORNERS) &&
           VerifyField<uint8_t>(verifier, VT_HALF_PIXEL_CENTERS) && verifier.EndTable();
  }
  ResizeNearestNeighborOptionsT *
  UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ResizeNearestNeighborOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ResizeNearestNeighborOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResizeNearestNeighborOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ResizeNearestNeighborOptionsBuilder
{
  typedef ResizeNearestNeighborOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_align_corners(bool align_corners)
  {
    fbb_.AddElement<uint8_t>(ResizeNearestNeighborOptions::VT_ALIGN_CORNERS,
                             static_cast<uint8_t>(align_corners), 0);
  }
  void add_half_pixel_centers(bool half_pixel_centers)
  {
    fbb_.AddElement<uint8_t>(ResizeNearestNeighborOptions::VT_HALF_PIXEL_CENTERS,
                             static_cast<uint8_t>(half_pixel_centers), 0);
  }
  explicit ResizeNearestNeighborOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ResizeNearestNeighborOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResizeNearestNeighborOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResizeNearestNeighborOptions>
CreateResizeNearestNeighborOptions(flatbuffers::FlatBufferBuilder &_fbb, bool align_corners = false,
                                   bool half_pixel_centers = false)
{
  ResizeNearestNeighborOptionsBuilder builder_(_fbb);
  builder_.add_half_pixel_centers(half_pixel_centers);
  builder_.add_align_corners(align_corners);
  return builder_.Finish();
}

flatbuffers::Offset<ResizeNearestNeighborOptions>
CreateResizeNearestNeighborOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                   const ResizeNearestNeighborOptionsT *_o,
                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CallOptionsT : public flatbuffers::NativeTable
{
  typedef CallOptions TableType;
  uint32_t subgraph = 0;
};

struct CallOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef CallOptionsT NativeTableType;
  typedef CallOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_SUBGRAPH = 4
  };
  uint32_t subgraph() const { return GetField<uint32_t>(VT_SUBGRAPH, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<uint32_t>(verifier, VT_SUBGRAPH) &&
           verifier.EndTable();
  }
  CallOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CallOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CallOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const CallOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CallOptionsBuilder
{
  typedef CallOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_subgraph(uint32_t subgraph)
  {
    fbb_.AddElement<uint32_t>(CallOptions::VT_SUBGRAPH, subgraph, 0);
  }
  explicit CallOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CallOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CallOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<CallOptions> CreateCallOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                          uint32_t subgraph = 0)
{
  CallOptionsBuilder builder_(_fbb);
  builder_.add_subgraph(subgraph);
  return builder_.Finish();
}

flatbuffers::Offset<CallOptions>
CreateCallOptions(flatbuffers::FlatBufferBuilder &_fbb, const CallOptionsT *_o,
                  const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PadOptionsT : public flatbuffers::NativeTable
{
  typedef PadOptions TableType;
};

struct PadOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef PadOptionsT NativeTableType;
  typedef PadOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  PadOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PadOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PadOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const PadOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PadOptionsBuilder
{
  typedef PadOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PadOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PadOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PadOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<PadOptions> CreatePadOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  PadOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<PadOptions>
CreatePadOptions(flatbuffers::FlatBufferBuilder &_fbb, const PadOptionsT *_o,
                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PadV2OptionsT : public flatbuffers::NativeTable
{
  typedef PadV2Options TableType;
};

struct PadV2Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef PadV2OptionsT NativeTableType;
  typedef PadV2OptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  PadV2OptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PadV2OptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PadV2Options>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const PadV2OptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PadV2OptionsBuilder
{
  typedef PadV2Options Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PadV2OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PadV2Options> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PadV2Options>(end);
    return o;
  }
};

inline flatbuffers::Offset<PadV2Options> CreatePadV2Options(flatbuffers::FlatBufferBuilder &_fbb)
{
  PadV2OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<PadV2Options>
CreatePadV2Options(flatbuffers::FlatBufferBuilder &_fbb, const PadV2OptionsT *_o,
                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReshapeOptionsT : public flatbuffers::NativeTable
{
  typedef ReshapeOptions TableType;
  std::vector<int32_t> new_shape{};
};

struct ReshapeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef ReshapeOptionsT NativeTableType;
  typedef ReshapeOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_NEW_SHAPE = 4
  };
  const flatbuffers::Vector<int32_t> *new_shape() const
  {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_NEW_SHAPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_NEW_SHAPE) &&
           verifier.VerifyVector(new_shape()) && verifier.EndTable();
  }
  ReshapeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReshapeOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReshapeOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReshapeOptionsBuilder
{
  typedef ReshapeOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_new_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> new_shape)
  {
    fbb_.AddOffset(ReshapeOptions::VT_NEW_SHAPE, new_shape);
  }
  explicit ReshapeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ReshapeOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReshapeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReshapeOptions>
CreateReshapeOptions(flatbuffers::FlatBufferBuilder &_fbb,
                     flatbuffers::Offset<flatbuffers::Vector<int32_t>> new_shape = 0)
{
  ReshapeOptionsBuilder builder_(_fbb);
  builder_.add_new_shape(new_shape);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReshapeOptions>
CreateReshapeOptionsDirect(flatbuffers::FlatBufferBuilder &_fbb,
                           const std::vector<int32_t> *new_shape = nullptr)
{
  auto new_shape__ = new_shape ? _fbb.CreateVector<int32_t>(*new_shape) : 0;
  return circle::CreateReshapeOptions(_fbb, new_shape__);
}

flatbuffers::Offset<ReshapeOptions>
CreateReshapeOptions(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeOptionsT *_o,
                     const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SpaceToBatchNDOptionsT : public flatbuffers::NativeTable
{
  typedef SpaceToBatchNDOptions TableType;
};

struct SpaceToBatchNDOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef SpaceToBatchNDOptionsT NativeTableType;
  typedef SpaceToBatchNDOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  SpaceToBatchNDOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SpaceToBatchNDOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SpaceToBatchNDOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SpaceToBatchNDOptionsBuilder
{
  typedef SpaceToBatchNDOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SpaceToBatchNDOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SpaceToBatchNDOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpaceToBatchNDOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpaceToBatchNDOptions>
CreateSpaceToBatchNDOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  SpaceToBatchNDOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SpaceToBatchNDOptions>
CreateSpaceToBatchNDOptions(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDOptionsT *_o,
                            const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BatchToSpaceNDOptionsT : public flatbuffers::NativeTable
{
  typedef BatchToSpaceNDOptions TableType;
};

struct BatchToSpaceNDOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef BatchToSpaceNDOptionsT NativeTableType;
  typedef BatchToSpaceNDOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  BatchToSpaceNDOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BatchToSpaceNDOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BatchToSpaceNDOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BatchToSpaceNDOptionsBuilder
{
  typedef BatchToSpaceNDOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BatchToSpaceNDOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BatchToSpaceNDOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchToSpaceNDOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchToSpaceNDOptions>
CreateBatchToSpaceNDOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  BatchToSpaceNDOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<BatchToSpaceNDOptions>
CreateBatchToSpaceNDOptions(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDOptionsT *_o,
                            const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SkipGramOptionsT : public flatbuffers::NativeTable
{
  typedef SkipGramOptions TableType;
  int32_t ngram_size = 0;
  int32_t max_skip_size = 0;
  bool include_all_ngrams = false;
};

struct SkipGramOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef SkipGramOptionsT NativeTableType;
  typedef SkipGramOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_NGRAM_SIZE = 4,
    VT_MAX_SKIP_SIZE = 6,
    VT_INCLUDE_ALL_NGRAMS = 8
  };
  int32_t ngram_size() const { return GetField<int32_t>(VT_NGRAM_SIZE, 0); }
  int32_t max_skip_size() const { return GetField<int32_t>(VT_MAX_SKIP_SIZE, 0); }
  bool include_all_ngrams() const { return GetField<uint8_t>(VT_INCLUDE_ALL_NGRAMS, 0) != 0; }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_NGRAM_SIZE) &&
           VerifyField<int32_t>(verifier, VT_MAX_SKIP_SIZE) &&
           VerifyField<uint8_t>(verifier, VT_INCLUDE_ALL_NGRAMS) && verifier.EndTable();
  }
  SkipGramOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SkipGramOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SkipGramOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const SkipGramOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SkipGramOptionsBuilder
{
  typedef SkipGramOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ngram_size(int32_t ngram_size)
  {
    fbb_.AddElement<int32_t>(SkipGramOptions::VT_NGRAM_SIZE, ngram_size, 0);
  }
  void add_max_skip_size(int32_t max_skip_size)
  {
    fbb_.AddElement<int32_t>(SkipGramOptions::VT_MAX_SKIP_SIZE, max_skip_size, 0);
  }
  void add_include_all_ngrams(bool include_all_ngrams)
  {
    fbb_.AddElement<uint8_t>(SkipGramOptions::VT_INCLUDE_ALL_NGRAMS,
                             static_cast<uint8_t>(include_all_ngrams), 0);
  }
  explicit SkipGramOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SkipGramOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SkipGramOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SkipGramOptions>
CreateSkipGramOptions(flatbuffers::FlatBufferBuilder &_fbb, int32_t ngram_size = 0,
                      int32_t max_skip_size = 0, bool include_all_ngrams = false)
{
  SkipGramOptionsBuilder builder_(_fbb);
  builder_.add_max_skip_size(max_skip_size);
  builder_.add_ngram_size(ngram_size);
  builder_.add_include_all_ngrams(include_all_ngrams);
  return builder_.Finish();
}

flatbuffers::Offset<SkipGramOptions>
CreateSkipGramOptions(flatbuffers::FlatBufferBuilder &_fbb, const SkipGramOptionsT *_o,
                      const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SpaceToDepthOptionsT : public flatbuffers::NativeTable
{
  typedef SpaceToDepthOptions TableType;
  int32_t block_size = 0;
};

struct SpaceToDepthOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef SpaceToDepthOptionsT NativeTableType;
  typedef SpaceToDepthOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_BLOCK_SIZE = 4
  };
  int32_t block_size() const { return GetField<int32_t>(VT_BLOCK_SIZE, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_BLOCK_SIZE) &&
           verifier.EndTable();
  }
  SpaceToDepthOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SpaceToDepthOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SpaceToDepthOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SpaceToDepthOptionsBuilder
{
  typedef SpaceToDepthOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_block_size(int32_t block_size)
  {
    fbb_.AddElement<int32_t>(SpaceToDepthOptions::VT_BLOCK_SIZE, block_size, 0);
  }
  explicit SpaceToDepthOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SpaceToDepthOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpaceToDepthOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpaceToDepthOptions>
CreateSpaceToDepthOptions(flatbuffers::FlatBufferBuilder &_fbb, int32_t block_size = 0)
{
  SpaceToDepthOptionsBuilder builder_(_fbb);
  builder_.add_block_size(block_size);
  return builder_.Finish();
}

flatbuffers::Offset<SpaceToDepthOptions>
CreateSpaceToDepthOptions(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthOptionsT *_o,
                          const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DepthToSpaceOptionsT : public flatbuffers::NativeTable
{
  typedef DepthToSpaceOptions TableType;
  int32_t block_size = 0;
};

struct DepthToSpaceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef DepthToSpaceOptionsT NativeTableType;
  typedef DepthToSpaceOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_BLOCK_SIZE = 4
  };
  int32_t block_size() const { return GetField<int32_t>(VT_BLOCK_SIZE, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_BLOCK_SIZE) &&
           verifier.EndTable();
  }
  DepthToSpaceOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DepthToSpaceOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DepthToSpaceOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const DepthToSpaceOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DepthToSpaceOptionsBuilder
{
  typedef DepthToSpaceOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_block_size(int32_t block_size)
  {
    fbb_.AddElement<int32_t>(DepthToSpaceOptions::VT_BLOCK_SIZE, block_size, 0);
  }
  explicit DepthToSpaceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DepthToSpaceOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DepthToSpaceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<DepthToSpaceOptions>
CreateDepthToSpaceOptions(flatbuffers::FlatBufferBuilder &_fbb, int32_t block_size = 0)
{
  DepthToSpaceOptionsBuilder builder_(_fbb);
  builder_.add_block_size(block_size);
  return builder_.Finish();
}

flatbuffers::Offset<DepthToSpaceOptions>
CreateDepthToSpaceOptions(flatbuffers::FlatBufferBuilder &_fbb, const DepthToSpaceOptionsT *_o,
                          const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SubOptionsT : public flatbuffers::NativeTable
{
  typedef SubOptions TableType;
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE;
  bool pot_scale_int16 = true;
};

struct SubOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef SubOptionsT NativeTableType;
  typedef SubOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_POT_SCALE_INT16 = 6
  };
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool pot_scale_int16() const { return GetField<uint8_t>(VT_POT_SCALE_INT16, 1) != 0; }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<uint8_t>(verifier, VT_POT_SCALE_INT16) && verifier.EndTable();
  }
  SubOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SubOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SubOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SubOptionsBuilder
{
  typedef SubOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(SubOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_pot_scale_int16(bool pot_scale_int16)
  {
    fbb_.AddElement<uint8_t>(SubOptions::VT_POT_SCALE_INT16, static_cast<uint8_t>(pot_scale_int16),
                             1);
  }
  explicit SubOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SubOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SubOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SubOptions> CreateSubOptions(
  flatbuffers::FlatBufferBuilder &_fbb,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE,
  bool pot_scale_int16 = true)
{
  SubOptionsBuilder builder_(_fbb);
  builder_.add_pot_scale_int16(pot_scale_int16);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<SubOptions>
CreateSubOptions(flatbuffers::FlatBufferBuilder &_fbb, const SubOptionsT *_o,
                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DivOptionsT : public flatbuffers::NativeTable
{
  typedef DivOptions TableType;
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE;
};

struct DivOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef DivOptionsT NativeTableType;
  typedef DivOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_FUSED_ACTIVATION_FUNCTION = 4
  };
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) && verifier.EndTable();
  }
  DivOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DivOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DivOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const DivOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DivOptionsBuilder
{
  typedef DivOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(DivOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit DivOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DivOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DivOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<DivOptions> CreateDivOptions(
  flatbuffers::FlatBufferBuilder &_fbb,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE)
{
  DivOptionsBuilder builder_(_fbb);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<DivOptions>
CreateDivOptions(flatbuffers::FlatBufferBuilder &_fbb, const DivOptionsT *_o,
                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TopKV2OptionsT : public flatbuffers::NativeTable
{
  typedef TopKV2Options TableType;
};

struct TopKV2Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef TopKV2OptionsT NativeTableType;
  typedef TopKV2OptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  TopKV2OptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TopKV2OptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TopKV2Options>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const TopKV2OptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TopKV2OptionsBuilder
{
  typedef TopKV2Options Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TopKV2OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TopKV2Options> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TopKV2Options>(end);
    return o;
  }
};

inline flatbuffers::Offset<TopKV2Options> CreateTopKV2Options(flatbuffers::FlatBufferBuilder &_fbb)
{
  TopKV2OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<TopKV2Options>
CreateTopKV2Options(flatbuffers::FlatBufferBuilder &_fbb, const TopKV2OptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EmbeddingLookupSparseOptionsT : public flatbuffers::NativeTable
{
  typedef EmbeddingLookupSparseOptions TableType;
  circle::CombinerType combiner = circle::CombinerType_SUM;
};

struct EmbeddingLookupSparseOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef EmbeddingLookupSparseOptionsT NativeTableType;
  typedef EmbeddingLookupSparseOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_COMBINER = 4
  };
  circle::CombinerType combiner() const
  {
    return static_cast<circle::CombinerType>(GetField<int8_t>(VT_COMBINER, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_COMBINER) &&
           verifier.EndTable();
  }
  EmbeddingLookupSparseOptionsT *
  UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EmbeddingLookupSparseOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EmbeddingLookupSparseOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupSparseOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EmbeddingLookupSparseOptionsBuilder
{
  typedef EmbeddingLookupSparseOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_combiner(circle::CombinerType combiner)
  {
    fbb_.AddElement<int8_t>(EmbeddingLookupSparseOptions::VT_COMBINER,
                            static_cast<int8_t>(combiner), 0);
  }
  explicit EmbeddingLookupSparseOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<EmbeddingLookupSparseOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EmbeddingLookupSparseOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<EmbeddingLookupSparseOptions>
CreateEmbeddingLookupSparseOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                   circle::CombinerType combiner = circle::CombinerType_SUM)
{
  EmbeddingLookupSparseOptionsBuilder builder_(_fbb);
  builder_.add_combiner(combiner);
  return builder_.Finish();
}

flatbuffers::Offset<EmbeddingLookupSparseOptions>
CreateEmbeddingLookupSparseOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                   const EmbeddingLookupSparseOptionsT *_o,
                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GatherOptionsT : public flatbuffers::NativeTable
{
  typedef GatherOptions TableType;
  int32_t axis = 0;
  int32_t batch_dims = 0;
};

struct GatherOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef GatherOptionsT NativeTableType;
  typedef GatherOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_AXIS = 4,
    VT_BATCH_DIMS = 6
  };
  int32_t axis() const { return GetField<int32_t>(VT_AXIS, 0); }
  int32_t batch_dims() const { return GetField<int32_t>(VT_BATCH_DIMS, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyField<int32_t>(verifier, VT_BATCH_DIMS) && verifier.EndTable();
  }
  GatherOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GatherOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GatherOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GatherOptionsBuilder
{
  typedef GatherOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) { fbb_.AddElement<int32_t>(GatherOptions::VT_AXIS, axis, 0); }
  void add_batch_dims(int32_t batch_dims)
  {
    fbb_.AddElement<int32_t>(GatherOptions::VT_BATCH_DIMS, batch_dims, 0);
  }
  explicit GatherOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GatherOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GatherOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<GatherOptions>
CreateGatherOptions(flatbuffers::FlatBufferBuilder &_fbb, int32_t axis = 0, int32_t batch_dims = 0)
{
  GatherOptionsBuilder builder_(_fbb);
  builder_.add_batch_dims(batch_dims);
  builder_.add_axis(axis);
  return builder_.Finish();
}

flatbuffers::Offset<GatherOptions>
CreateGatherOptions(flatbuffers::FlatBufferBuilder &_fbb, const GatherOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TransposeOptionsT : public flatbuffers::NativeTable
{
  typedef TransposeOptions TableType;
};

struct TransposeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef TransposeOptionsT NativeTableType;
  typedef TransposeOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  TransposeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TransposeOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TransposeOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransposeOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TransposeOptionsBuilder
{
  typedef TransposeOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TransposeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TransposeOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TransposeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<TransposeOptions>
CreateTransposeOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  TransposeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<TransposeOptions>
CreateTransposeOptions(flatbuffers::FlatBufferBuilder &_fbb, const TransposeOptionsT *_o,
                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExpOptionsT : public flatbuffers::NativeTable
{
  typedef ExpOptions TableType;
};

struct ExpOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef ExpOptionsT NativeTableType;
  typedef ExpOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  ExpOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExpOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ExpOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExpOptionsBuilder
{
  typedef ExpOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ExpOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ExpOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExpOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExpOptions> CreateExpOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  ExpOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ExpOptions>
CreateExpOptions(flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionsT *_o,
                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CosOptionsT : public flatbuffers::NativeTable
{
  typedef CosOptions TableType;
};

struct CosOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef CosOptionsT NativeTableType;
  typedef CosOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  CosOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CosOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CosOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const CosOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CosOptionsBuilder
{
  typedef CosOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit CosOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CosOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CosOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<CosOptions> CreateCosOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  CosOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<CosOptions>
CreateCosOptions(flatbuffers::FlatBufferBuilder &_fbb, const CosOptionsT *_o,
                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReducerOptionsT : public flatbuffers::NativeTable
{
  typedef ReducerOptions TableType;
  bool keep_dims = false;
};

struct ReducerOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef ReducerOptionsT NativeTableType;
  typedef ReducerOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_KEEP_DIMS = 4
  };
  bool keep_dims() const { return GetField<uint8_t>(VT_KEEP_DIMS, 0) != 0; }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_KEEP_DIMS) &&
           verifier.EndTable();
  }
  ReducerOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReducerOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReducerOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReducerOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReducerOptionsBuilder
{
  typedef ReducerOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_keep_dims(bool keep_dims)
  {
    fbb_.AddElement<uint8_t>(ReducerOptions::VT_KEEP_DIMS, static_cast<uint8_t>(keep_dims), 0);
  }
  explicit ReducerOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ReducerOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReducerOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReducerOptions>
CreateReducerOptions(flatbuffers::FlatBufferBuilder &_fbb, bool keep_dims = false)
{
  ReducerOptionsBuilder builder_(_fbb);
  builder_.add_keep_dims(keep_dims);
  return builder_.Finish();
}

flatbuffers::Offset<ReducerOptions>
CreateReducerOptions(flatbuffers::FlatBufferBuilder &_fbb, const ReducerOptionsT *_o,
                     const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SqueezeOptionsT : public flatbuffers::NativeTable
{
  typedef SqueezeOptions TableType;
  std::vector<int32_t> squeeze_dims{};
};

struct SqueezeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef SqueezeOptionsT NativeTableType;
  typedef SqueezeOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_SQUEEZE_DIMS = 4
  };
  const flatbuffers::Vector<int32_t> *squeeze_dims() const
  {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SQUEEZE_DIMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_SQUEEZE_DIMS) &&
           verifier.VerifyVector(squeeze_dims()) && verifier.EndTable();
  }
  SqueezeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SqueezeOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SqueezeOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SqueezeOptionsBuilder
{
  typedef SqueezeOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_squeeze_dims(flatbuffers::Offset<flatbuffers::Vector<int32_t>> squeeze_dims)
  {
    fbb_.AddOffset(SqueezeOptions::VT_SQUEEZE_DIMS, squeeze_dims);
  }
  explicit SqueezeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SqueezeOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SqueezeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SqueezeOptions>
CreateSqueezeOptions(flatbuffers::FlatBufferBuilder &_fbb,
                     flatbuffers::Offset<flatbuffers::Vector<int32_t>> squeeze_dims = 0)
{
  SqueezeOptionsBuilder builder_(_fbb);
  builder_.add_squeeze_dims(squeeze_dims);
  return builder_.Finish();
}

inline flatbuffers::Offset<SqueezeOptions>
CreateSqueezeOptionsDirect(flatbuffers::FlatBufferBuilder &_fbb,
                           const std::vector<int32_t> *squeeze_dims = nullptr)
{
  auto squeeze_dims__ = squeeze_dims ? _fbb.CreateVector<int32_t>(*squeeze_dims) : 0;
  return circle::CreateSqueezeOptions(_fbb, squeeze_dims__);
}

flatbuffers::Offset<SqueezeOptions>
CreateSqueezeOptions(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeOptionsT *_o,
                     const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SplitOptionsT : public flatbuffers::NativeTable
{
  typedef SplitOptions TableType;
  int32_t num_splits = 0;
};

struct SplitOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef SplitOptionsT NativeTableType;
  typedef SplitOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_NUM_SPLITS = 4
  };
  int32_t num_splits() const { return GetField<int32_t>(VT_NUM_SPLITS, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_NUM_SPLITS) &&
           verifier.EndTable();
  }
  SplitOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SplitOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SplitOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const SplitOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SplitOptionsBuilder
{
  typedef SplitOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_splits(int32_t num_splits)
  {
    fbb_.AddElement<int32_t>(SplitOptions::VT_NUM_SPLITS, num_splits, 0);
  }
  explicit SplitOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SplitOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SplitOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SplitOptions> CreateSplitOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                            int32_t num_splits = 0)
{
  SplitOptionsBuilder builder_(_fbb);
  builder_.add_num_splits(num_splits);
  return builder_.Finish();
}

flatbuffers::Offset<SplitOptions>
CreateSplitOptions(flatbuffers::FlatBufferBuilder &_fbb, const SplitOptionsT *_o,
                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SplitVOptionsT : public flatbuffers::NativeTable
{
  typedef SplitVOptions TableType;
  int32_t num_splits = 0;
};

struct SplitVOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef SplitVOptionsT NativeTableType;
  typedef SplitVOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_NUM_SPLITS = 4
  };
  int32_t num_splits() const { return GetField<int32_t>(VT_NUM_SPLITS, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_NUM_SPLITS) &&
           verifier.EndTable();
  }
  SplitVOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SplitVOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SplitVOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const SplitVOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SplitVOptionsBuilder
{
  typedef SplitVOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_splits(int32_t num_splits)
  {
    fbb_.AddElement<int32_t>(SplitVOptions::VT_NUM_SPLITS, num_splits, 0);
  }
  explicit SplitVOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SplitVOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SplitVOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SplitVOptions> CreateSplitVOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                              int32_t num_splits = 0)
{
  SplitVOptionsBuilder builder_(_fbb);
  builder_.add_num_splits(num_splits);
  return builder_.Finish();
}

flatbuffers::Offset<SplitVOptions>
CreateSplitVOptions(flatbuffers::FlatBufferBuilder &_fbb, const SplitVOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StridedSliceOptionsT : public flatbuffers::NativeTable
{
  typedef StridedSliceOptions TableType;
  int32_t begin_mask = 0;
  int32_t end_mask = 0;
  int32_t ellipsis_mask = 0;
  int32_t new_axis_mask = 0;
  int32_t shrink_axis_mask = 0;
};

struct StridedSliceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef StridedSliceOptionsT NativeTableType;
  typedef StridedSliceOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_BEGIN_MASK = 4,
    VT_END_MASK = 6,
    VT_ELLIPSIS_MASK = 8,
    VT_NEW_AXIS_MASK = 10,
    VT_SHRINK_AXIS_MASK = 12
  };
  int32_t begin_mask() const { return GetField<int32_t>(VT_BEGIN_MASK, 0); }
  int32_t end_mask() const { return GetField<int32_t>(VT_END_MASK, 0); }
  int32_t ellipsis_mask() const { return GetField<int32_t>(VT_ELLIPSIS_MASK, 0); }
  int32_t new_axis_mask() const { return GetField<int32_t>(VT_NEW_AXIS_MASK, 0); }
  int32_t shrink_axis_mask() const { return GetField<int32_t>(VT_SHRINK_AXIS_MASK, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_BEGIN_MASK) &&
           VerifyField<int32_t>(verifier, VT_END_MASK) &&
           VerifyField<int32_t>(verifier, VT_ELLIPSIS_MASK) &&
           VerifyField<int32_t>(verifier, VT_NEW_AXIS_MASK) &&
           VerifyField<int32_t>(verifier, VT_SHRINK_AXIS_MASK) && verifier.EndTable();
  }
  StridedSliceOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StridedSliceOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StridedSliceOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StridedSliceOptionsBuilder
{
  typedef StridedSliceOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_begin_mask(int32_t begin_mask)
  {
    fbb_.AddElement<int32_t>(StridedSliceOptions::VT_BEGIN_MASK, begin_mask, 0);
  }
  void add_end_mask(int32_t end_mask)
  {
    fbb_.AddElement<int32_t>(StridedSliceOptions::VT_END_MASK, end_mask, 0);
  }
  void add_ellipsis_mask(int32_t ellipsis_mask)
  {
    fbb_.AddElement<int32_t>(StridedSliceOptions::VT_ELLIPSIS_MASK, ellipsis_mask, 0);
  }
  void add_new_axis_mask(int32_t new_axis_mask)
  {
    fbb_.AddElement<int32_t>(StridedSliceOptions::VT_NEW_AXIS_MASK, new_axis_mask, 0);
  }
  void add_shrink_axis_mask(int32_t shrink_axis_mask)
  {
    fbb_.AddElement<int32_t>(StridedSliceOptions::VT_SHRINK_AXIS_MASK, shrink_axis_mask, 0);
  }
  explicit StridedSliceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StridedSliceOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StridedSliceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<StridedSliceOptions>
CreateStridedSliceOptions(flatbuffers::FlatBufferBuilder &_fbb, int32_t begin_mask = 0,
                          int32_t end_mask = 0, int32_t ellipsis_mask = 0,
                          int32_t new_axis_mask = 0, int32_t shrink_axis_mask = 0)
{
  StridedSliceOptionsBuilder builder_(_fbb);
  builder_.add_shrink_axis_mask(shrink_axis_mask);
  builder_.add_new_axis_mask(new_axis_mask);
  builder_.add_ellipsis_mask(ellipsis_mask);
  builder_.add_end_mask(end_mask);
  builder_.add_begin_mask(begin_mask);
  return builder_.Finish();
}

flatbuffers::Offset<StridedSliceOptions>
CreateStridedSliceOptions(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceOptionsT *_o,
                          const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogSoftmaxOptionsT : public flatbuffers::NativeTable
{
  typedef LogSoftmaxOptions TableType;
};

struct LogSoftmaxOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef LogSoftmaxOptionsT NativeTableType;
  typedef LogSoftmaxOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  LogSoftmaxOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogSoftmaxOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LogSoftmaxOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogSoftmaxOptionsBuilder
{
  typedef LogSoftmaxOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogSoftmaxOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LogSoftmaxOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogSoftmaxOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogSoftmaxOptions>
CreateLogSoftmaxOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  LogSoftmaxOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LogSoftmaxOptions>
CreateLogSoftmaxOptions(flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxOptionsT *_o,
                        const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CastOptionsT : public flatbuffers::NativeTable
{
  typedef CastOptions TableType;
  circle::TensorType in_data_type = circle::TensorType_FLOAT32;
  circle::TensorType out_data_type = circle::TensorType_FLOAT32;
};

struct CastOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef CastOptionsT NativeTableType;
  typedef CastOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_IN_DATA_TYPE = 4,
    VT_OUT_DATA_TYPE = 6
  };
  circle::TensorType in_data_type() const
  {
    return static_cast<circle::TensorType>(GetField<int8_t>(VT_IN_DATA_TYPE, 0));
  }
  circle::TensorType out_data_type() const
  {
    return static_cast<circle::TensorType>(GetField<int8_t>(VT_OUT_DATA_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_IN_DATA_TYPE) &&
           VerifyField<int8_t>(verifier, VT_OUT_DATA_TYPE) && verifier.EndTable();
  }
  CastOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CastOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CastOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const CastOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CastOptionsBuilder
{
  typedef CastOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_in_data_type(circle::TensorType in_data_type)
  {
    fbb_.AddElement<int8_t>(CastOptions::VT_IN_DATA_TYPE, static_cast<int8_t>(in_data_type), 0);
  }
  void add_out_data_type(circle::TensorType out_data_type)
  {
    fbb_.AddElement<int8_t>(CastOptions::VT_OUT_DATA_TYPE, static_cast<int8_t>(out_data_type), 0);
  }
  explicit CastOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CastOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CastOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<CastOptions>
CreateCastOptions(flatbuffers::FlatBufferBuilder &_fbb,
                  circle::TensorType in_data_type = circle::TensorType_FLOAT32,
                  circle::TensorType out_data_type = circle::TensorType_FLOAT32)
{
  CastOptionsBuilder builder_(_fbb);
  builder_.add_out_data_type(out_data_type);
  builder_.add_in_data_type(in_data_type);
  return builder_.Finish();
}

flatbuffers::Offset<CastOptions>
CreateCastOptions(flatbuffers::FlatBufferBuilder &_fbb, const CastOptionsT *_o,
                  const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DequantizeOptionsT : public flatbuffers::NativeTable
{
  typedef DequantizeOptions TableType;
};

struct DequantizeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef DequantizeOptionsT NativeTableType;
  typedef DequantizeOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  DequantizeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DequantizeOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DequantizeOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const DequantizeOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DequantizeOptionsBuilder
{
  typedef DequantizeOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DequantizeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DequantizeOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DequantizeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<DequantizeOptions>
CreateDequantizeOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  DequantizeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<DequantizeOptions>
CreateDequantizeOptions(flatbuffers::FlatBufferBuilder &_fbb, const DequantizeOptionsT *_o,
                        const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MaximumMinimumOptionsT : public flatbuffers::NativeTable
{
  typedef MaximumMinimumOptions TableType;
};

struct MaximumMinimumOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef MaximumMinimumOptionsT NativeTableType;
  typedef MaximumMinimumOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  MaximumMinimumOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MaximumMinimumOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MaximumMinimumOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const MaximumMinimumOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MaximumMinimumOptionsBuilder
{
  typedef MaximumMinimumOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MaximumMinimumOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MaximumMinimumOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MaximumMinimumOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<MaximumMinimumOptions>
CreateMaximumMinimumOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  MaximumMinimumOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<MaximumMinimumOptions>
CreateMaximumMinimumOptions(flatbuffers::FlatBufferBuilder &_fbb, const MaximumMinimumOptionsT *_o,
                            const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TileOptionsT : public flatbuffers::NativeTable
{
  typedef TileOptions TableType;
};

struct TileOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef TileOptionsT NativeTableType;
  typedef TileOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  TileOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TileOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TileOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const TileOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TileOptionsBuilder
{
  typedef TileOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TileOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TileOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TileOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<TileOptions> CreateTileOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  TileOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<TileOptions>
CreateTileOptions(flatbuffers::FlatBufferBuilder &_fbb, const TileOptionsT *_o,
                  const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ArgMaxOptionsT : public flatbuffers::NativeTable
{
  typedef ArgMaxOptions TableType;
  circle::TensorType output_type = circle::TensorType_FLOAT32;
};

struct ArgMaxOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef ArgMaxOptionsT NativeTableType;
  typedef ArgMaxOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_OUTPUT_TYPE = 4
  };
  circle::TensorType output_type() const
  {
    return static_cast<circle::TensorType>(GetField<int8_t>(VT_OUTPUT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_OUTPUT_TYPE) &&
           verifier.EndTable();
  }
  ArgMaxOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ArgMaxOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ArgMaxOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ArgMaxOptionsBuilder
{
  typedef ArgMaxOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_output_type(circle::TensorType output_type)
  {
    fbb_.AddElement<int8_t>(ArgMaxOptions::VT_OUTPUT_TYPE, static_cast<int8_t>(output_type), 0);
  }
  explicit ArgMaxOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ArgMaxOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArgMaxOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArgMaxOptions>
CreateArgMaxOptions(flatbuffers::FlatBufferBuilder &_fbb,
                    circle::TensorType output_type = circle::TensorType_FLOAT32)
{
  ArgMaxOptionsBuilder builder_(_fbb);
  builder_.add_output_type(output_type);
  return builder_.Finish();
}

flatbuffers::Offset<ArgMaxOptions>
CreateArgMaxOptions(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ArgMinOptionsT : public flatbuffers::NativeTable
{
  typedef ArgMinOptions TableType;
  circle::TensorType output_type = circle::TensorType_FLOAT32;
};

struct ArgMinOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef ArgMinOptionsT NativeTableType;
  typedef ArgMinOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_OUTPUT_TYPE = 4
  };
  circle::TensorType output_type() const
  {
    return static_cast<circle::TensorType>(GetField<int8_t>(VT_OUTPUT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_OUTPUT_TYPE) &&
           verifier.EndTable();
  }
  ArgMinOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ArgMinOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ArgMinOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMinOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ArgMinOptionsBuilder
{
  typedef ArgMinOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_output_type(circle::TensorType output_type)
  {
    fbb_.AddElement<int8_t>(ArgMinOptions::VT_OUTPUT_TYPE, static_cast<int8_t>(output_type), 0);
  }
  explicit ArgMinOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ArgMinOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArgMinOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArgMinOptions>
CreateArgMinOptions(flatbuffers::FlatBufferBuilder &_fbb,
                    circle::TensorType output_type = circle::TensorType_FLOAT32)
{
  ArgMinOptionsBuilder builder_(_fbb);
  builder_.add_output_type(output_type);
  return builder_.Finish();
}

flatbuffers::Offset<ArgMinOptions>
CreateArgMinOptions(flatbuffers::FlatBufferBuilder &_fbb, const ArgMinOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GreaterOptionsT : public flatbuffers::NativeTable
{
  typedef GreaterOptions TableType;
};

struct GreaterOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef GreaterOptionsT NativeTableType;
  typedef GreaterOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  GreaterOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GreaterOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GreaterOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GreaterOptionsBuilder
{
  typedef GreaterOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GreaterOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GreaterOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GreaterOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<GreaterOptions>
CreateGreaterOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  GreaterOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<GreaterOptions>
CreateGreaterOptions(flatbuffers::FlatBufferBuilder &_fbb, const GreaterOptionsT *_o,
                     const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GreaterEqualOptionsT : public flatbuffers::NativeTable
{
  typedef GreaterEqualOptions TableType;
};

struct GreaterEqualOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef GreaterEqualOptionsT NativeTableType;
  typedef GreaterEqualOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  GreaterEqualOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GreaterEqualOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GreaterEqualOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GreaterEqualOptionsBuilder
{
  typedef GreaterEqualOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GreaterEqualOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GreaterEqualOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GreaterEqualOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<GreaterEqualOptions>
CreateGreaterEqualOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  GreaterEqualOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<GreaterEqualOptions>
CreateGreaterEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionsT *_o,
                          const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LessOptionsT : public flatbuffers::NativeTable
{
  typedef LessOptions TableType;
};

struct LessOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef LessOptionsT NativeTableType;
  typedef LessOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  LessOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LessOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LessOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LessOptionsBuilder
{
  typedef LessOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LessOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LessOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LessOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LessOptions> CreateLessOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  LessOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LessOptions>
CreateLessOptions(flatbuffers::FlatBufferBuilder &_fbb, const LessOptionsT *_o,
                  const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LessEqualOptionsT : public flatbuffers::NativeTable
{
  typedef LessEqualOptions TableType;
};

struct LessEqualOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef LessEqualOptionsT NativeTableType;
  typedef LessEqualOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  LessEqualOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LessEqualOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LessEqualOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LessEqualOptionsBuilder
{
  typedef LessEqualOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LessEqualOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LessEqualOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LessEqualOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LessEqualOptions>
CreateLessEqualOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  LessEqualOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LessEqualOptions>
CreateLessEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualOptionsT *_o,
                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NegOptionsT : public flatbuffers::NativeTable
{
  typedef NegOptions TableType;
};

struct NegOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef NegOptionsT NativeTableType;
  typedef NegOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  NegOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NegOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NegOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const NegOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NegOptionsBuilder
{
  typedef NegOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NegOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NegOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NegOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<NegOptions> CreateNegOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  NegOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<NegOptions>
CreateNegOptions(flatbuffers::FlatBufferBuilder &_fbb, const NegOptionsT *_o,
                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SelectOptionsT : public flatbuffers::NativeTable
{
  typedef SelectOptions TableType;
};

struct SelectOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef SelectOptionsT NativeTableType;
  typedef SelectOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  SelectOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SelectOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SelectOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const SelectOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SelectOptionsBuilder
{
  typedef SelectOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SelectOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SelectOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SelectOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SelectOptions> CreateSelectOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  SelectOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SelectOptions>
CreateSelectOptions(flatbuffers::FlatBufferBuilder &_fbb, const SelectOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SliceOptionsT : public flatbuffers::NativeTable
{
  typedef SliceOptions TableType;
};

struct SliceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef SliceOptionsT NativeTableType;
  typedef SliceOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  SliceOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SliceOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SliceOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const SliceOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SliceOptionsBuilder
{
  typedef SliceOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SliceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SliceOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SliceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SliceOptions> CreateSliceOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  SliceOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SliceOptions>
CreateSliceOptions(flatbuffers::FlatBufferBuilder &_fbb, const SliceOptionsT *_o,
                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TransposeConvOptionsT : public flatbuffers::NativeTable
{
  typedef TransposeConvOptions TableType;
  circle::Padding padding = circle::Padding_SAME;
  int32_t stride_w = 0;
  int32_t stride_h = 0;
};

struct TransposeConvOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef TransposeConvOptionsT NativeTableType;
  typedef TransposeConvOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_PADDING = 4,
    VT_STRIDE_W = 6,
    VT_STRIDE_H = 8
  };
  circle::Padding padding() const
  {
    return static_cast<circle::Padding>(GetField<int8_t>(VT_PADDING, 0));
  }
  int32_t stride_w() const { return GetField<int32_t>(VT_STRIDE_W, 0); }
  int32_t stride_h() const { return GetField<int32_t>(VT_STRIDE_H, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_PADDING) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_W) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_H) && verifier.EndTable();
  }
  TransposeConvOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TransposeConvOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TransposeConvOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransposeConvOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TransposeConvOptionsBuilder
{
  typedef TransposeConvOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padding(circle::Padding padding)
  {
    fbb_.AddElement<int8_t>(TransposeConvOptions::VT_PADDING, static_cast<int8_t>(padding), 0);
  }
  void add_stride_w(int32_t stride_w)
  {
    fbb_.AddElement<int32_t>(TransposeConvOptions::VT_STRIDE_W, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h)
  {
    fbb_.AddElement<int32_t>(TransposeConvOptions::VT_STRIDE_H, stride_h, 0);
  }
  explicit TransposeConvOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TransposeConvOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TransposeConvOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<TransposeConvOptions>
CreateTransposeConvOptions(flatbuffers::FlatBufferBuilder &_fbb,
                           circle::Padding padding = circle::Padding_SAME, int32_t stride_w = 0,
                           int32_t stride_h = 0)
{
  TransposeConvOptionsBuilder builder_(_fbb);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_padding(padding);
  return builder_.Finish();
}

flatbuffers::Offset<TransposeConvOptions>
CreateTransposeConvOptions(flatbuffers::FlatBufferBuilder &_fbb, const TransposeConvOptionsT *_o,
                           const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExpandDimsOptionsT : public flatbuffers::NativeTable
{
  typedef ExpandDimsOptions TableType;
};

struct ExpandDimsOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef ExpandDimsOptionsT NativeTableType;
  typedef ExpandDimsOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  ExpandDimsOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExpandDimsOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ExpandDimsOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExpandDimsOptionsBuilder
{
  typedef ExpandDimsOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ExpandDimsOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ExpandDimsOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExpandDimsOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExpandDimsOptions>
CreateExpandDimsOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  ExpandDimsOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ExpandDimsOptions>
CreateExpandDimsOptions(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsOptionsT *_o,
                        const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SparseToDenseOptionsT : public flatbuffers::NativeTable
{
  typedef SparseToDenseOptions TableType;
  bool validate_indices = false;
};

struct SparseToDenseOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef SparseToDenseOptionsT NativeTableType;
  typedef SparseToDenseOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_VALIDATE_INDICES = 4
  };
  bool validate_indices() const { return GetField<uint8_t>(VT_VALIDATE_INDICES, 0) != 0; }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_VALIDATE_INDICES) &&
           verifier.EndTable();
  }
  SparseToDenseOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SparseToDenseOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SparseToDenseOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SparseToDenseOptionsBuilder
{
  typedef SparseToDenseOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_validate_indices(bool validate_indices)
  {
    fbb_.AddElement<uint8_t>(SparseToDenseOptions::VT_VALIDATE_INDICES,
                             static_cast<uint8_t>(validate_indices), 0);
  }
  explicit SparseToDenseOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SparseToDenseOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SparseToDenseOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SparseToDenseOptions>
CreateSparseToDenseOptions(flatbuffers::FlatBufferBuilder &_fbb, bool validate_indices = false)
{
  SparseToDenseOptionsBuilder builder_(_fbb);
  builder_.add_validate_indices(validate_indices);
  return builder_.Finish();
}

flatbuffers::Offset<SparseToDenseOptions>
CreateSparseToDenseOptions(flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseOptionsT *_o,
                           const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EqualOptionsT : public flatbuffers::NativeTable
{
  typedef EqualOptions TableType;
};

struct EqualOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef EqualOptionsT NativeTableType;
  typedef EqualOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  EqualOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EqualOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EqualOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const EqualOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EqualOptionsBuilder
{
  typedef EqualOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit EqualOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<EqualOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EqualOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<EqualOptions> CreateEqualOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  EqualOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<EqualOptions>
CreateEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const EqualOptionsT *_o,
                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NotEqualOptionsT : public flatbuffers::NativeTable
{
  typedef NotEqualOptions TableType;
};

struct NotEqualOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef NotEqualOptionsT NativeTableType;
  typedef NotEqualOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  NotEqualOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NotEqualOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NotEqualOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NotEqualOptionsBuilder
{
  typedef NotEqualOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NotEqualOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NotEqualOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NotEqualOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<NotEqualOptions>
CreateNotEqualOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  NotEqualOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<NotEqualOptions>
CreateNotEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualOptionsT *_o,
                      const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ShapeOptionsT : public flatbuffers::NativeTable
{
  typedef ShapeOptions TableType;
  circle::TensorType out_type = circle::TensorType_FLOAT32;
};

struct ShapeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef ShapeOptionsT NativeTableType;
  typedef ShapeOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_OUT_TYPE = 4
  };
  circle::TensorType out_type() const
  {
    return static_cast<circle::TensorType>(GetField<int8_t>(VT_OUT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_OUT_TYPE) &&
           verifier.EndTable();
  }
  ShapeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ShapeOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ShapeOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShapeOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ShapeOptionsBuilder
{
  typedef ShapeOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_out_type(circle::TensorType out_type)
  {
    fbb_.AddElement<int8_t>(ShapeOptions::VT_OUT_TYPE, static_cast<int8_t>(out_type), 0);
  }
  explicit ShapeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ShapeOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShapeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShapeOptions>
CreateShapeOptions(flatbuffers::FlatBufferBuilder &_fbb,
                   circle::TensorType out_type = circle::TensorType_FLOAT32)
{
  ShapeOptionsBuilder builder_(_fbb);
  builder_.add_out_type(out_type);
  return builder_.Finish();
}

flatbuffers::Offset<ShapeOptions>
CreateShapeOptions(flatbuffers::FlatBufferBuilder &_fbb, const ShapeOptionsT *_o,
                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RankOptionsT : public flatbuffers::NativeTable
{
  typedef RankOptions TableType;
};

struct RankOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef RankOptionsT NativeTableType;
  typedef RankOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  RankOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RankOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RankOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const RankOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RankOptionsBuilder
{
  typedef RankOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RankOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RankOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RankOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<RankOptions> CreateRankOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  RankOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<RankOptions>
CreateRankOptions(flatbuffers::FlatBufferBuilder &_fbb, const RankOptionsT *_o,
                  const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PowOptionsT : public flatbuffers::NativeTable
{
  typedef PowOptions TableType;
};

struct PowOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef PowOptionsT NativeTableType;
  typedef PowOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  PowOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PowOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PowOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const PowOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PowOptionsBuilder
{
  typedef PowOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PowOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PowOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PowOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<PowOptions> CreatePowOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  PowOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<PowOptions>
CreatePowOptions(flatbuffers::FlatBufferBuilder &_fbb, const PowOptionsT *_o,
                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FakeQuantOptionsT : public flatbuffers::NativeTable
{
  typedef FakeQuantOptions TableType;
  float min = 0.0f;
  float max = 0.0f;
  int32_t num_bits = 0;
  bool narrow_range = false;
};

struct FakeQuantOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef FakeQuantOptionsT NativeTableType;
  typedef FakeQuantOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_MIN = 4,
    VT_MAX = 6,
    VT_NUM_BITS = 8,
    VT_NARROW_RANGE = 10
  };
  float min() const { return GetField<float>(VT_MIN, 0.0f); }
  float max() const { return GetField<float>(VT_MAX, 0.0f); }
  int32_t num_bits() const { return GetField<int32_t>(VT_NUM_BITS, 0); }
  bool narrow_range() const { return GetField<uint8_t>(VT_NARROW_RANGE, 0) != 0; }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<float>(verifier, VT_MIN) &&
           VerifyField<float>(verifier, VT_MAX) && VerifyField<int32_t>(verifier, VT_NUM_BITS) &&
           VerifyField<uint8_t>(verifier, VT_NARROW_RANGE) && verifier.EndTable();
  }
  FakeQuantOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FakeQuantOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FakeQuantOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FakeQuantOptionsBuilder
{
  typedef FakeQuantOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_min(float min) { fbb_.AddElement<float>(FakeQuantOptions::VT_MIN, min, 0.0f); }
  void add_max(float max) { fbb_.AddElement<float>(FakeQuantOptions::VT_MAX, max, 0.0f); }
  void add_num_bits(int32_t num_bits)
  {
    fbb_.AddElement<int32_t>(FakeQuantOptions::VT_NUM_BITS, num_bits, 0);
  }
  void add_narrow_range(bool narrow_range)
  {
    fbb_.AddElement<uint8_t>(FakeQuantOptions::VT_NARROW_RANGE, static_cast<uint8_t>(narrow_range),
                             0);
  }
  explicit FakeQuantOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FakeQuantOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FakeQuantOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<FakeQuantOptions>
CreateFakeQuantOptions(flatbuffers::FlatBufferBuilder &_fbb, float min = 0.0f, float max = 0.0f,
                       int32_t num_bits = 0, bool narrow_range = false)
{
  FakeQuantOptionsBuilder builder_(_fbb);
  builder_.add_num_bits(num_bits);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_narrow_range(narrow_range);
  return builder_.Finish();
}

flatbuffers::Offset<FakeQuantOptions>
CreateFakeQuantOptions(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantOptionsT *_o,
                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PackOptionsT : public flatbuffers::NativeTable
{
  typedef PackOptions TableType;
  int32_t values_count = 0;
  int32_t axis = 0;
};

struct PackOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef PackOptionsT NativeTableType;
  typedef PackOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_VALUES_COUNT = 4,
    VT_AXIS = 6
  };
  int32_t values_count() const { return GetField<int32_t>(VT_VALUES_COUNT, 0); }
  int32_t axis() const { return GetField<int32_t>(VT_AXIS, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_VALUES_COUNT) &&
           VerifyField<int32_t>(verifier, VT_AXIS) && verifier.EndTable();
  }
  PackOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PackOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PackOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const PackOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PackOptionsBuilder
{
  typedef PackOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_values_count(int32_t values_count)
  {
    fbb_.AddElement<int32_t>(PackOptions::VT_VALUES_COUNT, values_count, 0);
  }
  void add_axis(int32_t axis) { fbb_.AddElement<int32_t>(PackOptions::VT_AXIS, axis, 0); }
  explicit PackOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PackOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PackOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<PackOptions>
CreatePackOptions(flatbuffers::FlatBufferBuilder &_fbb, int32_t values_count = 0, int32_t axis = 0)
{
  PackOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_values_count(values_count);
  return builder_.Finish();
}

flatbuffers::Offset<PackOptions>
CreatePackOptions(flatbuffers::FlatBufferBuilder &_fbb, const PackOptionsT *_o,
                  const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogicalOrOptionsT : public flatbuffers::NativeTable
{
  typedef LogicalOrOptions TableType;
};

struct LogicalOrOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef LogicalOrOptionsT NativeTableType;
  typedef LogicalOrOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  LogicalOrOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogicalOrOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LogicalOrOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogicalOrOptionsBuilder
{
  typedef LogicalOrOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogicalOrOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LogicalOrOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalOrOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalOrOptions>
CreateLogicalOrOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  LogicalOrOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LogicalOrOptions>
CreateLogicalOrOptions(flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrOptionsT *_o,
                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OneHotOptionsT : public flatbuffers::NativeTable
{
  typedef OneHotOptions TableType;
  int32_t axis = 0;
};

struct OneHotOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef OneHotOptionsT NativeTableType;
  typedef OneHotOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_AXIS = 4
  };
  int32_t axis() const { return GetField<int32_t>(VT_AXIS, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
  OneHotOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OneHotOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<OneHotOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const OneHotOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OneHotOptionsBuilder
{
  typedef OneHotOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) { fbb_.AddElement<int32_t>(OneHotOptions::VT_AXIS, axis, 0); }
  explicit OneHotOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OneHotOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OneHotOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<OneHotOptions> CreateOneHotOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                              int32_t axis = 0)
{
  OneHotOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

flatbuffers::Offset<OneHotOptions>
CreateOneHotOptions(flatbuffers::FlatBufferBuilder &_fbb, const OneHotOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AbsOptionsT : public flatbuffers::NativeTable
{
  typedef AbsOptions TableType;
};

struct AbsOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef AbsOptionsT NativeTableType;
  typedef AbsOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  AbsOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AbsOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AbsOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const AbsOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AbsOptionsBuilder
{
  typedef AbsOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AbsOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AbsOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AbsOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<AbsOptions> CreateAbsOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  AbsOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<AbsOptions>
CreateAbsOptions(flatbuffers::FlatBufferBuilder &_fbb, const AbsOptionsT *_o,
                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HardSwishOptionsT : public flatbuffers::NativeTable
{
  typedef HardSwishOptions TableType;
};

struct HardSwishOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef HardSwishOptionsT NativeTableType;
  typedef HardSwishOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  HardSwishOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HardSwishOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HardSwishOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const HardSwishOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HardSwishOptionsBuilder
{
  typedef HardSwishOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit HardSwishOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<HardSwishOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HardSwishOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<HardSwishOptions>
CreateHardSwishOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  HardSwishOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<HardSwishOptions>
CreateHardSwishOptions(flatbuffers::FlatBufferBuilder &_fbb, const HardSwishOptionsT *_o,
                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogicalAndOptionsT : public flatbuffers::NativeTable
{
  typedef LogicalAndOptions TableType;
};

struct LogicalAndOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef LogicalAndOptionsT NativeTableType;
  typedef LogicalAndOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  LogicalAndOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogicalAndOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LogicalAndOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogicalAndOptionsBuilder
{
  typedef LogicalAndOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogicalAndOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LogicalAndOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalAndOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalAndOptions>
CreateLogicalAndOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  LogicalAndOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LogicalAndOptions>
CreateLogicalAndOptions(flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndOptionsT *_o,
                        const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogicalNotOptionsT : public flatbuffers::NativeTable
{
  typedef LogicalNotOptions TableType;
};

struct LogicalNotOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef LogicalNotOptionsT NativeTableType;
  typedef LogicalNotOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  LogicalNotOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogicalNotOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LogicalNotOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogicalNotOptionsBuilder
{
  typedef LogicalNotOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogicalNotOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LogicalNotOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalNotOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalNotOptions>
CreateLogicalNotOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  LogicalNotOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LogicalNotOptions>
CreateLogicalNotOptions(flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotOptionsT *_o,
                        const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnpackOptionsT : public flatbuffers::NativeTable
{
  typedef UnpackOptions TableType;
  int32_t num = 0;
  int32_t axis = 0;
};

struct UnpackOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef UnpackOptionsT NativeTableType;
  typedef UnpackOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_NUM = 4,
    VT_AXIS = 6
  };
  int32_t num() const { return GetField<int32_t>(VT_NUM, 0); }
  int32_t axis() const { return GetField<int32_t>(VT_AXIS, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_NUM) &&
           VerifyField<int32_t>(verifier, VT_AXIS) && verifier.EndTable();
  }
  UnpackOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnpackOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UnpackOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnpackOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnpackOptionsBuilder
{
  typedef UnpackOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num(int32_t num) { fbb_.AddElement<int32_t>(UnpackOptions::VT_NUM, num, 0); }
  void add_axis(int32_t axis) { fbb_.AddElement<int32_t>(UnpackOptions::VT_AXIS, axis, 0); }
  explicit UnpackOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UnpackOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnpackOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnpackOptions> CreateUnpackOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                              int32_t num = 0, int32_t axis = 0)
{
  UnpackOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_num(num);
  return builder_.Finish();
}

flatbuffers::Offset<UnpackOptions>
CreateUnpackOptions(flatbuffers::FlatBufferBuilder &_fbb, const UnpackOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FloorDivOptionsT : public flatbuffers::NativeTable
{
  typedef FloorDivOptions TableType;
};

struct FloorDivOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef FloorDivOptionsT NativeTableType;
  typedef FloorDivOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  FloorDivOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FloorDivOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FloorDivOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloorDivOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FloorDivOptionsBuilder
{
  typedef FloorDivOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FloorDivOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FloorDivOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FloorDivOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<FloorDivOptions>
CreateFloorDivOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  FloorDivOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<FloorDivOptions>
CreateFloorDivOptions(flatbuffers::FlatBufferBuilder &_fbb, const FloorDivOptionsT *_o,
                      const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SquareOptionsT : public flatbuffers::NativeTable
{
  typedef SquareOptions TableType;
};

struct SquareOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef SquareOptionsT NativeTableType;
  typedef SquareOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  SquareOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SquareOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SquareOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const SquareOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SquareOptionsBuilder
{
  typedef SquareOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SquareOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SquareOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SquareOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SquareOptions> CreateSquareOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  SquareOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SquareOptions>
CreateSquareOptions(flatbuffers::FlatBufferBuilder &_fbb, const SquareOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ZerosLikeOptionsT : public flatbuffers::NativeTable
{
  typedef ZerosLikeOptions TableType;
};

struct ZerosLikeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef ZerosLikeOptionsT NativeTableType;
  typedef ZerosLikeOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  ZerosLikeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ZerosLikeOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ZerosLikeOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ZerosLikeOptionsBuilder
{
  typedef ZerosLikeOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ZerosLikeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ZerosLikeOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ZerosLikeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ZerosLikeOptions>
CreateZerosLikeOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  ZerosLikeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ZerosLikeOptions>
CreateZerosLikeOptions(flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeOptionsT *_o,
                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FillOptionsT : public flatbuffers::NativeTable
{
  typedef FillOptions TableType;
};

struct FillOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef FillOptionsT NativeTableType;
  typedef FillOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  FillOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FillOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FillOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const FillOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FillOptionsBuilder
{
  typedef FillOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FillOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FillOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FillOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<FillOptions> CreateFillOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  FillOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<FillOptions>
CreateFillOptions(flatbuffers::FlatBufferBuilder &_fbb, const FillOptionsT *_o,
                  const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FloorModOptionsT : public flatbuffers::NativeTable
{
  typedef FloorModOptions TableType;
};

struct FloorModOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef FloorModOptionsT NativeTableType;
  typedef FloorModOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  FloorModOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FloorModOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FloorModOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloorModOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FloorModOptionsBuilder
{
  typedef FloorModOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FloorModOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FloorModOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FloorModOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<FloorModOptions>
CreateFloorModOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  FloorModOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<FloorModOptions>
CreateFloorModOptions(flatbuffers::FlatBufferBuilder &_fbb, const FloorModOptionsT *_o,
                      const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RangeOptionsT : public flatbuffers::NativeTable
{
  typedef RangeOptions TableType;
};

struct RangeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef RangeOptionsT NativeTableType;
  typedef RangeOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  RangeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RangeOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RangeOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const RangeOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RangeOptionsBuilder
{
  typedef RangeOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RangeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RangeOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RangeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<RangeOptions> CreateRangeOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  RangeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<RangeOptions>
CreateRangeOptions(flatbuffers::FlatBufferBuilder &_fbb, const RangeOptionsT *_o,
                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LeakyReluOptionsT : public flatbuffers::NativeTable
{
  typedef LeakyReluOptions TableType;
  float alpha = 0.0f;
};

struct LeakyReluOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef LeakyReluOptionsT NativeTableType;
  typedef LeakyReluOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_ALPHA = 4
  };
  float alpha() const { return GetField<float>(VT_ALPHA, 0.0f); }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<float>(verifier, VT_ALPHA) &&
           verifier.EndTable();
  }
  LeakyReluOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LeakyReluOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LeakyReluOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LeakyReluOptionsBuilder
{
  typedef LeakyReluOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_alpha(float alpha) { fbb_.AddElement<float>(LeakyReluOptions::VT_ALPHA, alpha, 0.0f); }
  explicit LeakyReluOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LeakyReluOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LeakyReluOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LeakyReluOptions>
CreateLeakyReluOptions(flatbuffers::FlatBufferBuilder &_fbb, float alpha = 0.0f)
{
  LeakyReluOptionsBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  return builder_.Finish();
}

flatbuffers::Offset<LeakyReluOptions>
CreateLeakyReluOptions(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluOptionsT *_o,
                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SquaredDifferenceOptionsT : public flatbuffers::NativeTable
{
  typedef SquaredDifferenceOptions TableType;
};

struct SquaredDifferenceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef SquaredDifferenceOptionsT NativeTableType;
  typedef SquaredDifferenceOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  SquaredDifferenceOptionsT *
  UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SquaredDifferenceOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SquaredDifferenceOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const SquaredDifferenceOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SquaredDifferenceOptionsBuilder
{
  typedef SquaredDifferenceOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SquaredDifferenceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SquaredDifferenceOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SquaredDifferenceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SquaredDifferenceOptions>
CreateSquaredDifferenceOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  SquaredDifferenceOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SquaredDifferenceOptions>
CreateSquaredDifferenceOptions(flatbuffers::FlatBufferBuilder &_fbb,
                               const SquaredDifferenceOptionsT *_o,
                               const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MirrorPadOptionsT : public flatbuffers::NativeTable
{
  typedef MirrorPadOptions TableType;
  circle::MirrorPadMode mode = circle::MirrorPadMode_REFLECT;
};

struct MirrorPadOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef MirrorPadOptionsT NativeTableType;
  typedef MirrorPadOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_MODE = 4
  };
  circle::MirrorPadMode mode() const
  {
    return static_cast<circle::MirrorPadMode>(GetField<int8_t>(VT_MODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_MODE) &&
           verifier.EndTable();
  }
  MirrorPadOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MirrorPadOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MirrorPadOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const MirrorPadOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MirrorPadOptionsBuilder
{
  typedef MirrorPadOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mode(circle::MirrorPadMode mode)
  {
    fbb_.AddElement<int8_t>(MirrorPadOptions::VT_MODE, static_cast<int8_t>(mode), 0);
  }
  explicit MirrorPadOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MirrorPadOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MirrorPadOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<MirrorPadOptions>
CreateMirrorPadOptions(flatbuffers::FlatBufferBuilder &_fbb,
                       circle::MirrorPadMode mode = circle::MirrorPadMode_REFLECT)
{
  MirrorPadOptionsBuilder builder_(_fbb);
  builder_.add_mode(mode);
  return builder_.Finish();
}

flatbuffers::Offset<MirrorPadOptions>
CreateMirrorPadOptions(flatbuffers::FlatBufferBuilder &_fbb, const MirrorPadOptionsT *_o,
                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UniqueOptionsT : public flatbuffers::NativeTable
{
  typedef UniqueOptions TableType;
  circle::TensorType idx_out_type = circle::TensorType_INT32;
};

struct UniqueOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef UniqueOptionsT NativeTableType;
  typedef UniqueOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_IDX_OUT_TYPE = 4
  };
  circle::TensorType idx_out_type() const
  {
    return static_cast<circle::TensorType>(GetField<int8_t>(VT_IDX_OUT_TYPE, 2));
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_IDX_OUT_TYPE) &&
           verifier.EndTable();
  }
  UniqueOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UniqueOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UniqueOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const UniqueOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UniqueOptionsBuilder
{
  typedef UniqueOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_idx_out_type(circle::TensorType idx_out_type)
  {
    fbb_.AddElement<int8_t>(UniqueOptions::VT_IDX_OUT_TYPE, static_cast<int8_t>(idx_out_type), 2);
  }
  explicit UniqueOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UniqueOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UniqueOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<UniqueOptions>
CreateUniqueOptions(flatbuffers::FlatBufferBuilder &_fbb,
                    circle::TensorType idx_out_type = circle::TensorType_INT32)
{
  UniqueOptionsBuilder builder_(_fbb);
  builder_.add_idx_out_type(idx_out_type);
  return builder_.Finish();
}

flatbuffers::Offset<UniqueOptions>
CreateUniqueOptions(flatbuffers::FlatBufferBuilder &_fbb, const UniqueOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReverseV2OptionsT : public flatbuffers::NativeTable
{
  typedef ReverseV2Options TableType;
};

struct ReverseV2Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef ReverseV2OptionsT NativeTableType;
  typedef ReverseV2OptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  ReverseV2OptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReverseV2OptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReverseV2Options>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReverseV2OptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReverseV2OptionsBuilder
{
  typedef ReverseV2Options Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ReverseV2OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ReverseV2Options> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReverseV2Options>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReverseV2Options>
CreateReverseV2Options(flatbuffers::FlatBufferBuilder &_fbb)
{
  ReverseV2OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ReverseV2Options>
CreateReverseV2Options(flatbuffers::FlatBufferBuilder &_fbb, const ReverseV2OptionsT *_o,
                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AddNOptionsT : public flatbuffers::NativeTable
{
  typedef AddNOptions TableType;
};

struct AddNOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef AddNOptionsT NativeTableType;
  typedef AddNOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  AddNOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AddNOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AddNOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddNOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AddNOptionsBuilder
{
  typedef AddNOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AddNOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AddNOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddNOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddNOptions> CreateAddNOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  AddNOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<AddNOptions>
CreateAddNOptions(flatbuffers::FlatBufferBuilder &_fbb, const AddNOptionsT *_o,
                  const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GatherNdOptionsT : public flatbuffers::NativeTable
{
  typedef GatherNdOptions TableType;
};

struct GatherNdOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef GatherNdOptionsT NativeTableType;
  typedef GatherNdOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  GatherNdOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GatherNdOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GatherNdOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherNdOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GatherNdOptionsBuilder
{
  typedef GatherNdOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GatherNdOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GatherNdOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GatherNdOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<GatherNdOptions>
CreateGatherNdOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  GatherNdOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<GatherNdOptions>
CreateGatherNdOptions(flatbuffers::FlatBufferBuilder &_fbb, const GatherNdOptionsT *_o,
                      const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WhereOptionsT : public flatbuffers::NativeTable
{
  typedef WhereOptions TableType;
};

struct WhereOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef WhereOptionsT NativeTableType;
  typedef WhereOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  WhereOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WhereOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<WhereOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const WhereOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WhereOptionsBuilder
{
  typedef WhereOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit WhereOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<WhereOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WhereOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<WhereOptions> CreateWhereOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  WhereOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<WhereOptions>
CreateWhereOptions(flatbuffers::FlatBufferBuilder &_fbb, const WhereOptionsT *_o,
                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReverseSequenceOptionsT : public flatbuffers::NativeTable
{
  typedef ReverseSequenceOptions TableType;
  int32_t seq_dim = 0;
  int32_t batch_dim = 0;
};

struct ReverseSequenceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef ReverseSequenceOptionsT NativeTableType;
  typedef ReverseSequenceOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_SEQ_DIM = 4,
    VT_BATCH_DIM = 6
  };
  int32_t seq_dim() const { return GetField<int32_t>(VT_SEQ_DIM, 0); }
  int32_t batch_dim() const { return GetField<int32_t>(VT_BATCH_DIM, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_SEQ_DIM) &&
           VerifyField<int32_t>(verifier, VT_BATCH_DIM) && verifier.EndTable();
  }
  ReverseSequenceOptionsT *
  UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReverseSequenceOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReverseSequenceOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReverseSequenceOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReverseSequenceOptionsBuilder
{
  typedef ReverseSequenceOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_seq_dim(int32_t seq_dim)
  {
    fbb_.AddElement<int32_t>(ReverseSequenceOptions::VT_SEQ_DIM, seq_dim, 0);
  }
  void add_batch_dim(int32_t batch_dim)
  {
    fbb_.AddElement<int32_t>(ReverseSequenceOptions::VT_BATCH_DIM, batch_dim, 0);
  }
  explicit ReverseSequenceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ReverseSequenceOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReverseSequenceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReverseSequenceOptions>
CreateReverseSequenceOptions(flatbuffers::FlatBufferBuilder &_fbb, int32_t seq_dim = 0,
                             int32_t batch_dim = 0)
{
  ReverseSequenceOptionsBuilder builder_(_fbb);
  builder_.add_batch_dim(batch_dim);
  builder_.add_seq_dim(seq_dim);
  return builder_.Finish();
}

flatbuffers::Offset<ReverseSequenceOptions>
CreateReverseSequenceOptions(flatbuffers::FlatBufferBuilder &_fbb,
                             const ReverseSequenceOptionsT *_o,
                             const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MatrixDiagOptionsT : public flatbuffers::NativeTable
{
  typedef MatrixDiagOptions TableType;
};

struct MatrixDiagOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef MatrixDiagOptionsT NativeTableType;
  typedef MatrixDiagOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  MatrixDiagOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MatrixDiagOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MatrixDiagOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatrixDiagOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MatrixDiagOptionsBuilder
{
  typedef MatrixDiagOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MatrixDiagOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MatrixDiagOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MatrixDiagOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<MatrixDiagOptions>
CreateMatrixDiagOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  MatrixDiagOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<MatrixDiagOptions>
CreateMatrixDiagOptions(flatbuffers::FlatBufferBuilder &_fbb, const MatrixDiagOptionsT *_o,
                        const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct QuantizeOptionsT : public flatbuffers::NativeTable
{
  typedef QuantizeOptions TableType;
};

struct QuantizeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef QuantizeOptionsT NativeTableType;
  typedef QuantizeOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  QuantizeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(QuantizeOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<QuantizeOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantizeOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct QuantizeOptionsBuilder
{
  typedef QuantizeOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit QuantizeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<QuantizeOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuantizeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<QuantizeOptions>
CreateQuantizeOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  QuantizeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<QuantizeOptions>
CreateQuantizeOptions(flatbuffers::FlatBufferBuilder &_fbb, const QuantizeOptionsT *_o,
                      const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MatrixSetDiagOptionsT : public flatbuffers::NativeTable
{
  typedef MatrixSetDiagOptions TableType;
};

struct MatrixSetDiagOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef MatrixSetDiagOptionsT NativeTableType;
  typedef MatrixSetDiagOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  MatrixSetDiagOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MatrixSetDiagOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MatrixSetDiagOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatrixSetDiagOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MatrixSetDiagOptionsBuilder
{
  typedef MatrixSetDiagOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MatrixSetDiagOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MatrixSetDiagOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MatrixSetDiagOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<MatrixSetDiagOptions>
CreateMatrixSetDiagOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  MatrixSetDiagOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<MatrixSetDiagOptions>
CreateMatrixSetDiagOptions(flatbuffers::FlatBufferBuilder &_fbb, const MatrixSetDiagOptionsT *_o,
                           const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct IfOptionsT : public flatbuffers::NativeTable
{
  typedef IfOptions TableType;
  int32_t then_subgraph_index = 0;
  int32_t else_subgraph_index = 0;
};

struct IfOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef IfOptionsT NativeTableType;
  typedef IfOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_THEN_SUBGRAPH_INDEX = 4,
    VT_ELSE_SUBGRAPH_INDEX = 6
  };
  int32_t then_subgraph_index() const { return GetField<int32_t>(VT_THEN_SUBGRAPH_INDEX, 0); }
  int32_t else_subgraph_index() const { return GetField<int32_t>(VT_ELSE_SUBGRAPH_INDEX, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_THEN_SUBGRAPH_INDEX) &&
           VerifyField<int32_t>(verifier, VT_ELSE_SUBGRAPH_INDEX) && verifier.EndTable();
  }
  IfOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(IfOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<IfOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const IfOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IfOptionsBuilder
{
  typedef IfOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_then_subgraph_index(int32_t then_subgraph_index)
  {
    fbb_.AddElement<int32_t>(IfOptions::VT_THEN_SUBGRAPH_INDEX, then_subgraph_index, 0);
  }
  void add_else_subgraph_index(int32_t else_subgraph_index)
  {
    fbb_.AddElement<int32_t>(IfOptions::VT_ELSE_SUBGRAPH_INDEX, else_subgraph_index, 0);
  }
  explicit IfOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<IfOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IfOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<IfOptions> CreateIfOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                      int32_t then_subgraph_index = 0,
                                                      int32_t else_subgraph_index = 0)
{
  IfOptionsBuilder builder_(_fbb);
  builder_.add_else_subgraph_index(else_subgraph_index);
  builder_.add_then_subgraph_index(then_subgraph_index);
  return builder_.Finish();
}

flatbuffers::Offset<IfOptions>
CreateIfOptions(flatbuffers::FlatBufferBuilder &_fbb, const IfOptionsT *_o,
                const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CallOnceOptionsT : public flatbuffers::NativeTable
{
  typedef CallOnceOptions TableType;
  int32_t init_subgraph_index = 0;
};

struct CallOnceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef CallOnceOptionsT NativeTableType;
  typedef CallOnceOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_INIT_SUBGRAPH_INDEX = 4
  };
  int32_t init_subgraph_index() const { return GetField<int32_t>(VT_INIT_SUBGRAPH_INDEX, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_INIT_SUBGRAPH_INDEX) &&
           verifier.EndTable();
  }
  CallOnceOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CallOnceOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CallOnceOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const CallOnceOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CallOnceOptionsBuilder
{
  typedef CallOnceOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_init_subgraph_index(int32_t init_subgraph_index)
  {
    fbb_.AddElement<int32_t>(CallOnceOptions::VT_INIT_SUBGRAPH_INDEX, init_subgraph_index, 0);
  }
  explicit CallOnceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CallOnceOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CallOnceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<CallOnceOptions>
CreateCallOnceOptions(flatbuffers::FlatBufferBuilder &_fbb, int32_t init_subgraph_index = 0)
{
  CallOnceOptionsBuilder builder_(_fbb);
  builder_.add_init_subgraph_index(init_subgraph_index);
  return builder_.Finish();
}

flatbuffers::Offset<CallOnceOptions>
CreateCallOnceOptions(flatbuffers::FlatBufferBuilder &_fbb, const CallOnceOptionsT *_o,
                      const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WhileOptionsT : public flatbuffers::NativeTable
{
  typedef WhileOptions TableType;
  int32_t cond_subgraph_index = 0;
  int32_t body_subgraph_index = 0;
};

struct WhileOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef WhileOptionsT NativeTableType;
  typedef WhileOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_COND_SUBGRAPH_INDEX = 4,
    VT_BODY_SUBGRAPH_INDEX = 6
  };
  int32_t cond_subgraph_index() const { return GetField<int32_t>(VT_COND_SUBGRAPH_INDEX, 0); }
  int32_t body_subgraph_index() const { return GetField<int32_t>(VT_BODY_SUBGRAPH_INDEX, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_COND_SUBGRAPH_INDEX) &&
           VerifyField<int32_t>(verifier, VT_BODY_SUBGRAPH_INDEX) && verifier.EndTable();
  }
  WhileOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WhileOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<WhileOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const WhileOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WhileOptionsBuilder
{
  typedef WhileOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cond_subgraph_index(int32_t cond_subgraph_index)
  {
    fbb_.AddElement<int32_t>(WhileOptions::VT_COND_SUBGRAPH_INDEX, cond_subgraph_index, 0);
  }
  void add_body_subgraph_index(int32_t body_subgraph_index)
  {
    fbb_.AddElement<int32_t>(WhileOptions::VT_BODY_SUBGRAPH_INDEX, body_subgraph_index, 0);
  }
  explicit WhileOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<WhileOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WhileOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<WhileOptions> CreateWhileOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                            int32_t cond_subgraph_index = 0,
                                                            int32_t body_subgraph_index = 0)
{
  WhileOptionsBuilder builder_(_fbb);
  builder_.add_body_subgraph_index(body_subgraph_index);
  builder_.add_cond_subgraph_index(cond_subgraph_index);
  return builder_.Finish();
}

flatbuffers::Offset<WhileOptions>
CreateWhileOptions(flatbuffers::FlatBufferBuilder &_fbb, const WhileOptionsT *_o,
                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NonMaxSuppressionV4OptionsT : public flatbuffers::NativeTable
{
  typedef NonMaxSuppressionV4Options TableType;
};

struct NonMaxSuppressionV4Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef NonMaxSuppressionV4OptionsT NativeTableType;
  typedef NonMaxSuppressionV4OptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  NonMaxSuppressionV4OptionsT *
  UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NonMaxSuppressionV4OptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NonMaxSuppressionV4Options>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV4OptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NonMaxSuppressionV4OptionsBuilder
{
  typedef NonMaxSuppressionV4Options Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NonMaxSuppressionV4OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NonMaxSuppressionV4Options> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NonMaxSuppressionV4Options>(end);
    return o;
  }
};

inline flatbuffers::Offset<NonMaxSuppressionV4Options>
CreateNonMaxSuppressionV4Options(flatbuffers::FlatBufferBuilder &_fbb)
{
  NonMaxSuppressionV4OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<NonMaxSuppressionV4Options>
CreateNonMaxSuppressionV4Options(flatbuffers::FlatBufferBuilder &_fbb,
                                 const NonMaxSuppressionV4OptionsT *_o,
                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NonMaxSuppressionV5OptionsT : public flatbuffers::NativeTable
{
  typedef NonMaxSuppressionV5Options TableType;
};

struct NonMaxSuppressionV5Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef NonMaxSuppressionV5OptionsT NativeTableType;
  typedef NonMaxSuppressionV5OptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  NonMaxSuppressionV5OptionsT *
  UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NonMaxSuppressionV5OptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NonMaxSuppressionV5Options>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV5OptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NonMaxSuppressionV5OptionsBuilder
{
  typedef NonMaxSuppressionV5Options Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NonMaxSuppressionV5OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NonMaxSuppressionV5Options> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NonMaxSuppressionV5Options>(end);
    return o;
  }
};

inline flatbuffers::Offset<NonMaxSuppressionV5Options>
CreateNonMaxSuppressionV5Options(flatbuffers::FlatBufferBuilder &_fbb)
{
  NonMaxSuppressionV5OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<NonMaxSuppressionV5Options>
CreateNonMaxSuppressionV5Options(flatbuffers::FlatBufferBuilder &_fbb,
                                 const NonMaxSuppressionV5OptionsT *_o,
                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ScatterNdOptionsT : public flatbuffers::NativeTable
{
  typedef ScatterNdOptions TableType;
};

struct ScatterNdOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef ScatterNdOptionsT NativeTableType;
  typedef ScatterNdOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  ScatterNdOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ScatterNdOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ScatterNdOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ScatterNdOptionsBuilder
{
  typedef ScatterNdOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ScatterNdOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ScatterNdOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScatterNdOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScatterNdOptions>
CreateScatterNdOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  ScatterNdOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ScatterNdOptions>
CreateScatterNdOptions(flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdOptionsT *_o,
                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SelectV2OptionsT : public flatbuffers::NativeTable
{
  typedef SelectV2Options TableType;
};

struct SelectV2Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef SelectV2OptionsT NativeTableType;
  typedef SelectV2OptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  SelectV2OptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SelectV2OptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SelectV2Options>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const SelectV2OptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SelectV2OptionsBuilder
{
  typedef SelectV2Options Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SelectV2OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SelectV2Options> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SelectV2Options>(end);
    return o;
  }
};

inline flatbuffers::Offset<SelectV2Options>
CreateSelectV2Options(flatbuffers::FlatBufferBuilder &_fbb)
{
  SelectV2OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SelectV2Options>
CreateSelectV2Options(flatbuffers::FlatBufferBuilder &_fbb, const SelectV2OptionsT *_o,
                      const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DensifyOptionsT : public flatbuffers::NativeTable
{
  typedef DensifyOptions TableType;
};

struct DensifyOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef DensifyOptionsT NativeTableType;
  typedef DensifyOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  DensifyOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DensifyOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DensifyOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const DensifyOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DensifyOptionsBuilder
{
  typedef DensifyOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DensifyOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DensifyOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DensifyOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<DensifyOptions>
CreateDensifyOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  DensifyOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<DensifyOptions>
CreateDensifyOptions(flatbuffers::FlatBufferBuilder &_fbb, const DensifyOptionsT *_o,
                     const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SegmentSumOptionsT : public flatbuffers::NativeTable
{
  typedef SegmentSumOptions TableType;
};

struct SegmentSumOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef SegmentSumOptionsT NativeTableType;
  typedef SegmentSumOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  SegmentSumOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SegmentSumOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SegmentSumOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const SegmentSumOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SegmentSumOptionsBuilder
{
  typedef SegmentSumOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SegmentSumOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SegmentSumOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SegmentSumOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SegmentSumOptions>
CreateSegmentSumOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  SegmentSumOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SegmentSumOptions>
CreateSegmentSumOptions(flatbuffers::FlatBufferBuilder &_fbb, const SegmentSumOptionsT *_o,
                        const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BatchMatMulOptionsT : public flatbuffers::NativeTable
{
  typedef BatchMatMulOptions TableType;
  bool adjoint_lhs = false;
  bool adjoint_rhs = false;
  bool asymmetric_quantize_inputs = false;
};

struct BatchMatMulOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef BatchMatMulOptionsT NativeTableType;
  typedef BatchMatMulOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_ADJOINT_LHS = 4,
    VT_ADJOINT_RHS = 6,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 8
  };
  bool adjoint_lhs() const { return GetField<uint8_t>(VT_ADJOINT_LHS, 0) != 0; }
  bool adjoint_rhs() const { return GetField<uint8_t>(VT_ADJOINT_RHS, 0) != 0; }
  bool asymmetric_quantize_inputs() const
  {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_ADJOINT_LHS) &&
           VerifyField<uint8_t>(verifier, VT_ADJOINT_RHS) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) && verifier.EndTable();
  }
  BatchMatMulOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BatchMatMulOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BatchMatMulOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchMatMulOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BatchMatMulOptionsBuilder
{
  typedef BatchMatMulOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_adjoint_lhs(bool adjoint_lhs)
  {
    fbb_.AddElement<uint8_t>(BatchMatMulOptions::VT_ADJOINT_LHS, static_cast<uint8_t>(adjoint_lhs),
                             0);
  }
  void add_adjoint_rhs(bool adjoint_rhs)
  {
    fbb_.AddElement<uint8_t>(BatchMatMulOptions::VT_ADJOINT_RHS, static_cast<uint8_t>(adjoint_rhs),
                             0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs)
  {
    fbb_.AddElement<uint8_t>(BatchMatMulOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                             static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit BatchMatMulOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BatchMatMulOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchMatMulOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchMatMulOptions>
CreateBatchMatMulOptions(flatbuffers::FlatBufferBuilder &_fbb, bool adjoint_lhs = false,
                         bool adjoint_rhs = false, bool asymmetric_quantize_inputs = false)
{
  BatchMatMulOptionsBuilder builder_(_fbb);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_adjoint_rhs(adjoint_rhs);
  builder_.add_adjoint_lhs(adjoint_lhs);
  return builder_.Finish();
}

flatbuffers::Offset<BatchMatMulOptions>
CreateBatchMatMulOptions(flatbuffers::FlatBufferBuilder &_fbb, const BatchMatMulOptionsT *_o,
                         const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CumsumOptionsT : public flatbuffers::NativeTable
{
  typedef CumsumOptions TableType;
  bool exclusive = false;
  bool reverse = false;
};

struct CumsumOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef CumsumOptionsT NativeTableType;
  typedef CumsumOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_EXCLUSIVE = 4,
    VT_REVERSE = 6
  };
  bool exclusive() const { return GetField<uint8_t>(VT_EXCLUSIVE, 0) != 0; }
  bool reverse() const { return GetField<uint8_t>(VT_REVERSE, 0) != 0; }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_EXCLUSIVE) &&
           VerifyField<uint8_t>(verifier, VT_REVERSE) && verifier.EndTable();
  }
  CumsumOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CumsumOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CumsumOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const CumsumOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CumsumOptionsBuilder
{
  typedef CumsumOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_exclusive(bool exclusive)
  {
    fbb_.AddElement<uint8_t>(CumsumOptions::VT_EXCLUSIVE, static_cast<uint8_t>(exclusive), 0);
  }
  void add_reverse(bool reverse)
  {
    fbb_.AddElement<uint8_t>(CumsumOptions::VT_REVERSE, static_cast<uint8_t>(reverse), 0);
  }
  explicit CumsumOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CumsumOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CumsumOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<CumsumOptions> CreateCumsumOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                              bool exclusive = false,
                                                              bool reverse = false)
{
  CumsumOptionsBuilder builder_(_fbb);
  builder_.add_reverse(reverse);
  builder_.add_exclusive(exclusive);
  return builder_.Finish();
}

flatbuffers::Offset<CumsumOptions>
CreateCumsumOptions(flatbuffers::FlatBufferBuilder &_fbb, const CumsumOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BroadcastToOptionsT : public flatbuffers::NativeTable
{
  typedef BroadcastToOptions TableType;
};

struct BroadcastToOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef BroadcastToOptionsT NativeTableType;
  typedef BroadcastToOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  BroadcastToOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BroadcastToOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BroadcastToOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const BroadcastToOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BroadcastToOptionsBuilder
{
  typedef BroadcastToOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BroadcastToOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BroadcastToOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BroadcastToOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BroadcastToOptions>
CreateBroadcastToOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  BroadcastToOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<BroadcastToOptions>
CreateBroadcastToOptions(flatbuffers::FlatBufferBuilder &_fbb, const BroadcastToOptionsT *_o,
                         const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Rfft2dOptionsT : public flatbuffers::NativeTable
{
  typedef Rfft2dOptions TableType;
};

struct Rfft2dOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef Rfft2dOptionsT NativeTableType;
  typedef Rfft2dOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  Rfft2dOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Rfft2dOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Rfft2dOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const Rfft2dOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Rfft2dOptionsBuilder
{
  typedef Rfft2dOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit Rfft2dOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Rfft2dOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Rfft2dOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<Rfft2dOptions> CreateRfft2dOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  Rfft2dOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Rfft2dOptions>
CreateRfft2dOptions(flatbuffers::FlatBufferBuilder &_fbb, const Rfft2dOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HashtableOptionsT : public flatbuffers::NativeTable
{
  typedef HashtableOptions TableType;
  int32_t table_id = 0;
  circle::TensorType key_dtype = circle::TensorType_FLOAT32;
  circle::TensorType value_dtype = circle::TensorType_FLOAT32;
};

struct HashtableOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef HashtableOptionsT NativeTableType;
  typedef HashtableOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_TABLE_ID = 4,
    VT_KEY_DTYPE = 6,
    VT_VALUE_DTYPE = 8
  };
  int32_t table_id() const { return GetField<int32_t>(VT_TABLE_ID, 0); }
  circle::TensorType key_dtype() const
  {
    return static_cast<circle::TensorType>(GetField<int8_t>(VT_KEY_DTYPE, 0));
  }
  circle::TensorType value_dtype() const
  {
    return static_cast<circle::TensorType>(GetField<int8_t>(VT_VALUE_DTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_TABLE_ID) &&
           VerifyField<int8_t>(verifier, VT_KEY_DTYPE) &&
           VerifyField<int8_t>(verifier, VT_VALUE_DTYPE) && verifier.EndTable();
  }
  HashtableOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HashtableOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HashtableOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const HashtableOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HashtableOptionsBuilder
{
  typedef HashtableOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_table_id(int32_t table_id)
  {
    fbb_.AddElement<int32_t>(HashtableOptions::VT_TABLE_ID, table_id, 0);
  }
  void add_key_dtype(circle::TensorType key_dtype)
  {
    fbb_.AddElement<int8_t>(HashtableOptions::VT_KEY_DTYPE, static_cast<int8_t>(key_dtype), 0);
  }
  void add_value_dtype(circle::TensorType value_dtype)
  {
    fbb_.AddElement<int8_t>(HashtableOptions::VT_VALUE_DTYPE, static_cast<int8_t>(value_dtype), 0);
  }
  explicit HashtableOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<HashtableOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HashtableOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<HashtableOptions>
CreateHashtableOptions(flatbuffers::FlatBufferBuilder &_fbb, int32_t table_id = 0,
                       circle::TensorType key_dtype = circle::TensorType_FLOAT32,
                       circle::TensorType value_dtype = circle::TensorType_FLOAT32)
{
  HashtableOptionsBuilder builder_(_fbb);
  builder_.add_table_id(table_id);
  builder_.add_value_dtype(value_dtype);
  builder_.add_key_dtype(key_dtype);
  return builder_.Finish();
}

flatbuffers::Offset<HashtableOptions>
CreateHashtableOptions(flatbuffers::FlatBufferBuilder &_fbb, const HashtableOptionsT *_o,
                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HashtableFindOptionsT : public flatbuffers::NativeTable
{
  typedef HashtableFindOptions TableType;
};

struct HashtableFindOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef HashtableFindOptionsT NativeTableType;
  typedef HashtableFindOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  HashtableFindOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HashtableFindOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HashtableFindOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const HashtableFindOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HashtableFindOptionsBuilder
{
  typedef HashtableFindOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit HashtableFindOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<HashtableFindOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HashtableFindOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<HashtableFindOptions>
CreateHashtableFindOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  HashtableFindOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<HashtableFindOptions>
CreateHashtableFindOptions(flatbuffers::FlatBufferBuilder &_fbb, const HashtableFindOptionsT *_o,
                           const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HashtableImportOptionsT : public flatbuffers::NativeTable
{
  typedef HashtableImportOptions TableType;
};

struct HashtableImportOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef HashtableImportOptionsT NativeTableType;
  typedef HashtableImportOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  HashtableImportOptionsT *
  UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HashtableImportOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HashtableImportOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const HashtableImportOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HashtableImportOptionsBuilder
{
  typedef HashtableImportOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit HashtableImportOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<HashtableImportOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HashtableImportOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<HashtableImportOptions>
CreateHashtableImportOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  HashtableImportOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<HashtableImportOptions>
CreateHashtableImportOptions(flatbuffers::FlatBufferBuilder &_fbb,
                             const HashtableImportOptionsT *_o,
                             const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HashtableSizeOptionsT : public flatbuffers::NativeTable
{
  typedef HashtableSizeOptions TableType;
};

struct HashtableSizeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef HashtableSizeOptionsT NativeTableType;
  typedef HashtableSizeOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  HashtableSizeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HashtableSizeOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HashtableSizeOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const HashtableSizeOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HashtableSizeOptionsBuilder
{
  typedef HashtableSizeOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit HashtableSizeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<HashtableSizeOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HashtableSizeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<HashtableSizeOptions>
CreateHashtableSizeOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  HashtableSizeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<HashtableSizeOptions>
CreateHashtableSizeOptions(flatbuffers::FlatBufferBuilder &_fbb, const HashtableSizeOptionsT *_o,
                           const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct VarHandleOptionsT : public flatbuffers::NativeTable
{
  typedef VarHandleOptions TableType;
  std::string container{};
  std::string shared_name{};
};

struct VarHandleOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef VarHandleOptionsT NativeTableType;
  typedef VarHandleOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_CONTAINER = 4,
    VT_SHARED_NAME = 6
  };
  const flatbuffers::String *container() const
  {
    return GetPointer<const flatbuffers::String *>(VT_CONTAINER);
  }
  const flatbuffers::String *shared_name() const
  {
    return GetPointer<const flatbuffers::String *>(VT_SHARED_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_CONTAINER) &&
           verifier.VerifyString(container()) && VerifyOffset(verifier, VT_SHARED_NAME) &&
           verifier.VerifyString(shared_name()) && verifier.EndTable();
  }
  VarHandleOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(VarHandleOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<VarHandleOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const VarHandleOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct VarHandleOptionsBuilder
{
  typedef VarHandleOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_container(flatbuffers::Offset<flatbuffers::String> container)
  {
    fbb_.AddOffset(VarHandleOptions::VT_CONTAINER, container);
  }
  void add_shared_name(flatbuffers::Offset<flatbuffers::String> shared_name)
  {
    fbb_.AddOffset(VarHandleOptions::VT_SHARED_NAME, shared_name);
  }
  explicit VarHandleOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<VarHandleOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VarHandleOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<VarHandleOptions>
CreateVarHandleOptions(flatbuffers::FlatBufferBuilder &_fbb,
                       flatbuffers::Offset<flatbuffers::String> container = 0,
                       flatbuffers::Offset<flatbuffers::String> shared_name = 0)
{
  VarHandleOptionsBuilder builder_(_fbb);
  builder_.add_shared_name(shared_name);
  builder_.add_container(container);
  return builder_.Finish();
}

inline flatbuffers::Offset<VarHandleOptions>
CreateVarHandleOptionsDirect(flatbuffers::FlatBufferBuilder &_fbb, const char *container = nullptr,
                             const char *shared_name = nullptr)
{
  auto container__ = container ? _fbb.CreateString(container) : 0;
  auto shared_name__ = shared_name ? _fbb.CreateString(shared_name) : 0;
  return circle::CreateVarHandleOptions(_fbb, container__, shared_name__);
}

flatbuffers::Offset<VarHandleOptions>
CreateVarHandleOptions(flatbuffers::FlatBufferBuilder &_fbb, const VarHandleOptionsT *_o,
                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReadVariableOptionsT : public flatbuffers::NativeTable
{
  typedef ReadVariableOptions TableType;
};

struct ReadVariableOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef ReadVariableOptionsT NativeTableType;
  typedef ReadVariableOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  ReadVariableOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReadVariableOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReadVariableOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReadVariableOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReadVariableOptionsBuilder
{
  typedef ReadVariableOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ReadVariableOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ReadVariableOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReadVariableOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReadVariableOptions>
CreateReadVariableOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  ReadVariableOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ReadVariableOptions>
CreateReadVariableOptions(flatbuffers::FlatBufferBuilder &_fbb, const ReadVariableOptionsT *_o,
                          const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AssignVariableOptionsT : public flatbuffers::NativeTable
{
  typedef AssignVariableOptions TableType;
};

struct AssignVariableOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef AssignVariableOptionsT NativeTableType;
  typedef AssignVariableOptionsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
  AssignVariableOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AssignVariableOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AssignVariableOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const AssignVariableOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AssignVariableOptionsBuilder
{
  typedef AssignVariableOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AssignVariableOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AssignVariableOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AssignVariableOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<AssignVariableOptions>
CreateAssignVariableOptions(flatbuffers::FlatBufferBuilder &_fbb)
{
  AssignVariableOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<AssignVariableOptions>
CreateAssignVariableOptions(flatbuffers::FlatBufferBuilder &_fbb, const AssignVariableOptionsT *_o,
                            const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RandomOptionsT : public flatbuffers::NativeTable
{
  typedef RandomOptions TableType;
  int32_t seed = 0;
  int32_t seed2 = 0;
};

struct RandomOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef RandomOptionsT NativeTableType;
  typedef RandomOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_SEED = 4,
    VT_SEED2 = 6
  };
  int32_t seed() const { return GetField<int32_t>(VT_SEED, 0); }
  int32_t seed2() const { return GetField<int32_t>(VT_SEED2, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_SEED) &&
           VerifyField<int32_t>(verifier, VT_SEED2) && verifier.EndTable();
  }
  RandomOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RandomOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RandomOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const RandomOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RandomOptionsBuilder
{
  typedef RandomOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_seed(int32_t seed) { fbb_.AddElement<int32_t>(RandomOptions::VT_SEED, seed, 0); }
  void add_seed2(int32_t seed2) { fbb_.AddElement<int32_t>(RandomOptions::VT_SEED2, seed2, 0); }
  explicit RandomOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RandomOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RandomOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<RandomOptions> CreateRandomOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                              int32_t seed = 0, int32_t seed2 = 0)
{
  RandomOptionsBuilder builder_(_fbb);
  builder_.add_seed2(seed2);
  builder_.add_seed(seed);
  return builder_.Finish();
}

flatbuffers::Offset<RandomOptions>
CreateRandomOptions(flatbuffers::FlatBufferBuilder &_fbb, const RandomOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BCQGatherOptionsT : public flatbuffers::NativeTable
{
  typedef BCQGatherOptions TableType;
  int32_t input_hidden_size = 0;
  int32_t axis = 0;
};

struct BCQGatherOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef BCQGatherOptionsT NativeTableType;
  typedef BCQGatherOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_INPUT_HIDDEN_SIZE = 4,
    VT_AXIS = 6
  };
  int32_t input_hidden_size() const { return GetField<int32_t>(VT_INPUT_HIDDEN_SIZE, 0); }
  int32_t axis() const { return GetField<int32_t>(VT_AXIS, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_INPUT_HIDDEN_SIZE) &&
           VerifyField<int32_t>(verifier, VT_AXIS) && verifier.EndTable();
  }
  BCQGatherOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BCQGatherOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BCQGatherOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const BCQGatherOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BCQGatherOptionsBuilder
{
  typedef BCQGatherOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input_hidden_size(int32_t input_hidden_size)
  {
    fbb_.AddElement<int32_t>(BCQGatherOptions::VT_INPUT_HIDDEN_SIZE, input_hidden_size, 0);
  }
  void add_axis(int32_t axis) { fbb_.AddElement<int32_t>(BCQGatherOptions::VT_AXIS, axis, 0); }
  explicit BCQGatherOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BCQGatherOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BCQGatherOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BCQGatherOptions>
CreateBCQGatherOptions(flatbuffers::FlatBufferBuilder &_fbb, int32_t input_hidden_size = 0,
                       int32_t axis = 0)
{
  BCQGatherOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_input_hidden_size(input_hidden_size);
  return builder_.Finish();
}

flatbuffers::Offset<BCQGatherOptions>
CreateBCQGatherOptions(flatbuffers::FlatBufferBuilder &_fbb, const BCQGatherOptionsT *_o,
                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BCQFullyConnectedOptionsT : public flatbuffers::NativeTable
{
  typedef BCQFullyConnectedOptions TableType;
  int32_t weights_hidden_size = 0;
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE;
};

struct BCQFullyConnectedOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef BCQFullyConnectedOptionsT NativeTableType;
  typedef BCQFullyConnectedOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_WEIGHTS_HIDDEN_SIZE = 4,
    VT_FUSED_ACTIVATION_FUNCTION = 6
  };
  int32_t weights_hidden_size() const { return GetField<int32_t>(VT_WEIGHTS_HIDDEN_SIZE, 0); }
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_WEIGHTS_HIDDEN_SIZE) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) && verifier.EndTable();
  }
  BCQFullyConnectedOptionsT *
  UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BCQFullyConnectedOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BCQFullyConnectedOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const BCQFullyConnectedOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BCQFullyConnectedOptionsBuilder
{
  typedef BCQFullyConnectedOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_weights_hidden_size(int32_t weights_hidden_size)
  {
    fbb_.AddElement<int32_t>(BCQFullyConnectedOptions::VT_WEIGHTS_HIDDEN_SIZE, weights_hidden_size,
                             0);
  }
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(BCQFullyConnectedOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit BCQFullyConnectedOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BCQFullyConnectedOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BCQFullyConnectedOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BCQFullyConnectedOptions> CreateBCQFullyConnectedOptions(
  flatbuffers::FlatBufferBuilder &_fbb, int32_t weights_hidden_size = 0,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE)
{
  BCQFullyConnectedOptionsBuilder builder_(_fbb);
  builder_.add_weights_hidden_size(weights_hidden_size);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<BCQFullyConnectedOptions>
CreateBCQFullyConnectedOptions(flatbuffers::FlatBufferBuilder &_fbb,
                               const BCQFullyConnectedOptionsT *_o,
                               const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InstanceNormOptionsT : public flatbuffers::NativeTable
{
  typedef InstanceNormOptions TableType;
  float epsilon = 0.0f;
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE;
};

struct InstanceNormOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef InstanceNormOptionsT NativeTableType;
  typedef InstanceNormOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_EPSILON = 4,
    VT_FUSED_ACTIVATION_FUNCTION = 6
  };
  float epsilon() const { return GetField<float>(VT_EPSILON, 0.0f); }
  circle::ActivationFunctionType fused_activation_function() const
  {
    return static_cast<circle::ActivationFunctionType>(
      GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<float>(verifier, VT_EPSILON) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) && verifier.EndTable();
  }
  InstanceNormOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InstanceNormOptionsT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<InstanceNormOptions>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const InstanceNormOptionsT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InstanceNormOptionsBuilder
{
  typedef InstanceNormOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_epsilon(float epsilon)
  {
    fbb_.AddElement<float>(InstanceNormOptions::VT_EPSILON, epsilon, 0.0f);
  }
  void add_fused_activation_function(circle::ActivationFunctionType fused_activation_function)
  {
    fbb_.AddElement<int8_t>(InstanceNormOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit InstanceNormOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<InstanceNormOptions> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InstanceNormOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<InstanceNormOptions> CreateInstanceNormOptions(
  flatbuffers::FlatBufferBuilder &_fbb, float epsilon = 0.0f,
  circle::ActivationFunctionType fused_activation_function = circle::ActivationFunctionType_NONE)
{
  InstanceNormOptionsBuilder builder_(_fbb);
  builder_.add_epsilon(epsilon);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<InstanceNormOptions>
CreateInstanceNormOptions(flatbuffers::FlatBufferBuilder &_fbb, const InstanceNormOptionsT *_o,
                          const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OperatorCodeT : public flatbuffers::NativeTable
{
  typedef OperatorCode TableType;
  int8_t deprecated_builtin_code = 0;
  std::string custom_code{};
  int32_t version = 1;
  circle::BuiltinOperator builtin_code = circle::BuiltinOperator_ADD;
};

struct OperatorCode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef OperatorCodeT NativeTableType;
  typedef OperatorCodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_DEPRECATED_BUILTIN_CODE = 4,
    VT_CUSTOM_CODE = 6,
    VT_VERSION = 8,
    VT_BUILTIN_CODE = 10
  };
  int8_t deprecated_builtin_code() const { return GetField<int8_t>(VT_DEPRECATED_BUILTIN_CODE, 0); }
  const flatbuffers::String *custom_code() const
  {
    return GetPointer<const flatbuffers::String *>(VT_CUSTOM_CODE);
  }
  int32_t version() const { return GetField<int32_t>(VT_VERSION, 1); }
  circle::BuiltinOperator builtin_code() const
  {
    return static_cast<circle::BuiltinOperator>(GetField<int32_t>(VT_BUILTIN_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_DEPRECATED_BUILTIN_CODE) &&
           VerifyOffset(verifier, VT_CUSTOM_CODE) && verifier.VerifyString(custom_code()) &&
           VerifyField<int32_t>(verifier, VT_VERSION) &&
           VerifyField<int32_t>(verifier, VT_BUILTIN_CODE) && verifier.EndTable();
  }
  OperatorCodeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OperatorCodeT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<OperatorCode>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const OperatorCodeT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OperatorCodeBuilder
{
  typedef OperatorCode Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_deprecated_builtin_code(int8_t deprecated_builtin_code)
  {
    fbb_.AddElement<int8_t>(OperatorCode::VT_DEPRECATED_BUILTIN_CODE, deprecated_builtin_code, 0);
  }
  void add_custom_code(flatbuffers::Offset<flatbuffers::String> custom_code)
  {
    fbb_.AddOffset(OperatorCode::VT_CUSTOM_CODE, custom_code);
  }
  void add_version(int32_t version)
  {
    fbb_.AddElement<int32_t>(OperatorCode::VT_VERSION, version, 1);
  }
  void add_builtin_code(circle::BuiltinOperator builtin_code)
  {
    fbb_.AddElement<int32_t>(OperatorCode::VT_BUILTIN_CODE, static_cast<int32_t>(builtin_code), 0);
  }
  explicit OperatorCodeBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OperatorCode> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OperatorCode>(end);
    return o;
  }
};

inline flatbuffers::Offset<OperatorCode>
CreateOperatorCode(flatbuffers::FlatBufferBuilder &_fbb, int8_t deprecated_builtin_code = 0,
                   flatbuffers::Offset<flatbuffers::String> custom_code = 0, int32_t version = 1,
                   circle::BuiltinOperator builtin_code = circle::BuiltinOperator_ADD)
{
  OperatorCodeBuilder builder_(_fbb);
  builder_.add_builtin_code(builtin_code);
  builder_.add_version(version);
  builder_.add_custom_code(custom_code);
  builder_.add_deprecated_builtin_code(deprecated_builtin_code);
  return builder_.Finish();
}

inline flatbuffers::Offset<OperatorCode>
CreateOperatorCodeDirect(flatbuffers::FlatBufferBuilder &_fbb, int8_t deprecated_builtin_code = 0,
                         const char *custom_code = nullptr, int32_t version = 1,
                         circle::BuiltinOperator builtin_code = circle::BuiltinOperator_ADD)
{
  auto custom_code__ = custom_code ? _fbb.CreateString(custom_code) : 0;
  return circle::CreateOperatorCode(_fbb, deprecated_builtin_code, custom_code__, version,
                                    builtin_code);
}

flatbuffers::Offset<OperatorCode>
CreateOperatorCode(flatbuffers::FlatBufferBuilder &_fbb, const OperatorCodeT *_o,
                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OperatorT : public flatbuffers::NativeTable
{
  typedef Operator TableType;
  uint32_t opcode_index = 0;
  std::vector<int32_t> inputs{};
  std::vector<int32_t> outputs{};
  circle::BuiltinOptionsUnion builtin_options{};
  std::vector<uint8_t> custom_options{};
  circle::CustomOptionsFormat custom_options_format = circle::CustomOptionsFormat_FLEXBUFFERS;
  std::vector<bool> mutating_variable_inputs{};
  std::vector<int32_t> intermediates{};
};

struct Operator FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef OperatorT NativeTableType;
  typedef OperatorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_OPCODE_INDEX = 4,
    VT_INPUTS = 6,
    VT_OUTPUTS = 8,
    VT_BUILTIN_OPTIONS_TYPE = 10,
    VT_BUILTIN_OPTIONS = 12,
    VT_CUSTOM_OPTIONS = 14,
    VT_CUSTOM_OPTIONS_FORMAT = 16,
    VT_MUTATING_VARIABLE_INPUTS = 18,
    VT_INTERMEDIATES = 20
  };
  uint32_t opcode_index() const { return GetField<uint32_t>(VT_OPCODE_INDEX, 0); }
  const flatbuffers::Vector<int32_t> *inputs() const
  {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INPUTS);
  }
  const flatbuffers::Vector<int32_t> *outputs() const
  {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_OUTPUTS);
  }
  circle::BuiltinOptions builtin_options_type() const
  {
    return static_cast<circle::BuiltinOptions>(GetField<uint8_t>(VT_BUILTIN_OPTIONS_TYPE, 0));
  }
  const void *builtin_options() const { return GetPointer<const void *>(VT_BUILTIN_OPTIONS); }
  template <typename T> const T *builtin_options_as() const;
  const circle::Conv2DOptions *builtin_options_as_Conv2DOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_Conv2DOptions
             ? static_cast<const circle::Conv2DOptions *>(builtin_options())
             : nullptr;
  }
  const circle::DepthwiseConv2DOptions *builtin_options_as_DepthwiseConv2DOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_DepthwiseConv2DOptions
             ? static_cast<const circle::DepthwiseConv2DOptions *>(builtin_options())
             : nullptr;
  }
  const circle::ConcatEmbeddingsOptions *builtin_options_as_ConcatEmbeddingsOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_ConcatEmbeddingsOptions
             ? static_cast<const circle::ConcatEmbeddingsOptions *>(builtin_options())
             : nullptr;
  }
  const circle::LSHProjectionOptions *builtin_options_as_LSHProjectionOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_LSHProjectionOptions
             ? static_cast<const circle::LSHProjectionOptions *>(builtin_options())
             : nullptr;
  }
  const circle::Pool2DOptions *builtin_options_as_Pool2DOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_Pool2DOptions
             ? static_cast<const circle::Pool2DOptions *>(builtin_options())
             : nullptr;
  }
  const circle::SVDFOptions *builtin_options_as_SVDFOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_SVDFOptions
             ? static_cast<const circle::SVDFOptions *>(builtin_options())
             : nullptr;
  }
  const circle::RNNOptions *builtin_options_as_RNNOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_RNNOptions
             ? static_cast<const circle::RNNOptions *>(builtin_options())
             : nullptr;
  }
  const circle::FullyConnectedOptions *builtin_options_as_FullyConnectedOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_FullyConnectedOptions
             ? static_cast<const circle::FullyConnectedOptions *>(builtin_options())
             : nullptr;
  }
  const circle::SoftmaxOptions *builtin_options_as_SoftmaxOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_SoftmaxOptions
             ? static_cast<const circle::SoftmaxOptions *>(builtin_options())
             : nullptr;
  }
  const circle::ConcatenationOptions *builtin_options_as_ConcatenationOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_ConcatenationOptions
             ? static_cast<const circle::ConcatenationOptions *>(builtin_options())
             : nullptr;
  }
  const circle::AddOptions *builtin_options_as_AddOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_AddOptions
             ? static_cast<const circle::AddOptions *>(builtin_options())
             : nullptr;
  }
  const circle::L2NormOptions *builtin_options_as_L2NormOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_L2NormOptions
             ? static_cast<const circle::L2NormOptions *>(builtin_options())
             : nullptr;
  }
  const circle::LocalResponseNormalizationOptions *
  builtin_options_as_LocalResponseNormalizationOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_LocalResponseNormalizationOptions
             ? static_cast<const circle::LocalResponseNormalizationOptions *>(builtin_options())
             : nullptr;
  }
  const circle::LSTMOptions *builtin_options_as_LSTMOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_LSTMOptions
             ? static_cast<const circle::LSTMOptions *>(builtin_options())
             : nullptr;
  }
  const circle::ResizeBilinearOptions *builtin_options_as_ResizeBilinearOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_ResizeBilinearOptions
             ? static_cast<const circle::ResizeBilinearOptions *>(builtin_options())
             : nullptr;
  }
  const circle::CallOptions *builtin_options_as_CallOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_CallOptions
             ? static_cast<const circle::CallOptions *>(builtin_options())
             : nullptr;
  }
  const circle::ReshapeOptions *builtin_options_as_ReshapeOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_ReshapeOptions
             ? static_cast<const circle::ReshapeOptions *>(builtin_options())
             : nullptr;
  }
  const circle::SkipGramOptions *builtin_options_as_SkipGramOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_SkipGramOptions
             ? static_cast<const circle::SkipGramOptions *>(builtin_options())
             : nullptr;
  }
  const circle::SpaceToDepthOptions *builtin_options_as_SpaceToDepthOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_SpaceToDepthOptions
             ? static_cast<const circle::SpaceToDepthOptions *>(builtin_options())
             : nullptr;
  }
  const circle::EmbeddingLookupSparseOptions *
  builtin_options_as_EmbeddingLookupSparseOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_EmbeddingLookupSparseOptions
             ? static_cast<const circle::EmbeddingLookupSparseOptions *>(builtin_options())
             : nullptr;
  }
  const circle::MulOptions *builtin_options_as_MulOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_MulOptions
             ? static_cast<const circle::MulOptions *>(builtin_options())
             : nullptr;
  }
  const circle::PadOptions *builtin_options_as_PadOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_PadOptions
             ? static_cast<const circle::PadOptions *>(builtin_options())
             : nullptr;
  }
  const circle::GatherOptions *builtin_options_as_GatherOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_GatherOptions
             ? static_cast<const circle::GatherOptions *>(builtin_options())
             : nullptr;
  }
  const circle::BatchToSpaceNDOptions *builtin_options_as_BatchToSpaceNDOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_BatchToSpaceNDOptions
             ? static_cast<const circle::BatchToSpaceNDOptions *>(builtin_options())
             : nullptr;
  }
  const circle::SpaceToBatchNDOptions *builtin_options_as_SpaceToBatchNDOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_SpaceToBatchNDOptions
             ? static_cast<const circle::SpaceToBatchNDOptions *>(builtin_options())
             : nullptr;
  }
  const circle::TransposeOptions *builtin_options_as_TransposeOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_TransposeOptions
             ? static_cast<const circle::TransposeOptions *>(builtin_options())
             : nullptr;
  }
  const circle::ReducerOptions *builtin_options_as_ReducerOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_ReducerOptions
             ? static_cast<const circle::ReducerOptions *>(builtin_options())
             : nullptr;
  }
  const circle::SubOptions *builtin_options_as_SubOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_SubOptions
             ? static_cast<const circle::SubOptions *>(builtin_options())
             : nullptr;
  }
  const circle::DivOptions *builtin_options_as_DivOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_DivOptions
             ? static_cast<const circle::DivOptions *>(builtin_options())
             : nullptr;
  }
  const circle::SqueezeOptions *builtin_options_as_SqueezeOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_SqueezeOptions
             ? static_cast<const circle::SqueezeOptions *>(builtin_options())
             : nullptr;
  }
  const circle::SequenceRNNOptions *builtin_options_as_SequenceRNNOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_SequenceRNNOptions
             ? static_cast<const circle::SequenceRNNOptions *>(builtin_options())
             : nullptr;
  }
  const circle::StridedSliceOptions *builtin_options_as_StridedSliceOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_StridedSliceOptions
             ? static_cast<const circle::StridedSliceOptions *>(builtin_options())
             : nullptr;
  }
  const circle::ExpOptions *builtin_options_as_ExpOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_ExpOptions
             ? static_cast<const circle::ExpOptions *>(builtin_options())
             : nullptr;
  }
  const circle::TopKV2Options *builtin_options_as_TopKV2Options() const
  {
    return builtin_options_type() == circle::BuiltinOptions_TopKV2Options
             ? static_cast<const circle::TopKV2Options *>(builtin_options())
             : nullptr;
  }
  const circle::SplitOptions *builtin_options_as_SplitOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_SplitOptions
             ? static_cast<const circle::SplitOptions *>(builtin_options())
             : nullptr;
  }
  const circle::LogSoftmaxOptions *builtin_options_as_LogSoftmaxOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_LogSoftmaxOptions
             ? static_cast<const circle::LogSoftmaxOptions *>(builtin_options())
             : nullptr;
  }
  const circle::CastOptions *builtin_options_as_CastOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_CastOptions
             ? static_cast<const circle::CastOptions *>(builtin_options())
             : nullptr;
  }
  const circle::DequantizeOptions *builtin_options_as_DequantizeOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_DequantizeOptions
             ? static_cast<const circle::DequantizeOptions *>(builtin_options())
             : nullptr;
  }
  const circle::MaximumMinimumOptions *builtin_options_as_MaximumMinimumOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_MaximumMinimumOptions
             ? static_cast<const circle::MaximumMinimumOptions *>(builtin_options())
             : nullptr;
  }
  const circle::ArgMaxOptions *builtin_options_as_ArgMaxOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_ArgMaxOptions
             ? static_cast<const circle::ArgMaxOptions *>(builtin_options())
             : nullptr;
  }
  const circle::LessOptions *builtin_options_as_LessOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_LessOptions
             ? static_cast<const circle::LessOptions *>(builtin_options())
             : nullptr;
  }
  const circle::NegOptions *builtin_options_as_NegOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_NegOptions
             ? static_cast<const circle::NegOptions *>(builtin_options())
             : nullptr;
  }
  const circle::PadV2Options *builtin_options_as_PadV2Options() const
  {
    return builtin_options_type() == circle::BuiltinOptions_PadV2Options
             ? static_cast<const circle::PadV2Options *>(builtin_options())
             : nullptr;
  }
  const circle::GreaterOptions *builtin_options_as_GreaterOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_GreaterOptions
             ? static_cast<const circle::GreaterOptions *>(builtin_options())
             : nullptr;
  }
  const circle::GreaterEqualOptions *builtin_options_as_GreaterEqualOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_GreaterEqualOptions
             ? static_cast<const circle::GreaterEqualOptions *>(builtin_options())
             : nullptr;
  }
  const circle::LessEqualOptions *builtin_options_as_LessEqualOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_LessEqualOptions
             ? static_cast<const circle::LessEqualOptions *>(builtin_options())
             : nullptr;
  }
  const circle::SelectOptions *builtin_options_as_SelectOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_SelectOptions
             ? static_cast<const circle::SelectOptions *>(builtin_options())
             : nullptr;
  }
  const circle::SliceOptions *builtin_options_as_SliceOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_SliceOptions
             ? static_cast<const circle::SliceOptions *>(builtin_options())
             : nullptr;
  }
  const circle::TransposeConvOptions *builtin_options_as_TransposeConvOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_TransposeConvOptions
             ? static_cast<const circle::TransposeConvOptions *>(builtin_options())
             : nullptr;
  }
  const circle::SparseToDenseOptions *builtin_options_as_SparseToDenseOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_SparseToDenseOptions
             ? static_cast<const circle::SparseToDenseOptions *>(builtin_options())
             : nullptr;
  }
  const circle::TileOptions *builtin_options_as_TileOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_TileOptions
             ? static_cast<const circle::TileOptions *>(builtin_options())
             : nullptr;
  }
  const circle::ExpandDimsOptions *builtin_options_as_ExpandDimsOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_ExpandDimsOptions
             ? static_cast<const circle::ExpandDimsOptions *>(builtin_options())
             : nullptr;
  }
  const circle::EqualOptions *builtin_options_as_EqualOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_EqualOptions
             ? static_cast<const circle::EqualOptions *>(builtin_options())
             : nullptr;
  }
  const circle::NotEqualOptions *builtin_options_as_NotEqualOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_NotEqualOptions
             ? static_cast<const circle::NotEqualOptions *>(builtin_options())
             : nullptr;
  }
  const circle::ShapeOptions *builtin_options_as_ShapeOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_ShapeOptions
             ? static_cast<const circle::ShapeOptions *>(builtin_options())
             : nullptr;
  }
  const circle::PowOptions *builtin_options_as_PowOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_PowOptions
             ? static_cast<const circle::PowOptions *>(builtin_options())
             : nullptr;
  }
  const circle::ArgMinOptions *builtin_options_as_ArgMinOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_ArgMinOptions
             ? static_cast<const circle::ArgMinOptions *>(builtin_options())
             : nullptr;
  }
  const circle::FakeQuantOptions *builtin_options_as_FakeQuantOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_FakeQuantOptions
             ? static_cast<const circle::FakeQuantOptions *>(builtin_options())
             : nullptr;
  }
  const circle::PackOptions *builtin_options_as_PackOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_PackOptions
             ? static_cast<const circle::PackOptions *>(builtin_options())
             : nullptr;
  }
  const circle::LogicalOrOptions *builtin_options_as_LogicalOrOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_LogicalOrOptions
             ? static_cast<const circle::LogicalOrOptions *>(builtin_options())
             : nullptr;
  }
  const circle::OneHotOptions *builtin_options_as_OneHotOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_OneHotOptions
             ? static_cast<const circle::OneHotOptions *>(builtin_options())
             : nullptr;
  }
  const circle::LogicalAndOptions *builtin_options_as_LogicalAndOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_LogicalAndOptions
             ? static_cast<const circle::LogicalAndOptions *>(builtin_options())
             : nullptr;
  }
  const circle::LogicalNotOptions *builtin_options_as_LogicalNotOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_LogicalNotOptions
             ? static_cast<const circle::LogicalNotOptions *>(builtin_options())
             : nullptr;
  }
  const circle::UnpackOptions *builtin_options_as_UnpackOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_UnpackOptions
             ? static_cast<const circle::UnpackOptions *>(builtin_options())
             : nullptr;
  }
  const circle::FloorDivOptions *builtin_options_as_FloorDivOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_FloorDivOptions
             ? static_cast<const circle::FloorDivOptions *>(builtin_options())
             : nullptr;
  }
  const circle::SquareOptions *builtin_options_as_SquareOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_SquareOptions
             ? static_cast<const circle::SquareOptions *>(builtin_options())
             : nullptr;
  }
  const circle::ZerosLikeOptions *builtin_options_as_ZerosLikeOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_ZerosLikeOptions
             ? static_cast<const circle::ZerosLikeOptions *>(builtin_options())
             : nullptr;
  }
  const circle::FillOptions *builtin_options_as_FillOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_FillOptions
             ? static_cast<const circle::FillOptions *>(builtin_options())
             : nullptr;
  }
  const circle::BidirectionalSequenceLSTMOptions *
  builtin_options_as_BidirectionalSequenceLSTMOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_BidirectionalSequenceLSTMOptions
             ? static_cast<const circle::BidirectionalSequenceLSTMOptions *>(builtin_options())
             : nullptr;
  }
  const circle::BidirectionalSequenceRNNOptions *
  builtin_options_as_BidirectionalSequenceRNNOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_BidirectionalSequenceRNNOptions
             ? static_cast<const circle::BidirectionalSequenceRNNOptions *>(builtin_options())
             : nullptr;
  }
  const circle::UnidirectionalSequenceLSTMOptions *
  builtin_options_as_UnidirectionalSequenceLSTMOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_UnidirectionalSequenceLSTMOptions
             ? static_cast<const circle::UnidirectionalSequenceLSTMOptions *>(builtin_options())
             : nullptr;
  }
  const circle::FloorModOptions *builtin_options_as_FloorModOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_FloorModOptions
             ? static_cast<const circle::FloorModOptions *>(builtin_options())
             : nullptr;
  }
  const circle::RangeOptions *builtin_options_as_RangeOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_RangeOptions
             ? static_cast<const circle::RangeOptions *>(builtin_options())
             : nullptr;
  }
  const circle::ResizeNearestNeighborOptions *
  builtin_options_as_ResizeNearestNeighborOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_ResizeNearestNeighborOptions
             ? static_cast<const circle::ResizeNearestNeighborOptions *>(builtin_options())
             : nullptr;
  }
  const circle::LeakyReluOptions *builtin_options_as_LeakyReluOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_LeakyReluOptions
             ? static_cast<const circle::LeakyReluOptions *>(builtin_options())
             : nullptr;
  }
  const circle::SquaredDifferenceOptions *builtin_options_as_SquaredDifferenceOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_SquaredDifferenceOptions
             ? static_cast<const circle::SquaredDifferenceOptions *>(builtin_options())
             : nullptr;
  }
  const circle::MirrorPadOptions *builtin_options_as_MirrorPadOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_MirrorPadOptions
             ? static_cast<const circle::MirrorPadOptions *>(builtin_options())
             : nullptr;
  }
  const circle::AbsOptions *builtin_options_as_AbsOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_AbsOptions
             ? static_cast<const circle::AbsOptions *>(builtin_options())
             : nullptr;
  }
  const circle::SplitVOptions *builtin_options_as_SplitVOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_SplitVOptions
             ? static_cast<const circle::SplitVOptions *>(builtin_options())
             : nullptr;
  }
  const circle::UniqueOptions *builtin_options_as_UniqueOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_UniqueOptions
             ? static_cast<const circle::UniqueOptions *>(builtin_options())
             : nullptr;
  }
  const circle::ReverseV2Options *builtin_options_as_ReverseV2Options() const
  {
    return builtin_options_type() == circle::BuiltinOptions_ReverseV2Options
             ? static_cast<const circle::ReverseV2Options *>(builtin_options())
             : nullptr;
  }
  const circle::AddNOptions *builtin_options_as_AddNOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_AddNOptions
             ? static_cast<const circle::AddNOptions *>(builtin_options())
             : nullptr;
  }
  const circle::GatherNdOptions *builtin_options_as_GatherNdOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_GatherNdOptions
             ? static_cast<const circle::GatherNdOptions *>(builtin_options())
             : nullptr;
  }
  const circle::CosOptions *builtin_options_as_CosOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_CosOptions
             ? static_cast<const circle::CosOptions *>(builtin_options())
             : nullptr;
  }
  const circle::WhereOptions *builtin_options_as_WhereOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_WhereOptions
             ? static_cast<const circle::WhereOptions *>(builtin_options())
             : nullptr;
  }
  const circle::RankOptions *builtin_options_as_RankOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_RankOptions
             ? static_cast<const circle::RankOptions *>(builtin_options())
             : nullptr;
  }
  const circle::ReverseSequenceOptions *builtin_options_as_ReverseSequenceOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_ReverseSequenceOptions
             ? static_cast<const circle::ReverseSequenceOptions *>(builtin_options())
             : nullptr;
  }
  const circle::MatrixDiagOptions *builtin_options_as_MatrixDiagOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_MatrixDiagOptions
             ? static_cast<const circle::MatrixDiagOptions *>(builtin_options())
             : nullptr;
  }
  const circle::QuantizeOptions *builtin_options_as_QuantizeOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_QuantizeOptions
             ? static_cast<const circle::QuantizeOptions *>(builtin_options())
             : nullptr;
  }
  const circle::MatrixSetDiagOptions *builtin_options_as_MatrixSetDiagOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_MatrixSetDiagOptions
             ? static_cast<const circle::MatrixSetDiagOptions *>(builtin_options())
             : nullptr;
  }
  const circle::HardSwishOptions *builtin_options_as_HardSwishOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_HardSwishOptions
             ? static_cast<const circle::HardSwishOptions *>(builtin_options())
             : nullptr;
  }
  const circle::IfOptions *builtin_options_as_IfOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_IfOptions
             ? static_cast<const circle::IfOptions *>(builtin_options())
             : nullptr;
  }
  const circle::WhileOptions *builtin_options_as_WhileOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_WhileOptions
             ? static_cast<const circle::WhileOptions *>(builtin_options())
             : nullptr;
  }
  const circle::DepthToSpaceOptions *builtin_options_as_DepthToSpaceOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_DepthToSpaceOptions
             ? static_cast<const circle::DepthToSpaceOptions *>(builtin_options())
             : nullptr;
  }
  const circle::NonMaxSuppressionV4Options *builtin_options_as_NonMaxSuppressionV4Options() const
  {
    return builtin_options_type() == circle::BuiltinOptions_NonMaxSuppressionV4Options
             ? static_cast<const circle::NonMaxSuppressionV4Options *>(builtin_options())
             : nullptr;
  }
  const circle::NonMaxSuppressionV5Options *builtin_options_as_NonMaxSuppressionV5Options() const
  {
    return builtin_options_type() == circle::BuiltinOptions_NonMaxSuppressionV5Options
             ? static_cast<const circle::NonMaxSuppressionV5Options *>(builtin_options())
             : nullptr;
  }
  const circle::ScatterNdOptions *builtin_options_as_ScatterNdOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_ScatterNdOptions
             ? static_cast<const circle::ScatterNdOptions *>(builtin_options())
             : nullptr;
  }
  const circle::SelectV2Options *builtin_options_as_SelectV2Options() const
  {
    return builtin_options_type() == circle::BuiltinOptions_SelectV2Options
             ? static_cast<const circle::SelectV2Options *>(builtin_options())
             : nullptr;
  }
  const circle::DensifyOptions *builtin_options_as_DensifyOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_DensifyOptions
             ? static_cast<const circle::DensifyOptions *>(builtin_options())
             : nullptr;
  }
  const circle::SegmentSumOptions *builtin_options_as_SegmentSumOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_SegmentSumOptions
             ? static_cast<const circle::SegmentSumOptions *>(builtin_options())
             : nullptr;
  }
  const circle::BatchMatMulOptions *builtin_options_as_BatchMatMulOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_BatchMatMulOptions
             ? static_cast<const circle::BatchMatMulOptions *>(builtin_options())
             : nullptr;
  }
  const circle::CumsumOptions *builtin_options_as_CumsumOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_CumsumOptions
             ? static_cast<const circle::CumsumOptions *>(builtin_options())
             : nullptr;
  }
  const circle::CallOnceOptions *builtin_options_as_CallOnceOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_CallOnceOptions
             ? static_cast<const circle::CallOnceOptions *>(builtin_options())
             : nullptr;
  }
  const circle::BroadcastToOptions *builtin_options_as_BroadcastToOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_BroadcastToOptions
             ? static_cast<const circle::BroadcastToOptions *>(builtin_options())
             : nullptr;
  }
  const circle::Rfft2dOptions *builtin_options_as_Rfft2dOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_Rfft2dOptions
             ? static_cast<const circle::Rfft2dOptions *>(builtin_options())
             : nullptr;
  }
  const circle::Conv3DOptions *builtin_options_as_Conv3DOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_Conv3DOptions
             ? static_cast<const circle::Conv3DOptions *>(builtin_options())
             : nullptr;
  }
  const circle::HashtableOptions *builtin_options_as_HashtableOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_HashtableOptions
             ? static_cast<const circle::HashtableOptions *>(builtin_options())
             : nullptr;
  }
  const circle::HashtableFindOptions *builtin_options_as_HashtableFindOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_HashtableFindOptions
             ? static_cast<const circle::HashtableFindOptions *>(builtin_options())
             : nullptr;
  }
  const circle::HashtableImportOptions *builtin_options_as_HashtableImportOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_HashtableImportOptions
             ? static_cast<const circle::HashtableImportOptions *>(builtin_options())
             : nullptr;
  }
  const circle::HashtableSizeOptions *builtin_options_as_HashtableSizeOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_HashtableSizeOptions
             ? static_cast<const circle::HashtableSizeOptions *>(builtin_options())
             : nullptr;
  }
  const circle::VarHandleOptions *builtin_options_as_VarHandleOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_VarHandleOptions
             ? static_cast<const circle::VarHandleOptions *>(builtin_options())
             : nullptr;
  }
  const circle::ReadVariableOptions *builtin_options_as_ReadVariableOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_ReadVariableOptions
             ? static_cast<const circle::ReadVariableOptions *>(builtin_options())
             : nullptr;
  }
  const circle::AssignVariableOptions *builtin_options_as_AssignVariableOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_AssignVariableOptions
             ? static_cast<const circle::AssignVariableOptions *>(builtin_options())
             : nullptr;
  }
  const circle::RandomOptions *builtin_options_as_RandomOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_RandomOptions
             ? static_cast<const circle::RandomOptions *>(builtin_options())
             : nullptr;
  }
  const circle::BCQGatherOptions *builtin_options_as_BCQGatherOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_BCQGatherOptions
             ? static_cast<const circle::BCQGatherOptions *>(builtin_options())
             : nullptr;
  }
  const circle::BCQFullyConnectedOptions *builtin_options_as_BCQFullyConnectedOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_BCQFullyConnectedOptions
             ? static_cast<const circle::BCQFullyConnectedOptions *>(builtin_options())
             : nullptr;
  }
  const circle::InstanceNormOptions *builtin_options_as_InstanceNormOptions() const
  {
    return builtin_options_type() == circle::BuiltinOptions_InstanceNormOptions
             ? static_cast<const circle::InstanceNormOptions *>(builtin_options())
             : nullptr;
  }
  const flatbuffers::Vector<uint8_t> *custom_options() const
  {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CUSTOM_OPTIONS);
  }
  circle::CustomOptionsFormat custom_options_format() const
  {
    return static_cast<circle::CustomOptionsFormat>(GetField<int8_t>(VT_CUSTOM_OPTIONS_FORMAT, 0));
  }
  const flatbuffers::Vector<uint8_t> *mutating_variable_inputs() const
  {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_MUTATING_VARIABLE_INPUTS);
  }
  const flatbuffers::Vector<int32_t> *intermediates() const
  {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INTERMEDIATES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<uint32_t>(verifier, VT_OPCODE_INDEX) &&
           VerifyOffset(verifier, VT_INPUTS) && verifier.VerifyVector(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) && verifier.VerifyVector(outputs()) &&
           VerifyField<uint8_t>(verifier, VT_BUILTIN_OPTIONS_TYPE) &&
           VerifyOffset(verifier, VT_BUILTIN_OPTIONS) &&
           VerifyBuiltinOptions(verifier, builtin_options(), builtin_options_type()) &&
           VerifyOffset(verifier, VT_CUSTOM_OPTIONS) && verifier.VerifyVector(custom_options()) &&
           VerifyField<int8_t>(verifier, VT_CUSTOM_OPTIONS_FORMAT) &&
           VerifyOffset(verifier, VT_MUTATING_VARIABLE_INPUTS) &&
           verifier.VerifyVector(mutating_variable_inputs()) &&
           VerifyOffset(verifier, VT_INTERMEDIATES) && verifier.VerifyVector(intermediates()) &&
           verifier.EndTable();
  }
  OperatorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OperatorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Operator>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const OperatorT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template <>
inline const circle::Conv2DOptions *Operator::builtin_options_as<circle::Conv2DOptions>() const
{
  return builtin_options_as_Conv2DOptions();
}

template <>
inline const circle::DepthwiseConv2DOptions *
Operator::builtin_options_as<circle::DepthwiseConv2DOptions>() const
{
  return builtin_options_as_DepthwiseConv2DOptions();
}

template <>
inline const circle::ConcatEmbeddingsOptions *
Operator::builtin_options_as<circle::ConcatEmbeddingsOptions>() const
{
  return builtin_options_as_ConcatEmbeddingsOptions();
}

template <>
inline const circle::LSHProjectionOptions *
Operator::builtin_options_as<circle::LSHProjectionOptions>() const
{
  return builtin_options_as_LSHProjectionOptions();
}

template <>
inline const circle::Pool2DOptions *Operator::builtin_options_as<circle::Pool2DOptions>() const
{
  return builtin_options_as_Pool2DOptions();
}

template <>
inline const circle::SVDFOptions *Operator::builtin_options_as<circle::SVDFOptions>() const
{
  return builtin_options_as_SVDFOptions();
}

template <>
inline const circle::RNNOptions *Operator::builtin_options_as<circle::RNNOptions>() const
{
  return builtin_options_as_RNNOptions();
}

template <>
inline const circle::FullyConnectedOptions *
Operator::builtin_options_as<circle::FullyConnectedOptions>() const
{
  return builtin_options_as_FullyConnectedOptions();
}

template <>
inline const circle::SoftmaxOptions *Operator::builtin_options_as<circle::SoftmaxOptions>() const
{
  return builtin_options_as_SoftmaxOptions();
}

template <>
inline const circle::ConcatenationOptions *
Operator::builtin_options_as<circle::ConcatenationOptions>() const
{
  return builtin_options_as_ConcatenationOptions();
}

template <>
inline const circle::AddOptions *Operator::builtin_options_as<circle::AddOptions>() const
{
  return builtin_options_as_AddOptions();
}

template <>
inline const circle::L2NormOptions *Operator::builtin_options_as<circle::L2NormOptions>() const
{
  return builtin_options_as_L2NormOptions();
}

template <>
inline const circle::LocalResponseNormalizationOptions *
Operator::builtin_options_as<circle::LocalResponseNormalizationOptions>() const
{
  return builtin_options_as_LocalResponseNormalizationOptions();
}

template <>
inline const circle::LSTMOptions *Operator::builtin_options_as<circle::LSTMOptions>() const
{
  return builtin_options_as_LSTMOptions();
}

template <>
inline const circle::ResizeBilinearOptions *
Operator::builtin_options_as<circle::ResizeBilinearOptions>() const
{
  return builtin_options_as_ResizeBilinearOptions();
}

template <>
inline const circle::CallOptions *Operator::builtin_options_as<circle::CallOptions>() const
{
  return builtin_options_as_CallOptions();
}

template <>
inline const circle::ReshapeOptions *Operator::builtin_options_as<circle::ReshapeOptions>() const
{
  return builtin_options_as_ReshapeOptions();
}

template <>
inline const circle::SkipGramOptions *Operator::builtin_options_as<circle::SkipGramOptions>() const
{
  return builtin_options_as_SkipGramOptions();
}

template <>
inline const circle::SpaceToDepthOptions *
Operator::builtin_options_as<circle::SpaceToDepthOptions>() const
{
  return builtin_options_as_SpaceToDepthOptions();
}

template <>
inline const circle::EmbeddingLookupSparseOptions *
Operator::builtin_options_as<circle::EmbeddingLookupSparseOptions>() const
{
  return builtin_options_as_EmbeddingLookupSparseOptions();
}

template <>
inline const circle::MulOptions *Operator::builtin_options_as<circle::MulOptions>() const
{
  return builtin_options_as_MulOptions();
}

template <>
inline const circle::PadOptions *Operator::builtin_options_as<circle::PadOptions>() const
{
  return builtin_options_as_PadOptions();
}

template <>
inline const circle::GatherOptions *Operator::builtin_options_as<circle::GatherOptions>() const
{
  return builtin_options_as_GatherOptions();
}

template <>
inline const circle::BatchToSpaceNDOptions *
Operator::builtin_options_as<circle::BatchToSpaceNDOptions>() const
{
  return builtin_options_as_BatchToSpaceNDOptions();
}

template <>
inline const circle::SpaceToBatchNDOptions *
Operator::builtin_options_as<circle::SpaceToBatchNDOptions>() const
{
  return builtin_options_as_SpaceToBatchNDOptions();
}

template <>
inline const circle::TransposeOptions *
Operator::builtin_options_as<circle::TransposeOptions>() const
{
  return builtin_options_as_TransposeOptions();
}

template <>
inline const circle::ReducerOptions *Operator::builtin_options_as<circle::ReducerOptions>() const
{
  return builtin_options_as_ReducerOptions();
}

template <>
inline const circle::SubOptions *Operator::builtin_options_as<circle::SubOptions>() const
{
  return builtin_options_as_SubOptions();
}

template <>
inline const circle::DivOptions *Operator::builtin_options_as<circle::DivOptions>() const
{
  return builtin_options_as_DivOptions();
}

template <>
inline const circle::SqueezeOptions *Operator::builtin_options_as<circle::SqueezeOptions>() const
{
  return builtin_options_as_SqueezeOptions();
}

template <>
inline const circle::SequenceRNNOptions *
Operator::builtin_options_as<circle::SequenceRNNOptions>() const
{
  return builtin_options_as_SequenceRNNOptions();
}

template <>
inline const circle::StridedSliceOptions *
Operator::builtin_options_as<circle::StridedSliceOptions>() const
{
  return builtin_options_as_StridedSliceOptions();
}

template <>
inline const circle::ExpOptions *Operator::builtin_options_as<circle::ExpOptions>() const
{
  return builtin_options_as_ExpOptions();
}

template <>
inline const circle::TopKV2Options *Operator::builtin_options_as<circle::TopKV2Options>() const
{
  return builtin_options_as_TopKV2Options();
}

template <>
inline const circle::SplitOptions *Operator::builtin_options_as<circle::SplitOptions>() const
{
  return builtin_options_as_SplitOptions();
}

template <>
inline const circle::LogSoftmaxOptions *
Operator::builtin_options_as<circle::LogSoftmaxOptions>() const
{
  return builtin_options_as_LogSoftmaxOptions();
}

template <>
inline const circle::CastOptions *Operator::builtin_options_as<circle::CastOptions>() const
{
  return builtin_options_as_CastOptions();
}

template <>
inline const circle::DequantizeOptions *
Operator::builtin_options_as<circle::DequantizeOptions>() const
{
  return builtin_options_as_DequantizeOptions();
}

template <>
inline const circle::MaximumMinimumOptions *
Operator::builtin_options_as<circle::MaximumMinimumOptions>() const
{
  return builtin_options_as_MaximumMinimumOptions();
}

template <>
inline const circle::ArgMaxOptions *Operator::builtin_options_as<circle::ArgMaxOptions>() const
{
  return builtin_options_as_ArgMaxOptions();
}

template <>
inline const circle::LessOptions *Operator::builtin_options_as<circle::LessOptions>() const
{
  return builtin_options_as_LessOptions();
}

template <>
inline const circle::NegOptions *Operator::builtin_options_as<circle::NegOptions>() const
{
  return builtin_options_as_NegOptions();
}

template <>
inline const circle::PadV2Options *Operator::builtin_options_as<circle::PadV2Options>() const
{
  return builtin_options_as_PadV2Options();
}

template <>
inline const circle::GreaterOptions *Operator::builtin_options_as<circle::GreaterOptions>() const
{
  return builtin_options_as_GreaterOptions();
}

template <>
inline const circle::GreaterEqualOptions *
Operator::builtin_options_as<circle::GreaterEqualOptions>() const
{
  return builtin_options_as_GreaterEqualOptions();
}

template <>
inline const circle::LessEqualOptions *
Operator::builtin_options_as<circle::LessEqualOptions>() const
{
  return builtin_options_as_LessEqualOptions();
}

template <>
inline const circle::SelectOptions *Operator::builtin_options_as<circle::SelectOptions>() const
{
  return builtin_options_as_SelectOptions();
}

template <>
inline const circle::SliceOptions *Operator::builtin_options_as<circle::SliceOptions>() const
{
  return builtin_options_as_SliceOptions();
}

template <>
inline const circle::TransposeConvOptions *
Operator::builtin_options_as<circle::TransposeConvOptions>() const
{
  return builtin_options_as_TransposeConvOptions();
}

template <>
inline const circle::SparseToDenseOptions *
Operator::builtin_options_as<circle::SparseToDenseOptions>() const
{
  return builtin_options_as_SparseToDenseOptions();
}

template <>
inline const circle::TileOptions *Operator::builtin_options_as<circle::TileOptions>() const
{
  return builtin_options_as_TileOptions();
}

template <>
inline const circle::ExpandDimsOptions *
Operator::builtin_options_as<circle::ExpandDimsOptions>() const
{
  return builtin_options_as_ExpandDimsOptions();
}

template <>
inline const circle::EqualOptions *Operator::builtin_options_as<circle::EqualOptions>() const
{
  return builtin_options_as_EqualOptions();
}

template <>
inline const circle::NotEqualOptions *Operator::builtin_options_as<circle::NotEqualOptions>() const
{
  return builtin_options_as_NotEqualOptions();
}

template <>
inline const circle::ShapeOptions *Operator::builtin_options_as<circle::ShapeOptions>() const
{
  return builtin_options_as_ShapeOptions();
}

template <>
inline const circle::PowOptions *Operator::builtin_options_as<circle::PowOptions>() const
{
  return builtin_options_as_PowOptions();
}

template <>
inline const circle::ArgMinOptions *Operator::builtin_options_as<circle::ArgMinOptions>() const
{
  return builtin_options_as_ArgMinOptions();
}

template <>
inline const circle::FakeQuantOptions *
Operator::builtin_options_as<circle::FakeQuantOptions>() const
{
  return builtin_options_as_FakeQuantOptions();
}

template <>
inline const circle::PackOptions *Operator::builtin_options_as<circle::PackOptions>() const
{
  return builtin_options_as_PackOptions();
}

template <>
inline const circle::LogicalOrOptions *
Operator::builtin_options_as<circle::LogicalOrOptions>() const
{
  return builtin_options_as_LogicalOrOptions();
}

template <>
inline const circle::OneHotOptions *Operator::builtin_options_as<circle::OneHotOptions>() const
{
  return builtin_options_as_OneHotOptions();
}

template <>
inline const circle::LogicalAndOptions *
Operator::builtin_options_as<circle::LogicalAndOptions>() const
{
  return builtin_options_as_LogicalAndOptions();
}

template <>
inline const circle::LogicalNotOptions *
Operator::builtin_options_as<circle::LogicalNotOptions>() const
{
  return builtin_options_as_LogicalNotOptions();
}

template <>
inline const circle::UnpackOptions *Operator::builtin_options_as<circle::UnpackOptions>() const
{
  return builtin_options_as_UnpackOptions();
}

template <>
inline const circle::FloorDivOptions *Operator::builtin_options_as<circle::FloorDivOptions>() const
{
  return builtin_options_as_FloorDivOptions();
}

template <>
inline const circle::SquareOptions *Operator::builtin_options_as<circle::SquareOptions>() const
{
  return builtin_options_as_SquareOptions();
}

template <>
inline const circle::ZerosLikeOptions *
Operator::builtin_options_as<circle::ZerosLikeOptions>() const
{
  return builtin_options_as_ZerosLikeOptions();
}

template <>
inline const circle::FillOptions *Operator::builtin_options_as<circle::FillOptions>() const
{
  return builtin_options_as_FillOptions();
}

template <>
inline const circle::BidirectionalSequenceLSTMOptions *
Operator::builtin_options_as<circle::BidirectionalSequenceLSTMOptions>() const
{
  return builtin_options_as_BidirectionalSequenceLSTMOptions();
}

template <>
inline const circle::BidirectionalSequenceRNNOptions *
Operator::builtin_options_as<circle::BidirectionalSequenceRNNOptions>() const
{
  return builtin_options_as_BidirectionalSequenceRNNOptions();
}

template <>
inline const circle::UnidirectionalSequenceLSTMOptions *
Operator::builtin_options_as<circle::UnidirectionalSequenceLSTMOptions>() const
{
  return builtin_options_as_UnidirectionalSequenceLSTMOptions();
}

template <>
inline const circle::FloorModOptions *Operator::builtin_options_as<circle::FloorModOptions>() const
{
  return builtin_options_as_FloorModOptions();
}

template <>
inline const circle::RangeOptions *Operator::builtin_options_as<circle::RangeOptions>() const
{
  return builtin_options_as_RangeOptions();
}

template <>
inline const circle::ResizeNearestNeighborOptions *
Operator::builtin_options_as<circle::ResizeNearestNeighborOptions>() const
{
  return builtin_options_as_ResizeNearestNeighborOptions();
}

template <>
inline const circle::LeakyReluOptions *
Operator::builtin_options_as<circle::LeakyReluOptions>() const
{
  return builtin_options_as_LeakyReluOptions();
}

template <>
inline const circle::SquaredDifferenceOptions *
Operator::builtin_options_as<circle::SquaredDifferenceOptions>() const
{
  return builtin_options_as_SquaredDifferenceOptions();
}

template <>
inline const circle::MirrorPadOptions *
Operator::builtin_options_as<circle::MirrorPadOptions>() const
{
  return builtin_options_as_MirrorPadOptions();
}

template <>
inline const circle::AbsOptions *Operator::builtin_options_as<circle::AbsOptions>() const
{
  return builtin_options_as_AbsOptions();
}

template <>
inline const circle::SplitVOptions *Operator::builtin_options_as<circle::SplitVOptions>() const
{
  return builtin_options_as_SplitVOptions();
}

template <>
inline const circle::UniqueOptions *Operator::builtin_options_as<circle::UniqueOptions>() const
{
  return builtin_options_as_UniqueOptions();
}

template <>
inline const circle::ReverseV2Options *
Operator::builtin_options_as<circle::ReverseV2Options>() const
{
  return builtin_options_as_ReverseV2Options();
}

template <>
inline const circle::AddNOptions *Operator::builtin_options_as<circle::AddNOptions>() const
{
  return builtin_options_as_AddNOptions();
}

template <>
inline const circle::GatherNdOptions *Operator::builtin_options_as<circle::GatherNdOptions>() const
{
  return builtin_options_as_GatherNdOptions();
}

template <>
inline const circle::CosOptions *Operator::builtin_options_as<circle::CosOptions>() const
{
  return builtin_options_as_CosOptions();
}

template <>
inline const circle::WhereOptions *Operator::builtin_options_as<circle::WhereOptions>() const
{
  return builtin_options_as_WhereOptions();
}

template <>
inline const circle::RankOptions *Operator::builtin_options_as<circle::RankOptions>() const
{
  return builtin_options_as_RankOptions();
}

template <>
inline const circle::ReverseSequenceOptions *
Operator::builtin_options_as<circle::ReverseSequenceOptions>() const
{
  return builtin_options_as_ReverseSequenceOptions();
}

template <>
inline const circle::MatrixDiagOptions *
Operator::builtin_options_as<circle::MatrixDiagOptions>() const
{
  return builtin_options_as_MatrixDiagOptions();
}

template <>
inline const circle::QuantizeOptions *Operator::builtin_options_as<circle::QuantizeOptions>() const
{
  return builtin_options_as_QuantizeOptions();
}

template <>
inline const circle::MatrixSetDiagOptions *
Operator::builtin_options_as<circle::MatrixSetDiagOptions>() const
{
  return builtin_options_as_MatrixSetDiagOptions();
}

template <>
inline const circle::HardSwishOptions *
Operator::builtin_options_as<circle::HardSwishOptions>() const
{
  return builtin_options_as_HardSwishOptions();
}

template <> inline const circle::IfOptions *Operator::builtin_options_as<circle::IfOptions>() const
{
  return builtin_options_as_IfOptions();
}

template <>
inline const circle::WhileOptions *Operator::builtin_options_as<circle::WhileOptions>() const
{
  return builtin_options_as_WhileOptions();
}

template <>
inline const circle::DepthToSpaceOptions *
Operator::builtin_options_as<circle::DepthToSpaceOptions>() const
{
  return builtin_options_as_DepthToSpaceOptions();
}

template <>
inline const circle::NonMaxSuppressionV4Options *
Operator::builtin_options_as<circle::NonMaxSuppressionV4Options>() const
{
  return builtin_options_as_NonMaxSuppressionV4Options();
}

template <>
inline const circle::NonMaxSuppressionV5Options *
Operator::builtin_options_as<circle::NonMaxSuppressionV5Options>() const
{
  return builtin_options_as_NonMaxSuppressionV5Options();
}

template <>
inline const circle::ScatterNdOptions *
Operator::builtin_options_as<circle::ScatterNdOptions>() const
{
  return builtin_options_as_ScatterNdOptions();
}

template <>
inline const circle::SelectV2Options *Operator::builtin_options_as<circle::SelectV2Options>() const
{
  return builtin_options_as_SelectV2Options();
}

template <>
inline const circle::DensifyOptions *Operator::builtin_options_as<circle::DensifyOptions>() const
{
  return builtin_options_as_DensifyOptions();
}

template <>
inline const circle::SegmentSumOptions *
Operator::builtin_options_as<circle::SegmentSumOptions>() const
{
  return builtin_options_as_SegmentSumOptions();
}

template <>
inline const circle::BatchMatMulOptions *
Operator::builtin_options_as<circle::BatchMatMulOptions>() const
{
  return builtin_options_as_BatchMatMulOptions();
}

template <>
inline const circle::CumsumOptions *Operator::builtin_options_as<circle::CumsumOptions>() const
{
  return builtin_options_as_CumsumOptions();
}

template <>
inline const circle::CallOnceOptions *Operator::builtin_options_as<circle::CallOnceOptions>() const
{
  return builtin_options_as_CallOnceOptions();
}

template <>
inline const circle::BroadcastToOptions *
Operator::builtin_options_as<circle::BroadcastToOptions>() const
{
  return builtin_options_as_BroadcastToOptions();
}

template <>
inline const circle::Rfft2dOptions *Operator::builtin_options_as<circle::Rfft2dOptions>() const
{
  return builtin_options_as_Rfft2dOptions();
}

template <>
inline const circle::Conv3DOptions *Operator::builtin_options_as<circle::Conv3DOptions>() const
{
  return builtin_options_as_Conv3DOptions();
}

template <>
inline const circle::HashtableOptions *
Operator::builtin_options_as<circle::HashtableOptions>() const
{
  return builtin_options_as_HashtableOptions();
}

template <>
inline const circle::HashtableFindOptions *
Operator::builtin_options_as<circle::HashtableFindOptions>() const
{
  return builtin_options_as_HashtableFindOptions();
}

template <>
inline const circle::HashtableImportOptions *
Operator::builtin_options_as<circle::HashtableImportOptions>() const
{
  return builtin_options_as_HashtableImportOptions();
}

template <>
inline const circle::HashtableSizeOptions *
Operator::builtin_options_as<circle::HashtableSizeOptions>() const
{
  return builtin_options_as_HashtableSizeOptions();
}

template <>
inline const circle::VarHandleOptions *
Operator::builtin_options_as<circle::VarHandleOptions>() const
{
  return builtin_options_as_VarHandleOptions();
}

template <>
inline const circle::ReadVariableOptions *
Operator::builtin_options_as<circle::ReadVariableOptions>() const
{
  return builtin_options_as_ReadVariableOptions();
}

template <>
inline const circle::AssignVariableOptions *
Operator::builtin_options_as<circle::AssignVariableOptions>() const
{
  return builtin_options_as_AssignVariableOptions();
}

template <>
inline const circle::RandomOptions *Operator::builtin_options_as<circle::RandomOptions>() const
{
  return builtin_options_as_RandomOptions();
}

template <>
inline const circle::BCQGatherOptions *
Operator::builtin_options_as<circle::BCQGatherOptions>() const
{
  return builtin_options_as_BCQGatherOptions();
}

template <>
inline const circle::BCQFullyConnectedOptions *
Operator::builtin_options_as<circle::BCQFullyConnectedOptions>() const
{
  return builtin_options_as_BCQFullyConnectedOptions();
}

template <>
inline const circle::InstanceNormOptions *
Operator::builtin_options_as<circle::InstanceNormOptions>() const
{
  return builtin_options_as_InstanceNormOptions();
}

struct OperatorBuilder
{
  typedef Operator Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_opcode_index(uint32_t opcode_index)
  {
    fbb_.AddElement<uint32_t>(Operator::VT_OPCODE_INDEX, opcode_index, 0);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs)
  {
    fbb_.AddOffset(Operator::VT_INPUTS, inputs);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs)
  {
    fbb_.AddOffset(Operator::VT_OUTPUTS, outputs);
  }
  void add_builtin_options_type(circle::BuiltinOptions builtin_options_type)
  {
    fbb_.AddElement<uint8_t>(Operator::VT_BUILTIN_OPTIONS_TYPE,
                             static_cast<uint8_t>(builtin_options_type), 0);
  }
  void add_builtin_options(flatbuffers::Offset<void> builtin_options)
  {
    fbb_.AddOffset(Operator::VT_BUILTIN_OPTIONS, builtin_options);
  }
  void add_custom_options(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom_options)
  {
    fbb_.AddOffset(Operator::VT_CUSTOM_OPTIONS, custom_options);
  }
  void add_custom_options_format(circle::CustomOptionsFormat custom_options_format)
  {
    fbb_.AddElement<int8_t>(Operator::VT_CUSTOM_OPTIONS_FORMAT,
                            static_cast<int8_t>(custom_options_format), 0);
  }
  void add_mutating_variable_inputs(
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> mutating_variable_inputs)
  {
    fbb_.AddOffset(Operator::VT_MUTATING_VARIABLE_INPUTS, mutating_variable_inputs);
  }
  void add_intermediates(flatbuffers::Offset<flatbuffers::Vector<int32_t>> intermediates)
  {
    fbb_.AddOffset(Operator::VT_INTERMEDIATES, intermediates);
  }
  explicit OperatorBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Operator> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Operator>(end);
    return o;
  }
};

inline flatbuffers::Offset<Operator> CreateOperator(
  flatbuffers::FlatBufferBuilder &_fbb, uint32_t opcode_index = 0,
  flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs = 0,
  flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs = 0,
  circle::BuiltinOptions builtin_options_type = circle::BuiltinOptions_NONE,
  flatbuffers::Offset<void> builtin_options = 0,
  flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom_options = 0,
  circle::CustomOptionsFormat custom_options_format = circle::CustomOptionsFormat_FLEXBUFFERS,
  flatbuffers::Offset<flatbuffers::Vector<uint8_t>> mutating_variable_inputs = 0,
  flatbuffers::Offset<flatbuffers::Vector<int32_t>> intermediates = 0)
{
  OperatorBuilder builder_(_fbb);
  builder_.add_intermediates(intermediates);
  builder_.add_mutating_variable_inputs(mutating_variable_inputs);
  builder_.add_custom_options(custom_options);
  builder_.add_builtin_options(builtin_options);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_opcode_index(opcode_index);
  builder_.add_custom_options_format(custom_options_format);
  builder_.add_builtin_options_type(builtin_options_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Operator> CreateOperatorDirect(
  flatbuffers::FlatBufferBuilder &_fbb, uint32_t opcode_index = 0,
  const std::vector<int32_t> *inputs = nullptr, const std::vector<int32_t> *outputs = nullptr,
  circle::BuiltinOptions builtin_options_type = circle::BuiltinOptions_NONE,
  flatbuffers::Offset<void> builtin_options = 0,
  const std::vector<uint8_t> *custom_options = nullptr,
  circle::CustomOptionsFormat custom_options_format = circle::CustomOptionsFormat_FLEXBUFFERS,
  const std::vector<uint8_t> *mutating_variable_inputs = nullptr,
  const std::vector<int32_t> *intermediates = nullptr)
{
  auto inputs__ = inputs ? _fbb.CreateVector<int32_t>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<int32_t>(*outputs) : 0;
  auto custom_options__ = custom_options ? _fbb.CreateVector<uint8_t>(*custom_options) : 0;
  auto mutating_variable_inputs__ =
    mutating_variable_inputs ? _fbb.CreateVector<uint8_t>(*mutating_variable_inputs) : 0;
  auto intermediates__ = intermediates ? _fbb.CreateVector<int32_t>(*intermediates) : 0;
  return circle::CreateOperator(_fbb, opcode_index, inputs__, outputs__, builtin_options_type,
                                builtin_options, custom_options__, custom_options_format,
                                mutating_variable_inputs__, intermediates__);
}

flatbuffers::Offset<Operator>
CreateOperator(flatbuffers::FlatBufferBuilder &_fbb, const OperatorT *_o,
               const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SubGraphT : public flatbuffers::NativeTable
{
  typedef SubGraph TableType;
  std::vector<std::unique_ptr<circle::TensorT>> tensors{};
  std::vector<int32_t> inputs{};
  std::vector<int32_t> outputs{};
  std::vector<std::unique_ptr<circle::OperatorT>> operators{};
  std::string name{};
  circle::DataFormat data_format = circle::DataFormat_CHANNELS_LAST;
};

struct SubGraph FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef SubGraphT NativeTableType;
  typedef SubGraphBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_TENSORS = 4,
    VT_INPUTS = 6,
    VT_OUTPUTS = 8,
    VT_OPERATORS = 10,
    VT_NAME = 12,
    VT_DATA_FORMAT = 14
  };
  const flatbuffers::Vector<flatbuffers::Offset<circle::Tensor>> *tensors() const
  {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<circle::Tensor>> *>(VT_TENSORS);
  }
  const flatbuffers::Vector<int32_t> *inputs() const
  {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INPUTS);
  }
  const flatbuffers::Vector<int32_t> *outputs() const
  {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_OUTPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<circle::Operator>> *operators() const
  {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<circle::Operator>> *>(
      VT_OPERATORS);
  }
  const flatbuffers::String *name() const
  {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  circle::DataFormat data_format() const
  {
    return static_cast<circle::DataFormat>(GetField<int8_t>(VT_DATA_FORMAT, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_TENSORS) &&
           verifier.VerifyVector(tensors()) && verifier.VerifyVectorOfTables(tensors()) &&
           VerifyOffset(verifier, VT_INPUTS) && verifier.VerifyVector(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) && verifier.VerifyVector(outputs()) &&
           VerifyOffset(verifier, VT_OPERATORS) && verifier.VerifyVector(operators()) &&
           verifier.VerifyVectorOfTables(operators()) && VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) && VerifyField<int8_t>(verifier, VT_DATA_FORMAT) &&
           verifier.EndTable();
  }
  SubGraphT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SubGraphT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SubGraph>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SubGraphBuilder
{
  typedef SubGraph Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void
  add_tensors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<circle::Tensor>>> tensors)
  {
    fbb_.AddOffset(SubGraph::VT_TENSORS, tensors);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs)
  {
    fbb_.AddOffset(SubGraph::VT_INPUTS, inputs);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs)
  {
    fbb_.AddOffset(SubGraph::VT_OUTPUTS, outputs);
  }
  void add_operators(
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<circle::Operator>>> operators)
  {
    fbb_.AddOffset(SubGraph::VT_OPERATORS, operators);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name)
  {
    fbb_.AddOffset(SubGraph::VT_NAME, name);
  }
  void add_data_format(circle::DataFormat data_format)
  {
    fbb_.AddElement<int8_t>(SubGraph::VT_DATA_FORMAT, static_cast<int8_t>(data_format), 0);
  }
  explicit SubGraphBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SubGraph> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SubGraph>(end);
    return o;
  }
};

inline flatbuffers::Offset<SubGraph> CreateSubGraph(
  flatbuffers::FlatBufferBuilder &_fbb,
  flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<circle::Tensor>>> tensors = 0,
  flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs = 0,
  flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs = 0,
  flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<circle::Operator>>> operators = 0,
  flatbuffers::Offset<flatbuffers::String> name = 0,
  circle::DataFormat data_format = circle::DataFormat_CHANNELS_LAST)
{
  SubGraphBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_operators(operators);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_tensors(tensors);
  builder_.add_data_format(data_format);
  return builder_.Finish();
}

inline flatbuffers::Offset<SubGraph> CreateSubGraphDirect(
  flatbuffers::FlatBufferBuilder &_fbb,
  const std::vector<flatbuffers::Offset<circle::Tensor>> *tensors = nullptr,
  const std::vector<int32_t> *inputs = nullptr, const std::vector<int32_t> *outputs = nullptr,
  const std::vector<flatbuffers::Offset<circle::Operator>> *operators = nullptr,
  const char *name = nullptr, circle::DataFormat data_format = circle::DataFormat_CHANNELS_LAST)
{
  auto tensors__ = tensors ? _fbb.CreateVector<flatbuffers::Offset<circle::Tensor>>(*tensors) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<int32_t>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<int32_t>(*outputs) : 0;
  auto operators__ =
    operators ? _fbb.CreateVector<flatbuffers::Offset<circle::Operator>>(*operators) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return circle::CreateSubGraph(_fbb, tensors__, inputs__, outputs__, operators__, name__,
                                data_format);
}

flatbuffers::Offset<SubGraph>
CreateSubGraph(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT *_o,
               const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BufferT : public flatbuffers::NativeTable
{
  typedef Buffer TableType;
  std::vector<uint8_t> data{};
};

struct Buffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef BufferT NativeTableType;
  typedef BufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_DATA = 4
  };
  const flatbuffers::Vector<uint8_t> *data() const
  {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) && verifier.EndTable();
  }
  BufferT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BufferT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Buffer>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const BufferT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BufferBuilder
{
  typedef Buffer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data)
  {
    fbb_.AddOffset(Buffer::VT_DATA, data);
  }
  explicit BufferBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Buffer> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Buffer>(end);
    return o;
  }
};

inline flatbuffers::Offset<Buffer>
CreateBuffer(flatbuffers::FlatBufferBuilder &_fbb,
             flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0)
{
  BufferBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<Buffer> CreateBufferDirect(flatbuffers::FlatBufferBuilder &_fbb,
                                                      const std::vector<uint8_t> *data = nullptr)
{
  if (data)
  {
    _fbb.ForceVectorAlignment(data->size(), sizeof(uint8_t), 16);
  }
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return circle::CreateBuffer(_fbb, data__);
}

flatbuffers::Offset<Buffer>
CreateBuffer(flatbuffers::FlatBufferBuilder &_fbb, const BufferT *_o,
             const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MetadataT : public flatbuffers::NativeTable
{
  typedef Metadata TableType;
  std::string name{};
  uint32_t buffer = 0;
};

struct Metadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef MetadataT NativeTableType;
  typedef MetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_NAME = 4,
    VT_BUFFER = 6
  };
  const flatbuffers::String *name() const
  {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t buffer() const { return GetField<uint32_t>(VT_BUFFER, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) && VerifyField<uint32_t>(verifier, VT_BUFFER) &&
           verifier.EndTable();
  }
  MetadataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MetadataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Metadata>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const MetadataT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MetadataBuilder
{
  typedef Metadata Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name)
  {
    fbb_.AddOffset(Metadata::VT_NAME, name);
  }
  void add_buffer(uint32_t buffer) { fbb_.AddElement<uint32_t>(Metadata::VT_BUFFER, buffer, 0); }
  explicit MetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Metadata> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Metadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<Metadata>
CreateMetadata(flatbuffers::FlatBufferBuilder &_fbb,
               flatbuffers::Offset<flatbuffers::String> name = 0, uint32_t buffer = 0)
{
  MetadataBuilder builder_(_fbb);
  builder_.add_buffer(buffer);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Metadata> CreateMetadataDirect(flatbuffers::FlatBufferBuilder &_fbb,
                                                          const char *name = nullptr,
                                                          uint32_t buffer = 0)
{
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return circle::CreateMetadata(_fbb, name__, buffer);
}

flatbuffers::Offset<Metadata>
CreateMetadata(flatbuffers::FlatBufferBuilder &_fbb, const MetadataT *_o,
               const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TensorMapT : public flatbuffers::NativeTable
{
  typedef TensorMap TableType;
  std::string name{};
  uint32_t tensor_index = 0;
};

struct TensorMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef TensorMapT NativeTableType;
  typedef TensorMapBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_NAME = 4,
    VT_TENSOR_INDEX = 6
  };
  const flatbuffers::String *name() const
  {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t tensor_index() const { return GetField<uint32_t>(VT_TENSOR_INDEX, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) && VerifyField<uint32_t>(verifier, VT_TENSOR_INDEX) &&
           verifier.EndTable();
  }
  TensorMapT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TensorMapT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TensorMap>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorMapT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorMapBuilder
{
  typedef TensorMap Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name)
  {
    fbb_.AddOffset(TensorMap::VT_NAME, name);
  }
  void add_tensor_index(uint32_t tensor_index)
  {
    fbb_.AddElement<uint32_t>(TensorMap::VT_TENSOR_INDEX, tensor_index, 0);
  }
  explicit TensorMapBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TensorMap> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorMap>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorMap>
CreateTensorMap(flatbuffers::FlatBufferBuilder &_fbb,
                flatbuffers::Offset<flatbuffers::String> name = 0, uint32_t tensor_index = 0)
{
  TensorMapBuilder builder_(_fbb);
  builder_.add_tensor_index(tensor_index);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<TensorMap> CreateTensorMapDirect(flatbuffers::FlatBufferBuilder &_fbb,
                                                            const char *name = nullptr,
                                                            uint32_t tensor_index = 0)
{
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return circle::CreateTensorMap(_fbb, name__, tensor_index);
}

flatbuffers::Offset<TensorMap>
CreateTensorMap(flatbuffers::FlatBufferBuilder &_fbb, const TensorMapT *_o,
                const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SignatureDefT : public flatbuffers::NativeTable
{
  typedef SignatureDef TableType;
  std::vector<std::unique_ptr<circle::TensorMapT>> inputs{};
  std::vector<std::unique_ptr<circle::TensorMapT>> outputs{};
  std::string signature_key{};
  uint32_t subgraph_index = 0;
};

struct SignatureDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef SignatureDefT NativeTableType;
  typedef SignatureDefBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_INPUTS = 4,
    VT_OUTPUTS = 6,
    VT_SIGNATURE_KEY = 8,
    VT_SUBGRAPH_INDEX = 12
  };
  const flatbuffers::Vector<flatbuffers::Offset<circle::TensorMap>> *inputs() const
  {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<circle::TensorMap>> *>(
      VT_INPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<circle::TensorMap>> *outputs() const
  {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<circle::TensorMap>> *>(
      VT_OUTPUTS);
  }
  const flatbuffers::String *signature_key() const
  {
    return GetPointer<const flatbuffers::String *>(VT_SIGNATURE_KEY);
  }
  uint32_t subgraph_index() const { return GetField<uint32_t>(VT_SUBGRAPH_INDEX, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) && verifier.VerifyVectorOfTables(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) && verifier.VerifyVector(outputs()) &&
           verifier.VerifyVectorOfTables(outputs()) && VerifyOffset(verifier, VT_SIGNATURE_KEY) &&
           verifier.VerifyString(signature_key()) &&
           VerifyField<uint32_t>(verifier, VT_SUBGRAPH_INDEX) && verifier.EndTable();
  }
  SignatureDefT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SignatureDefT *_o,
                const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SignatureDef>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const SignatureDefT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SignatureDefBuilder
{
  typedef SignatureDef Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_inputs(
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<circle::TensorMap>>> inputs)
  {
    fbb_.AddOffset(SignatureDef::VT_INPUTS, inputs);
  }
  void add_outputs(
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<circle::TensorMap>>> outputs)
  {
    fbb_.AddOffset(SignatureDef::VT_OUTPUTS, outputs);
  }
  void add_signature_key(flatbuffers::Offset<flatbuffers::String> signature_key)
  {
    fbb_.AddOffset(SignatureDef::VT_SIGNATURE_KEY, signature_key);
  }
  void add_subgraph_index(uint32_t subgraph_index)
  {
    fbb_.AddElement<uint32_t>(SignatureDef::VT_SUBGRAPH_INDEX, subgraph_index, 0);
  }
  explicit SignatureDefBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SignatureDef> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SignatureDef>(end);
    return o;
  }
};

inline flatbuffers::Offset<SignatureDef> CreateSignatureDef(
  flatbuffers::FlatBufferBuilder &_fbb,
  flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<circle::TensorMap>>> inputs = 0,
  flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<circle::TensorMap>>> outputs = 0,
  flatbuffers::Offset<flatbuffers::String> signature_key = 0, uint32_t subgraph_index = 0)
{
  SignatureDefBuilder builder_(_fbb);
  builder_.add_subgraph_index(subgraph_index);
  builder_.add_signature_key(signature_key);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  return builder_.Finish();
}

inline flatbuffers::Offset<SignatureDef> CreateSignatureDefDirect(
  flatbuffers::FlatBufferBuilder &_fbb,
  const std::vector<flatbuffers::Offset<circle::TensorMap>> *inputs = nullptr,
  const std::vector<flatbuffers::Offset<circle::TensorMap>> *outputs = nullptr,
  const char *signature_key = nullptr, uint32_t subgraph_index = 0)
{
  auto inputs__ = inputs ? _fbb.CreateVector<flatbuffers::Offset<circle::TensorMap>>(*inputs) : 0;
  auto outputs__ =
    outputs ? _fbb.CreateVector<flatbuffers::Offset<circle::TensorMap>>(*outputs) : 0;
  auto signature_key__ = signature_key ? _fbb.CreateString(signature_key) : 0;
  return circle::CreateSignatureDef(_fbb, inputs__, outputs__, signature_key__, subgraph_index);
}

flatbuffers::Offset<SignatureDef>
CreateSignatureDef(flatbuffers::FlatBufferBuilder &_fbb, const SignatureDefT *_o,
                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ModelT : public flatbuffers::NativeTable
{
  typedef Model TableType;
  uint32_t version = 0;
  std::vector<std::unique_ptr<circle::OperatorCodeT>> operator_codes{};
  std::vector<std::unique_ptr<circle::SubGraphT>> subgraphs{};
  std::string description{};
  std::vector<std::unique_ptr<circle::BufferT>> buffers{};
  std::vector<int32_t> metadata_buffer{};
  std::vector<std::unique_ptr<circle::MetadataT>> metadata{};
  std::vector<std::unique_ptr<circle::SignatureDefT>> signature_defs{};
};

struct Model FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
  typedef ModelT NativeTableType;
  typedef ModelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_VERSION = 4,
    VT_OPERATOR_CODES = 6,
    VT_SUBGRAPHS = 8,
    VT_DESCRIPTION = 10,
    VT_BUFFERS = 12,
    VT_METADATA_BUFFER = 14,
    VT_METADATA = 16,
    VT_SIGNATURE_DEFS = 18
  };
  uint32_t version() const { return GetField<uint32_t>(VT_VERSION, 0); }
  const flatbuffers::Vector<flatbuffers::Offset<circle::OperatorCode>> *operator_codes() const
  {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<circle::OperatorCode>> *>(
      VT_OPERATOR_CODES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<circle::SubGraph>> *subgraphs() const
  {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<circle::SubGraph>> *>(
      VT_SUBGRAPHS);
  }
  const flatbuffers::String *description() const
  {
    return GetPointer<const flatbuffers::String *>(VT_DESCRIPTION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<circle::Buffer>> *buffers() const
  {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<circle::Buffer>> *>(VT_BUFFERS);
  }
  const flatbuffers::Vector<int32_t> *metadata_buffer() const
  {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_METADATA_BUFFER);
  }
  const flatbuffers::Vector<flatbuffers::Offset<circle::Metadata>> *metadata() const
  {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<circle::Metadata>> *>(
      VT_METADATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<circle::SignatureDef>> *signature_defs() const
  {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<circle::SignatureDef>> *>(
      VT_SIGNATURE_DEFS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const
  {
    return VerifyTableStart(verifier) && VerifyField<uint32_t>(verifier, VT_VERSION) &&
           VerifyOffset(verifier, VT_OPERATOR_CODES) && verifier.VerifyVector(operator_codes()) &&
           verifier.VerifyVectorOfTables(operator_codes()) &&
           VerifyOffset(verifier, VT_SUBGRAPHS) && verifier.VerifyVector(subgraphs()) &&
           verifier.VerifyVectorOfTables(subgraphs()) && VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) && VerifyOffset(verifier, VT_BUFFERS) &&
           verifier.VerifyVector(buffers()) && verifier.VerifyVectorOfTables(buffers()) &&
           VerifyOffset(verifier, VT_METADATA_BUFFER) && verifier.VerifyVector(metadata_buffer()) &&
           VerifyOffset(verifier, VT_METADATA) && verifier.VerifyVector(metadata()) &&
           verifier.VerifyVectorOfTables(metadata()) && VerifyOffset(verifier, VT_SIGNATURE_DEFS) &&
           verifier.VerifyVector(signature_defs()) &&
           verifier.VerifyVectorOfTables(signature_defs()) && verifier.EndTable();
  }
  ModelT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ModelT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Model>
  Pack(flatbuffers::FlatBufferBuilder &_fbb, const ModelT *_o,
       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ModelBuilder
{
  typedef Model Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(uint32_t version) { fbb_.AddElement<uint32_t>(Model::VT_VERSION, version, 0); }
  void add_operator_codes(
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<circle::OperatorCode>>>
      operator_codes)
  {
    fbb_.AddOffset(Model::VT_OPERATOR_CODES, operator_codes);
  }
  void add_subgraphs(
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<circle::SubGraph>>> subgraphs)
  {
    fbb_.AddOffset(Model::VT_SUBGRAPHS, subgraphs);
  }
  void add_description(flatbuffers::Offset<flatbuffers::String> description)
  {
    fbb_.AddOffset(Model::VT_DESCRIPTION, description);
  }
  void
  add_buffers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<circle::Buffer>>> buffers)
  {
    fbb_.AddOffset(Model::VT_BUFFERS, buffers);
  }
  void add_metadata_buffer(flatbuffers::Offset<flatbuffers::Vector<int32_t>> metadata_buffer)
  {
    fbb_.AddOffset(Model::VT_METADATA_BUFFER, metadata_buffer);
  }
  void add_metadata(
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<circle::Metadata>>> metadata)
  {
    fbb_.AddOffset(Model::VT_METADATA, metadata);
  }
  void add_signature_defs(
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<circle::SignatureDef>>>
      signature_defs)
  {
    fbb_.AddOffset(Model::VT_SIGNATURE_DEFS, signature_defs);
  }
  explicit ModelBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Model> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Model>(end);
    return o;
  }
};

inline flatbuffers::Offset<Model> CreateModel(
  flatbuffers::FlatBufferBuilder &_fbb, uint32_t version = 0,
  flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<circle::OperatorCode>>>
    operator_codes = 0,
  flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<circle::SubGraph>>> subgraphs = 0,
  flatbuffers::Offset<flatbuffers::String> description = 0,
  flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<circle::Buffer>>> buffers = 0,
  flatbuffers::Offset<flatbuffers::Vector<int32_t>> metadata_buffer = 0,
  flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<circle::Metadata>>> metadata = 0,
  flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<circle::SignatureDef>>>
    signature_defs = 0)
{
  ModelBuilder builder_(_fbb);
  builder_.add_signature_defs(signature_defs);
  builder_.add_metadata(metadata);
  builder_.add_metadata_buffer(metadata_buffer);
  builder_.add_buffers(buffers);
  builder_.add_description(description);
  builder_.add_subgraphs(subgraphs);
  builder_.add_operator_codes(operator_codes);
  builder_.add_version(version);
  return builder_.Finish();
}

inline flatbuffers::Offset<Model> CreateModelDirect(
  flatbuffers::FlatBufferBuilder &_fbb, uint32_t version = 0,
  const std::vector<flatbuffers::Offset<circle::OperatorCode>> *operator_codes = nullptr,
  const std::vector<flatbuffers::Offset<circle::SubGraph>> *subgraphs = nullptr,
  const char *description = nullptr,
  const std::vector<flatbuffers::Offset<circle::Buffer>> *buffers = nullptr,
  const std::vector<int32_t> *metadata_buffer = nullptr,
  const std::vector<flatbuffers::Offset<circle::Metadata>> *metadata = nullptr,
  const std::vector<flatbuffers::Offset<circle::SignatureDef>> *signature_defs = nullptr)
{
  auto operator_codes__ =
    operator_codes ? _fbb.CreateVector<flatbuffers::Offset<circle::OperatorCode>>(*operator_codes)
                   : 0;
  auto subgraphs__ =
    subgraphs ? _fbb.CreateVector<flatbuffers::Offset<circle::SubGraph>>(*subgraphs) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto buffers__ = buffers ? _fbb.CreateVector<flatbuffers::Offset<circle::Buffer>>(*buffers) : 0;
  auto metadata_buffer__ = metadata_buffer ? _fbb.CreateVector<int32_t>(*metadata_buffer) : 0;
  auto metadata__ =
    metadata ? _fbb.CreateVector<flatbuffers::Offset<circle::Metadata>>(*metadata) : 0;
  auto signature_defs__ =
    signature_defs ? _fbb.CreateVector<flatbuffers::Offset<circle::SignatureDef>>(*signature_defs)
                   : 0;
  return circle::CreateModel(_fbb, version, operator_codes__, subgraphs__, description__, buffers__,
                             metadata_buffer__, metadata__, signature_defs__);
}

flatbuffers::Offset<Model> CreateModel(flatbuffers::FlatBufferBuilder &_fbb, const ModelT *_o,
                                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline CustomQuantizationT *
CustomQuantization::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<CustomQuantizationT>(new CustomQuantizationT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CustomQuantization::UnPackTo(CustomQuantizationT *_o,
                                         const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = custom();
    if (_e)
    {
      _o->custom.resize(_e->size());
      std::copy(_e->begin(), _e->end(), _o->custom.begin());
    }
  }
}

inline flatbuffers::Offset<CustomQuantization>
CustomQuantization::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CustomQuantizationT *_o,
                         const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateCustomQuantization(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CustomQuantization>
CreateCustomQuantization(flatbuffers::FlatBufferBuilder &_fbb, const CustomQuantizationT *_o,
                         const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const CustomQuantizationT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  _fbb.ForceVectorAlignment(_o->custom.size(), sizeof(uint8_t), 16);
  auto _custom = _o->custom.size() ? _fbb.CreateVector(_o->custom) : 0;
  return circle::CreateCustomQuantization(_fbb, _custom);
}

inline QuantizationParametersT *
QuantizationParameters::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<QuantizationParametersT>(new QuantizationParametersT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void
QuantizationParameters::UnPackTo(QuantizationParametersT *_o,
                                 const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = min();
    if (_e)
    {
      _o->min.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
      {
        _o->min[_i] = _e->Get(_i);
      }
    }
  }
  {
    auto _e = max();
    if (_e)
    {
      _o->max.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
      {
        _o->max[_i] = _e->Get(_i);
      }
    }
  }
  {
    auto _e = scale();
    if (_e)
    {
      _o->scale.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
      {
        _o->scale[_i] = _e->Get(_i);
      }
    }
  }
  {
    auto _e = zero_point();
    if (_e)
    {
      _o->zero_point.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
      {
        _o->zero_point[_i] = _e->Get(_i);
      }
    }
  }
  {
    auto _e = details_type();
    _o->details.type = _e;
  }
  {
    auto _e = details();
    if (_e)
      _o->details.value = circle::QuantizationDetailsUnion::UnPack(_e, details_type(), _resolver);
  }
  {
    auto _e = quantized_dimension();
    _o->quantized_dimension = _e;
  }
}

inline flatbuffers::Offset<QuantizationParameters>
QuantizationParameters::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                             const QuantizationParametersT *_o,
                             const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateQuantizationParameters(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<QuantizationParameters>
CreateQuantizationParameters(flatbuffers::FlatBufferBuilder &_fbb,
                             const QuantizationParametersT *_o,
                             const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const QuantizationParametersT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _min = _o->min.size() ? _fbb.CreateVector(_o->min) : 0;
  auto _max = _o->max.size() ? _fbb.CreateVector(_o->max) : 0;
  auto _scale = _o->scale.size() ? _fbb.CreateVector(_o->scale) : 0;
  auto _zero_point = _o->zero_point.size() ? _fbb.CreateVector(_o->zero_point) : 0;
  auto _details_type = _o->details.type;
  auto _details = _o->details.Pack(_fbb);
  auto _quantized_dimension = _o->quantized_dimension;
  return circle::CreateQuantizationParameters(_fbb, _min, _max, _scale, _zero_point, _details_type,
                                              _details, _quantized_dimension);
}

inline Int32VectorT *Int32Vector::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<Int32VectorT>(new Int32VectorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Int32Vector::UnPackTo(Int32VectorT *_o,
                                  const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = values();
    if (_e)
    {
      _o->values.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
      {
        _o->values[_i] = _e->Get(_i);
      }
    }
  }
}

inline flatbuffers::Offset<Int32Vector>
Int32Vector::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Int32VectorT *_o,
                  const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateInt32Vector(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Int32Vector>
CreateInt32Vector(flatbuffers::FlatBufferBuilder &_fbb, const Int32VectorT *_o,
                  const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const Int32VectorT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _values = _o->values.size() ? _fbb.CreateVector(_o->values) : 0;
  return circle::CreateInt32Vector(_fbb, _values);
}

inline Uint16VectorT *Uint16Vector::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<Uint16VectorT>(new Uint16VectorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Uint16Vector::UnPackTo(Uint16VectorT *_o,
                                   const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = values();
    if (_e)
    {
      _o->values.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
      {
        _o->values[_i] = _e->Get(_i);
      }
    }
  }
}

inline flatbuffers::Offset<Uint16Vector>
Uint16Vector::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Uint16VectorT *_o,
                   const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateUint16Vector(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Uint16Vector>
CreateUint16Vector(flatbuffers::FlatBufferBuilder &_fbb, const Uint16VectorT *_o,
                   const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const Uint16VectorT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  _fbb.ForceVectorAlignment(_o->values.size(), sizeof(uint16_t), 4);
  auto _values = _o->values.size() ? _fbb.CreateVector(_o->values) : 0;
  return circle::CreateUint16Vector(_fbb, _values);
}

inline Uint8VectorT *Uint8Vector::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<Uint8VectorT>(new Uint8VectorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Uint8Vector::UnPackTo(Uint8VectorT *_o,
                                  const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = values();
    if (_e)
    {
      _o->values.resize(_e->size());
      std::copy(_e->begin(), _e->end(), _o->values.begin());
    }
  }
}

inline flatbuffers::Offset<Uint8Vector>
Uint8Vector::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Uint8VectorT *_o,
                  const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateUint8Vector(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Uint8Vector>
CreateUint8Vector(flatbuffers::FlatBufferBuilder &_fbb, const Uint8VectorT *_o,
                  const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const Uint8VectorT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  _fbb.ForceVectorAlignment(_o->values.size(), sizeof(uint8_t), 4);
  auto _values = _o->values.size() ? _fbb.CreateVector(_o->values) : 0;
  return circle::CreateUint8Vector(_fbb, _values);
}

inline DimensionMetadataT *
DimensionMetadata::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<DimensionMetadataT>(new DimensionMetadataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DimensionMetadata::UnPackTo(DimensionMetadataT *_o,
                                        const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = format();
    _o->format = _e;
  }
  {
    auto _e = dense_size();
    _o->dense_size = _e;
  }
  {
    auto _e = array_segments_type();
    _o->array_segments.type = _e;
  }
  {
    auto _e = array_segments();
    if (_e)
      _o->array_segments.value =
        circle::SparseIndexVectorUnion::UnPack(_e, array_segments_type(), _resolver);
  }
  {
    auto _e = array_indices_type();
    _o->array_indices.type = _e;
  }
  {
    auto _e = array_indices();
    if (_e)
      _o->array_indices.value =
        circle::SparseIndexVectorUnion::UnPack(_e, array_indices_type(), _resolver);
  }
}

inline flatbuffers::Offset<DimensionMetadata>
DimensionMetadata::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DimensionMetadataT *_o,
                        const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateDimensionMetadata(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DimensionMetadata>
CreateDimensionMetadata(flatbuffers::FlatBufferBuilder &_fbb, const DimensionMetadataT *_o,
                        const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const DimensionMetadataT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _format = _o->format;
  auto _dense_size = _o->dense_size;
  auto _array_segments_type = _o->array_segments.type;
  auto _array_segments = _o->array_segments.Pack(_fbb);
  auto _array_indices_type = _o->array_indices.type;
  auto _array_indices = _o->array_indices.Pack(_fbb);
  return circle::CreateDimensionMetadata(_fbb, _format, _dense_size, _array_segments_type,
                                         _array_segments, _array_indices_type, _array_indices);
}

inline SparsityParametersT *
SparsityParameters::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<SparsityParametersT>(new SparsityParametersT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SparsityParameters::UnPackTo(SparsityParametersT *_o,
                                         const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = traversal_order();
    if (_e)
    {
      _o->traversal_order.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
      {
        _o->traversal_order[_i] = _e->Get(_i);
      }
    }
  }
  {
    auto _e = block_map();
    if (_e)
    {
      _o->block_map.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
      {
        _o->block_map[_i] = _e->Get(_i);
      }
    }
  }
  {
    auto _e = dim_metadata();
    if (_e)
    {
      _o->dim_metadata.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
      {
        _o->dim_metadata[_i] =
          std::unique_ptr<circle::DimensionMetadataT>(_e->Get(_i)->UnPack(_resolver));
      }
    }
  }
}

inline flatbuffers::Offset<SparsityParameters>
SparsityParameters::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SparsityParametersT *_o,
                         const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateSparsityParameters(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SparsityParameters>
CreateSparsityParameters(flatbuffers::FlatBufferBuilder &_fbb, const SparsityParametersT *_o,
                         const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const SparsityParametersT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _traversal_order = _o->traversal_order.size() ? _fbb.CreateVector(_o->traversal_order) : 0;
  auto _block_map = _o->block_map.size() ? _fbb.CreateVector(_o->block_map) : 0;
  auto _dim_metadata = _o->dim_metadata.size()
                         ? _fbb.CreateVector<flatbuffers::Offset<circle::DimensionMetadata>>(
                             _o->dim_metadata.size(),
                             [](size_t i, _VectorArgs *__va) {
                               return CreateDimensionMetadata(
                                 *__va->__fbb, __va->__o->dim_metadata[i].get(), __va->__rehasher);
                             },
                             &_va)
                         : 0;
  return circle::CreateSparsityParameters(_fbb, _traversal_order, _block_map, _dim_metadata);
}

inline TensorT *Tensor::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<TensorT>(new TensorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Tensor::UnPackTo(TensorT *_o, const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = shape();
    if (_e)
    {
      _o->shape.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
      {
        _o->shape[_i] = _e->Get(_i);
      }
    }
  }
  {
    auto _e = type();
    _o->type = _e;
  }
  {
    auto _e = buffer();
    _o->buffer = _e;
  }
  {
    auto _e = name();
    if (_e)
      _o->name = _e->str();
  }
  {
    auto _e = quantization();
    if (_e)
      _o->quantization = std::unique_ptr<circle::QuantizationParametersT>(_e->UnPack(_resolver));
  }
  {
    auto _e = is_variable();
    _o->is_variable = _e;
  }
  {
    auto _e = sparsity();
    if (_e)
      _o->sparsity = std::unique_ptr<circle::SparsityParametersT>(_e->UnPack(_resolver));
  }
  {
    auto _e = shape_signature();
    if (_e)
    {
      _o->shape_signature.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
      {
        _o->shape_signature[_i] = _e->Get(_i);
      }
    }
  }
}

inline flatbuffers::Offset<Tensor> Tensor::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                const TensorT *_o,
                                                const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateTensor(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Tensor> CreateTensor(flatbuffers::FlatBufferBuilder &_fbb,
                                                const TensorT *_o,
                                                const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const TensorT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _shape = _o->shape.size() ? _fbb.CreateVector(_o->shape) : 0;
  auto _type = _o->type;
  auto _buffer = _o->buffer;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _quantization =
    _o->quantization ? CreateQuantizationParameters(_fbb, _o->quantization.get(), _rehasher) : 0;
  auto _is_variable = _o->is_variable;
  auto _sparsity = _o->sparsity ? CreateSparsityParameters(_fbb, _o->sparsity.get(), _rehasher) : 0;
  auto _shape_signature = _o->shape_signature.size() ? _fbb.CreateVector(_o->shape_signature) : 0;
  return circle::CreateTensor(_fbb, _shape, _type, _buffer, _name, _quantization, _is_variable,
                              _sparsity, _shape_signature);
}

inline Conv2DOptionsT *
Conv2DOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<Conv2DOptionsT>(new Conv2DOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Conv2DOptions::UnPackTo(Conv2DOptionsT *_o,
                                    const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = padding();
    _o->padding = _e;
  }
  {
    auto _e = stride_w();
    _o->stride_w = _e;
  }
  {
    auto _e = stride_h();
    _o->stride_h = _e;
  }
  {
    auto _e = fused_activation_function();
    _o->fused_activation_function = _e;
  }
  {
    auto _e = dilation_w_factor();
    _o->dilation_w_factor = _e;
  }
  {
    auto _e = dilation_h_factor();
    _o->dilation_h_factor = _e;
  }
}

inline flatbuffers::Offset<Conv2DOptions>
Conv2DOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateConv2DOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Conv2DOptions>
CreateConv2DOptions(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const Conv2DOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _padding = _o->padding;
  auto _stride_w = _o->stride_w;
  auto _stride_h = _o->stride_h;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _dilation_w_factor = _o->dilation_w_factor;
  auto _dilation_h_factor = _o->dilation_h_factor;
  return circle::CreateConv2DOptions(_fbb, _padding, _stride_w, _stride_h,
                                     _fused_activation_function, _dilation_w_factor,
                                     _dilation_h_factor);
}

inline Conv3DOptionsT *
Conv3DOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<Conv3DOptionsT>(new Conv3DOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Conv3DOptions::UnPackTo(Conv3DOptionsT *_o,
                                    const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = padding();
    _o->padding = _e;
  }
  {
    auto _e = stride_d();
    _o->stride_d = _e;
  }
  {
    auto _e = stride_w();
    _o->stride_w = _e;
  }
  {
    auto _e = stride_h();
    _o->stride_h = _e;
  }
  {
    auto _e = fused_activation_function();
    _o->fused_activation_function = _e;
  }
  {
    auto _e = dilation_d_factor();
    _o->dilation_d_factor = _e;
  }
  {
    auto _e = dilation_w_factor();
    _o->dilation_w_factor = _e;
  }
  {
    auto _e = dilation_h_factor();
    _o->dilation_h_factor = _e;
  }
}

inline flatbuffers::Offset<Conv3DOptions>
Conv3DOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv3DOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateConv3DOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Conv3DOptions>
CreateConv3DOptions(flatbuffers::FlatBufferBuilder &_fbb, const Conv3DOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const Conv3DOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _padding = _o->padding;
  auto _stride_d = _o->stride_d;
  auto _stride_w = _o->stride_w;
  auto _stride_h = _o->stride_h;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _dilation_d_factor = _o->dilation_d_factor;
  auto _dilation_w_factor = _o->dilation_w_factor;
  auto _dilation_h_factor = _o->dilation_h_factor;
  return circle::CreateConv3DOptions(_fbb, _padding, _stride_d, _stride_w, _stride_h,
                                     _fused_activation_function, _dilation_d_factor,
                                     _dilation_w_factor, _dilation_h_factor);
}

inline Pool2DOptionsT *
Pool2DOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<Pool2DOptionsT>(new Pool2DOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Pool2DOptions::UnPackTo(Pool2DOptionsT *_o,
                                    const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = padding();
    _o->padding = _e;
  }
  {
    auto _e = stride_w();
    _o->stride_w = _e;
  }
  {
    auto _e = stride_h();
    _o->stride_h = _e;
  }
  {
    auto _e = filter_width();
    _o->filter_width = _e;
  }
  {
    auto _e = filter_height();
    _o->filter_height = _e;
  }
  {
    auto _e = fused_activation_function();
    _o->fused_activation_function = _e;
  }
}

inline flatbuffers::Offset<Pool2DOptions>
Pool2DOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Pool2DOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreatePool2DOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Pool2DOptions>
CreatePool2DOptions(flatbuffers::FlatBufferBuilder &_fbb, const Pool2DOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const Pool2DOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _padding = _o->padding;
  auto _stride_w = _o->stride_w;
  auto _stride_h = _o->stride_h;
  auto _filter_width = _o->filter_width;
  auto _filter_height = _o->filter_height;
  auto _fused_activation_function = _o->fused_activation_function;
  return circle::CreatePool2DOptions(_fbb, _padding, _stride_w, _stride_h, _filter_width,
                                     _filter_height, _fused_activation_function);
}

inline DepthwiseConv2DOptionsT *
DepthwiseConv2DOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<DepthwiseConv2DOptionsT>(new DepthwiseConv2DOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void
DepthwiseConv2DOptions::UnPackTo(DepthwiseConv2DOptionsT *_o,
                                 const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = padding();
    _o->padding = _e;
  }
  {
    auto _e = stride_w();
    _o->stride_w = _e;
  }
  {
    auto _e = stride_h();
    _o->stride_h = _e;
  }
  {
    auto _e = depth_multiplier();
    _o->depth_multiplier = _e;
  }
  {
    auto _e = fused_activation_function();
    _o->fused_activation_function = _e;
  }
  {
    auto _e = dilation_w_factor();
    _o->dilation_w_factor = _e;
  }
  {
    auto _e = dilation_h_factor();
    _o->dilation_h_factor = _e;
  }
}

inline flatbuffers::Offset<DepthwiseConv2DOptions>
DepthwiseConv2DOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                             const DepthwiseConv2DOptionsT *_o,
                             const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateDepthwiseConv2DOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DepthwiseConv2DOptions>
CreateDepthwiseConv2DOptions(flatbuffers::FlatBufferBuilder &_fbb,
                             const DepthwiseConv2DOptionsT *_o,
                             const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const DepthwiseConv2DOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _padding = _o->padding;
  auto _stride_w = _o->stride_w;
  auto _stride_h = _o->stride_h;
  auto _depth_multiplier = _o->depth_multiplier;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _dilation_w_factor = _o->dilation_w_factor;
  auto _dilation_h_factor = _o->dilation_h_factor;
  return circle::CreateDepthwiseConv2DOptions(_fbb, _padding, _stride_w, _stride_h,
                                              _depth_multiplier, _fused_activation_function,
                                              _dilation_w_factor, _dilation_h_factor);
}

inline ConcatEmbeddingsOptionsT *
ConcatEmbeddingsOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<ConcatEmbeddingsOptionsT>(new ConcatEmbeddingsOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void
ConcatEmbeddingsOptions::UnPackTo(ConcatEmbeddingsOptionsT *_o,
                                  const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = num_channels();
    _o->num_channels = _e;
  }
  {
    auto _e = num_columns_per_channel();
    if (_e)
    {
      _o->num_columns_per_channel.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
      {
        _o->num_columns_per_channel[_i] = _e->Get(_i);
      }
    }
  }
  {
    auto _e = embedding_dim_per_channel();
    if (_e)
    {
      _o->embedding_dim_per_channel.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
      {
        _o->embedding_dim_per_channel[_i] = _e->Get(_i);
      }
    }
  }
}

inline flatbuffers::Offset<ConcatEmbeddingsOptions>
ConcatEmbeddingsOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                              const ConcatEmbeddingsOptionsT *_o,
                              const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateConcatEmbeddingsOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ConcatEmbeddingsOptions>
CreateConcatEmbeddingsOptions(flatbuffers::FlatBufferBuilder &_fbb,
                              const ConcatEmbeddingsOptionsT *_o,
                              const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const ConcatEmbeddingsOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _num_channels = _o->num_channels;
  auto _num_columns_per_channel =
    _o->num_columns_per_channel.size() ? _fbb.CreateVector(_o->num_columns_per_channel) : 0;
  auto _embedding_dim_per_channel =
    _o->embedding_dim_per_channel.size() ? _fbb.CreateVector(_o->embedding_dim_per_channel) : 0;
  return circle::CreateConcatEmbeddingsOptions(_fbb, _num_channels, _num_columns_per_channel,
                                               _embedding_dim_per_channel);
}

inline LSHProjectionOptionsT *
LSHProjectionOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<LSHProjectionOptionsT>(new LSHProjectionOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LSHProjectionOptions::UnPackTo(LSHProjectionOptionsT *_o,
                                           const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = type();
    _o->type = _e;
  }
}

inline flatbuffers::Offset<LSHProjectionOptions>
LSHProjectionOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSHProjectionOptionsT *_o,
                           const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateLSHProjectionOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LSHProjectionOptions>
CreateLSHProjectionOptions(flatbuffers::FlatBufferBuilder &_fbb, const LSHProjectionOptionsT *_o,
                           const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const LSHProjectionOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _type = _o->type;
  return circle::CreateLSHProjectionOptions(_fbb, _type);
}

inline SVDFOptionsT *SVDFOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<SVDFOptionsT>(new SVDFOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SVDFOptions::UnPackTo(SVDFOptionsT *_o,
                                  const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = rank();
    _o->rank = _e;
  }
  {
    auto _e = fused_activation_function();
    _o->fused_activation_function = _e;
  }
  {
    auto _e = asymmetric_quantize_inputs();
    _o->asymmetric_quantize_inputs = _e;
  }
}

inline flatbuffers::Offset<SVDFOptions>
SVDFOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SVDFOptionsT *_o,
                  const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateSVDFOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SVDFOptions>
CreateSVDFOptions(flatbuffers::FlatBufferBuilder &_fbb, const SVDFOptionsT *_o,
                  const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const SVDFOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _rank = _o->rank;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
  return circle::CreateSVDFOptions(_fbb, _rank, _fused_activation_function,
                                   _asymmetric_quantize_inputs);
}

inline RNNOptionsT *RNNOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<RNNOptionsT>(new RNNOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RNNOptions::UnPackTo(RNNOptionsT *_o,
                                 const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = fused_activation_function();
    _o->fused_activation_function = _e;
  }
  {
    auto _e = asymmetric_quantize_inputs();
    _o->asymmetric_quantize_inputs = _e;
  }
}

inline flatbuffers::Offset<RNNOptions>
RNNOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RNNOptionsT *_o,
                 const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateRNNOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RNNOptions>
CreateRNNOptions(flatbuffers::FlatBufferBuilder &_fbb, const RNNOptionsT *_o,
                 const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const RNNOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
  return circle::CreateRNNOptions(_fbb, _fused_activation_function, _asymmetric_quantize_inputs);
}

inline SequenceRNNOptionsT *
SequenceRNNOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<SequenceRNNOptionsT>(new SequenceRNNOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SequenceRNNOptions::UnPackTo(SequenceRNNOptionsT *_o,
                                         const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = time_major();
    _o->time_major = _e;
  }
  {
    auto _e = fused_activation_function();
    _o->fused_activation_function = _e;
  }
  {
    auto _e = asymmetric_quantize_inputs();
    _o->asymmetric_quantize_inputs = _e;
  }
}

inline flatbuffers::Offset<SequenceRNNOptions>
SequenceRNNOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SequenceRNNOptionsT *_o,
                         const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateSequenceRNNOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SequenceRNNOptions>
CreateSequenceRNNOptions(flatbuffers::FlatBufferBuilder &_fbb, const SequenceRNNOptionsT *_o,
                         const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const SequenceRNNOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _time_major = _o->time_major;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
  return circle::CreateSequenceRNNOptions(_fbb, _time_major, _fused_activation_function,
                                          _asymmetric_quantize_inputs);
}

inline BidirectionalSequenceRNNOptionsT *
BidirectionalSequenceRNNOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o =
    std::unique_ptr<BidirectionalSequenceRNNOptionsT>(new BidirectionalSequenceRNNOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void
BidirectionalSequenceRNNOptions::UnPackTo(BidirectionalSequenceRNNOptionsT *_o,
                                          const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = time_major();
    _o->time_major = _e;
  }
  {
    auto _e = fused_activation_function();
    _o->fused_activation_function = _e;
  }
  {
    auto _e = merge_outputs();
    _o->merge_outputs = _e;
  }
  {
    auto _e = asymmetric_quantize_inputs();
    _o->asymmetric_quantize_inputs = _e;
  }
}

inline flatbuffers::Offset<BidirectionalSequenceRNNOptions>
BidirectionalSequenceRNNOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                      const BidirectionalSequenceRNNOptionsT *_o,
                                      const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateBidirectionalSequenceRNNOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BidirectionalSequenceRNNOptions>
CreateBidirectionalSequenceRNNOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                      const BidirectionalSequenceRNNOptionsT *_o,
                                      const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const BidirectionalSequenceRNNOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _time_major = _o->time_major;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _merge_outputs = _o->merge_outputs;
  auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
  return circle::CreateBidirectionalSequenceRNNOptions(
    _fbb, _time_major, _fused_activation_function, _merge_outputs, _asymmetric_quantize_inputs);
}

inline FullyConnectedOptionsT *
FullyConnectedOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<FullyConnectedOptionsT>(new FullyConnectedOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FullyConnectedOptions::UnPackTo(FullyConnectedOptionsT *_o,
                                            const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = fused_activation_function();
    _o->fused_activation_function = _e;
  }
  {
    auto _e = weights_format();
    _o->weights_format = _e;
  }
  {
    auto _e = keep_num_dims();
    _o->keep_num_dims = _e;
  }
  {
    auto _e = asymmetric_quantize_inputs();
    _o->asymmetric_quantize_inputs = _e;
  }
}

inline flatbuffers::Offset<FullyConnectedOptions>
FullyConnectedOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FullyConnectedOptionsT *_o,
                            const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateFullyConnectedOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FullyConnectedOptions>
CreateFullyConnectedOptions(flatbuffers::FlatBufferBuilder &_fbb, const FullyConnectedOptionsT *_o,
                            const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const FullyConnectedOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _weights_format = _o->weights_format;
  auto _keep_num_dims = _o->keep_num_dims;
  auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
  return circle::CreateFullyConnectedOptions(_fbb, _fused_activation_function, _weights_format,
                                             _keep_num_dims, _asymmetric_quantize_inputs);
}

inline SoftmaxOptionsT *
SoftmaxOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<SoftmaxOptionsT>(new SoftmaxOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SoftmaxOptions::UnPackTo(SoftmaxOptionsT *_o,
                                     const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = beta();
    _o->beta = _e;
  }
}

inline flatbuffers::Offset<SoftmaxOptions>
SoftmaxOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxOptionsT *_o,
                     const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateSoftmaxOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SoftmaxOptions>
CreateSoftmaxOptions(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxOptionsT *_o,
                     const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const SoftmaxOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _beta = _o->beta;
  return circle::CreateSoftmaxOptions(_fbb, _beta);
}

inline ConcatenationOptionsT *
ConcatenationOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<ConcatenationOptionsT>(new ConcatenationOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ConcatenationOptions::UnPackTo(ConcatenationOptionsT *_o,
                                           const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = axis();
    _o->axis = _e;
  }
  {
    auto _e = fused_activation_function();
    _o->fused_activation_function = _e;
  }
}

inline flatbuffers::Offset<ConcatenationOptions>
ConcatenationOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConcatenationOptionsT *_o,
                           const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateConcatenationOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ConcatenationOptions>
CreateConcatenationOptions(flatbuffers::FlatBufferBuilder &_fbb, const ConcatenationOptionsT *_o,
                           const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const ConcatenationOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _axis = _o->axis;
  auto _fused_activation_function = _o->fused_activation_function;
  return circle::CreateConcatenationOptions(_fbb, _axis, _fused_activation_function);
}

inline AddOptionsT *AddOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<AddOptionsT>(new AddOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AddOptions::UnPackTo(AddOptionsT *_o,
                                 const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = fused_activation_function();
    _o->fused_activation_function = _e;
  }
  {
    auto _e = pot_scale_int16();
    _o->pot_scale_int16 = _e;
  }
}

inline flatbuffers::Offset<AddOptions>
AddOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddOptionsT *_o,
                 const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateAddOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AddOptions>
CreateAddOptions(flatbuffers::FlatBufferBuilder &_fbb, const AddOptionsT *_o,
                 const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const AddOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _pot_scale_int16 = _o->pot_scale_int16;
  return circle::CreateAddOptions(_fbb, _fused_activation_function, _pot_scale_int16);
}

inline MulOptionsT *MulOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<MulOptionsT>(new MulOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MulOptions::UnPackTo(MulOptionsT *_o,
                                 const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = fused_activation_function();
    _o->fused_activation_function = _e;
  }
}

inline flatbuffers::Offset<MulOptions>
MulOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MulOptionsT *_o,
                 const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateMulOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MulOptions>
CreateMulOptions(flatbuffers::FlatBufferBuilder &_fbb, const MulOptionsT *_o,
                 const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const MulOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  return circle::CreateMulOptions(_fbb, _fused_activation_function);
}

inline L2NormOptionsT *
L2NormOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<L2NormOptionsT>(new L2NormOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void L2NormOptions::UnPackTo(L2NormOptionsT *_o,
                                    const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = fused_activation_function();
    _o->fused_activation_function = _e;
  }
}

inline flatbuffers::Offset<L2NormOptions>
L2NormOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const L2NormOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateL2NormOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<L2NormOptions>
CreateL2NormOptions(flatbuffers::FlatBufferBuilder &_fbb, const L2NormOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const L2NormOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  return circle::CreateL2NormOptions(_fbb, _fused_activation_function);
}

inline LocalResponseNormalizationOptionsT *
LocalResponseNormalizationOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o =
    std::unique_ptr<LocalResponseNormalizationOptionsT>(new LocalResponseNormalizationOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void
LocalResponseNormalizationOptions::UnPackTo(LocalResponseNormalizationOptionsT *_o,
                                            const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = radius();
    _o->radius = _e;
  }
  {
    auto _e = bias();
    _o->bias = _e;
  }
  {
    auto _e = alpha();
    _o->alpha = _e;
  }
  {
    auto _e = beta();
    _o->beta = _e;
  }
}

inline flatbuffers::Offset<LocalResponseNormalizationOptions>
LocalResponseNormalizationOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                        const LocalResponseNormalizationOptionsT *_o,
                                        const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateLocalResponseNormalizationOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LocalResponseNormalizationOptions>
CreateLocalResponseNormalizationOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                        const LocalResponseNormalizationOptionsT *_o,
                                        const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const LocalResponseNormalizationOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _radius = _o->radius;
  auto _bias = _o->bias;
  auto _alpha = _o->alpha;
  auto _beta = _o->beta;
  return circle::CreateLocalResponseNormalizationOptions(_fbb, _radius, _bias, _alpha, _beta);
}

inline LSTMOptionsT *LSTMOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<LSTMOptionsT>(new LSTMOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LSTMOptions::UnPackTo(LSTMOptionsT *_o,
                                  const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = fused_activation_function();
    _o->fused_activation_function = _e;
  }
  {
    auto _e = cell_clip();
    _o->cell_clip = _e;
  }
  {
    auto _e = proj_clip();
    _o->proj_clip = _e;
  }
  {
    auto _e = kernel_type();
    _o->kernel_type = _e;
  }
  {
    auto _e = asymmetric_quantize_inputs();
    _o->asymmetric_quantize_inputs = _e;
  }
}

inline flatbuffers::Offset<LSTMOptions>
LSTMOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSTMOptionsT *_o,
                  const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateLSTMOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LSTMOptions>
CreateLSTMOptions(flatbuffers::FlatBufferBuilder &_fbb, const LSTMOptionsT *_o,
                  const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const LSTMOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _cell_clip = _o->cell_clip;
  auto _proj_clip = _o->proj_clip;
  auto _kernel_type = _o->kernel_type;
  auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
  return circle::CreateLSTMOptions(_fbb, _fused_activation_function, _cell_clip, _proj_clip,
                                   _kernel_type, _asymmetric_quantize_inputs);
}

inline UnidirectionalSequenceLSTMOptionsT *
UnidirectionalSequenceLSTMOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o =
    std::unique_ptr<UnidirectionalSequenceLSTMOptionsT>(new UnidirectionalSequenceLSTMOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void
UnidirectionalSequenceLSTMOptions::UnPackTo(UnidirectionalSequenceLSTMOptionsT *_o,
                                            const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = fused_activation_function();
    _o->fused_activation_function = _e;
  }
  {
    auto _e = cell_clip();
    _o->cell_clip = _e;
  }
  {
    auto _e = proj_clip();
    _o->proj_clip = _e;
  }
  {
    auto _e = time_major();
    _o->time_major = _e;
  }
  {
    auto _e = asymmetric_quantize_inputs();
    _o->asymmetric_quantize_inputs = _e;
  }
}

inline flatbuffers::Offset<UnidirectionalSequenceLSTMOptions>
UnidirectionalSequenceLSTMOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                        const UnidirectionalSequenceLSTMOptionsT *_o,
                                        const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateUnidirectionalSequenceLSTMOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UnidirectionalSequenceLSTMOptions>
CreateUnidirectionalSequenceLSTMOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                        const UnidirectionalSequenceLSTMOptionsT *_o,
                                        const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const UnidirectionalSequenceLSTMOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _cell_clip = _o->cell_clip;
  auto _proj_clip = _o->proj_clip;
  auto _time_major = _o->time_major;
  auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
  return circle::CreateUnidirectionalSequenceLSTMOptions(_fbb, _fused_activation_function,
                                                         _cell_clip, _proj_clip, _time_major,
                                                         _asymmetric_quantize_inputs);
}

inline BidirectionalSequenceLSTMOptionsT *
BidirectionalSequenceLSTMOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o =
    std::unique_ptr<BidirectionalSequenceLSTMOptionsT>(new BidirectionalSequenceLSTMOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void
BidirectionalSequenceLSTMOptions::UnPackTo(BidirectionalSequenceLSTMOptionsT *_o,
                                           const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = fused_activation_function();
    _o->fused_activation_function = _e;
  }
  {
    auto _e = cell_clip();
    _o->cell_clip = _e;
  }
  {
    auto _e = proj_clip();
    _o->proj_clip = _e;
  }
  {
    auto _e = merge_outputs();
    _o->merge_outputs = _e;
  }
  {
    auto _e = time_major();
    _o->time_major = _e;
  }
  {
    auto _e = asymmetric_quantize_inputs();
    _o->asymmetric_quantize_inputs = _e;
  }
}

inline flatbuffers::Offset<BidirectionalSequenceLSTMOptions>
BidirectionalSequenceLSTMOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                       const BidirectionalSequenceLSTMOptionsT *_o,
                                       const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateBidirectionalSequenceLSTMOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BidirectionalSequenceLSTMOptions>
CreateBidirectionalSequenceLSTMOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                       const BidirectionalSequenceLSTMOptionsT *_o,
                                       const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const BidirectionalSequenceLSTMOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _cell_clip = _o->cell_clip;
  auto _proj_clip = _o->proj_clip;
  auto _merge_outputs = _o->merge_outputs;
  auto _time_major = _o->time_major;
  auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
  return circle::CreateBidirectionalSequenceLSTMOptions(_fbb, _fused_activation_function,
                                                        _cell_clip, _proj_clip, _merge_outputs,
                                                        _time_major, _asymmetric_quantize_inputs);
}

inline ResizeBilinearOptionsT *
ResizeBilinearOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<ResizeBilinearOptionsT>(new ResizeBilinearOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ResizeBilinearOptions::UnPackTo(ResizeBilinearOptionsT *_o,
                                            const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = align_corners();
    _o->align_corners = _e;
  }
  {
    auto _e = half_pixel_centers();
    _o->half_pixel_centers = _e;
  }
}

inline flatbuffers::Offset<ResizeBilinearOptions>
ResizeBilinearOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResizeBilinearOptionsT *_o,
                            const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateResizeBilinearOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ResizeBilinearOptions>
CreateResizeBilinearOptions(flatbuffers::FlatBufferBuilder &_fbb, const ResizeBilinearOptionsT *_o,
                            const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const ResizeBilinearOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _align_corners = _o->align_corners;
  auto _half_pixel_centers = _o->half_pixel_centers;
  return circle::CreateResizeBilinearOptions(_fbb, _align_corners, _half_pixel_centers);
}

inline ResizeNearestNeighborOptionsT *
ResizeNearestNeighborOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<ResizeNearestNeighborOptionsT>(new ResizeNearestNeighborOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void
ResizeNearestNeighborOptions::UnPackTo(ResizeNearestNeighborOptionsT *_o,
                                       const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = align_corners();
    _o->align_corners = _e;
  }
  {
    auto _e = half_pixel_centers();
    _o->half_pixel_centers = _e;
  }
}

inline flatbuffers::Offset<ResizeNearestNeighborOptions>
ResizeNearestNeighborOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                   const ResizeNearestNeighborOptionsT *_o,
                                   const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateResizeNearestNeighborOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ResizeNearestNeighborOptions>
CreateResizeNearestNeighborOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                   const ResizeNearestNeighborOptionsT *_o,
                                   const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const ResizeNearestNeighborOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _align_corners = _o->align_corners;
  auto _half_pixel_centers = _o->half_pixel_centers;
  return circle::CreateResizeNearestNeighborOptions(_fbb, _align_corners, _half_pixel_centers);
}

inline CallOptionsT *CallOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<CallOptionsT>(new CallOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CallOptions::UnPackTo(CallOptionsT *_o,
                                  const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = subgraph();
    _o->subgraph = _e;
  }
}

inline flatbuffers::Offset<CallOptions>
CallOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CallOptionsT *_o,
                  const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateCallOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CallOptions>
CreateCallOptions(flatbuffers::FlatBufferBuilder &_fbb, const CallOptionsT *_o,
                  const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const CallOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _subgraph = _o->subgraph;
  return circle::CreateCallOptions(_fbb, _subgraph);
}

inline PadOptionsT *PadOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<PadOptionsT>(new PadOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PadOptions::UnPackTo(PadOptionsT *_o,
                                 const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<PadOptions>
PadOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PadOptionsT *_o,
                 const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreatePadOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PadOptions>
CreatePadOptions(flatbuffers::FlatBufferBuilder &_fbb, const PadOptionsT *_o,
                 const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const PadOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreatePadOptions(_fbb);
}

inline PadV2OptionsT *PadV2Options::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<PadV2OptionsT>(new PadV2OptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PadV2Options::UnPackTo(PadV2OptionsT *_o,
                                   const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<PadV2Options>
PadV2Options::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PadV2OptionsT *_o,
                   const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreatePadV2Options(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PadV2Options>
CreatePadV2Options(flatbuffers::FlatBufferBuilder &_fbb, const PadV2OptionsT *_o,
                   const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const PadV2OptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreatePadV2Options(_fbb);
}

inline ReshapeOptionsT *
ReshapeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<ReshapeOptionsT>(new ReshapeOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReshapeOptions::UnPackTo(ReshapeOptionsT *_o,
                                     const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = new_shape();
    if (_e)
    {
      _o->new_shape.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
      {
        _o->new_shape[_i] = _e->Get(_i);
      }
    }
  }
}

inline flatbuffers::Offset<ReshapeOptions>
ReshapeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeOptionsT *_o,
                     const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateReshapeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReshapeOptions>
CreateReshapeOptions(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeOptionsT *_o,
                     const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const ReshapeOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _new_shape = _o->new_shape.size() ? _fbb.CreateVector(_o->new_shape) : 0;
  return circle::CreateReshapeOptions(_fbb, _new_shape);
}

inline SpaceToBatchNDOptionsT *
SpaceToBatchNDOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<SpaceToBatchNDOptionsT>(new SpaceToBatchNDOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SpaceToBatchNDOptions::UnPackTo(SpaceToBatchNDOptionsT *_o,
                                            const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SpaceToBatchNDOptions>
SpaceToBatchNDOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDOptionsT *_o,
                            const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateSpaceToBatchNDOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SpaceToBatchNDOptions>
CreateSpaceToBatchNDOptions(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDOptionsT *_o,
                            const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const SpaceToBatchNDOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateSpaceToBatchNDOptions(_fbb);
}

inline BatchToSpaceNDOptionsT *
BatchToSpaceNDOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<BatchToSpaceNDOptionsT>(new BatchToSpaceNDOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BatchToSpaceNDOptions::UnPackTo(BatchToSpaceNDOptionsT *_o,
                                            const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<BatchToSpaceNDOptions>
BatchToSpaceNDOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDOptionsT *_o,
                            const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateBatchToSpaceNDOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BatchToSpaceNDOptions>
CreateBatchToSpaceNDOptions(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDOptionsT *_o,
                            const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const BatchToSpaceNDOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateBatchToSpaceNDOptions(_fbb);
}

inline SkipGramOptionsT *
SkipGramOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<SkipGramOptionsT>(new SkipGramOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SkipGramOptions::UnPackTo(SkipGramOptionsT *_o,
                                      const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = ngram_size();
    _o->ngram_size = _e;
  }
  {
    auto _e = max_skip_size();
    _o->max_skip_size = _e;
  }
  {
    auto _e = include_all_ngrams();
    _o->include_all_ngrams = _e;
  }
}

inline flatbuffers::Offset<SkipGramOptions>
SkipGramOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SkipGramOptionsT *_o,
                      const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateSkipGramOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SkipGramOptions>
CreateSkipGramOptions(flatbuffers::FlatBufferBuilder &_fbb, const SkipGramOptionsT *_o,
                      const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const SkipGramOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _ngram_size = _o->ngram_size;
  auto _max_skip_size = _o->max_skip_size;
  auto _include_all_ngrams = _o->include_all_ngrams;
  return circle::CreateSkipGramOptions(_fbb, _ngram_size, _max_skip_size, _include_all_ngrams);
}

inline SpaceToDepthOptionsT *
SpaceToDepthOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<SpaceToDepthOptionsT>(new SpaceToDepthOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SpaceToDepthOptions::UnPackTo(SpaceToDepthOptionsT *_o,
                                          const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = block_size();
    _o->block_size = _e;
  }
}

inline flatbuffers::Offset<SpaceToDepthOptions>
SpaceToDepthOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthOptionsT *_o,
                          const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateSpaceToDepthOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SpaceToDepthOptions>
CreateSpaceToDepthOptions(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthOptionsT *_o,
                          const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const SpaceToDepthOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _block_size = _o->block_size;
  return circle::CreateSpaceToDepthOptions(_fbb, _block_size);
}

inline DepthToSpaceOptionsT *
DepthToSpaceOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<DepthToSpaceOptionsT>(new DepthToSpaceOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DepthToSpaceOptions::UnPackTo(DepthToSpaceOptionsT *_o,
                                          const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = block_size();
    _o->block_size = _e;
  }
}

inline flatbuffers::Offset<DepthToSpaceOptions>
DepthToSpaceOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DepthToSpaceOptionsT *_o,
                          const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateDepthToSpaceOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DepthToSpaceOptions>
CreateDepthToSpaceOptions(flatbuffers::FlatBufferBuilder &_fbb, const DepthToSpaceOptionsT *_o,
                          const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const DepthToSpaceOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _block_size = _o->block_size;
  return circle::CreateDepthToSpaceOptions(_fbb, _block_size);
}

inline SubOptionsT *SubOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<SubOptionsT>(new SubOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SubOptions::UnPackTo(SubOptionsT *_o,
                                 const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = fused_activation_function();
    _o->fused_activation_function = _e;
  }
  {
    auto _e = pot_scale_int16();
    _o->pot_scale_int16 = _e;
  }
}

inline flatbuffers::Offset<SubOptions>
SubOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubOptionsT *_o,
                 const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateSubOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SubOptions>
CreateSubOptions(flatbuffers::FlatBufferBuilder &_fbb, const SubOptionsT *_o,
                 const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const SubOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _pot_scale_int16 = _o->pot_scale_int16;
  return circle::CreateSubOptions(_fbb, _fused_activation_function, _pot_scale_int16);
}

inline DivOptionsT *DivOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<DivOptionsT>(new DivOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DivOptions::UnPackTo(DivOptionsT *_o,
                                 const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = fused_activation_function();
    _o->fused_activation_function = _e;
  }
}

inline flatbuffers::Offset<DivOptions>
DivOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DivOptionsT *_o,
                 const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateDivOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DivOptions>
CreateDivOptions(flatbuffers::FlatBufferBuilder &_fbb, const DivOptionsT *_o,
                 const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const DivOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  return circle::CreateDivOptions(_fbb, _fused_activation_function);
}

inline TopKV2OptionsT *
TopKV2Options::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<TopKV2OptionsT>(new TopKV2OptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TopKV2Options::UnPackTo(TopKV2OptionsT *_o,
                                    const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<TopKV2Options>
TopKV2Options::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TopKV2OptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateTopKV2Options(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TopKV2Options>
CreateTopKV2Options(flatbuffers::FlatBufferBuilder &_fbb, const TopKV2OptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const TopKV2OptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateTopKV2Options(_fbb);
}

inline EmbeddingLookupSparseOptionsT *
EmbeddingLookupSparseOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<EmbeddingLookupSparseOptionsT>(new EmbeddingLookupSparseOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void
EmbeddingLookupSparseOptions::UnPackTo(EmbeddingLookupSparseOptionsT *_o,
                                       const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = combiner();
    _o->combiner = _e;
  }
}

inline flatbuffers::Offset<EmbeddingLookupSparseOptions>
EmbeddingLookupSparseOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                   const EmbeddingLookupSparseOptionsT *_o,
                                   const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateEmbeddingLookupSparseOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EmbeddingLookupSparseOptions>
CreateEmbeddingLookupSparseOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                   const EmbeddingLookupSparseOptionsT *_o,
                                   const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const EmbeddingLookupSparseOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _combiner = _o->combiner;
  return circle::CreateEmbeddingLookupSparseOptions(_fbb, _combiner);
}

inline GatherOptionsT *
GatherOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<GatherOptionsT>(new GatherOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GatherOptions::UnPackTo(GatherOptionsT *_o,
                                    const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = axis();
    _o->axis = _e;
  }
  {
    auto _e = batch_dims();
    _o->batch_dims = _e;
  }
}

inline flatbuffers::Offset<GatherOptions>
GatherOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateGatherOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GatherOptions>
CreateGatherOptions(flatbuffers::FlatBufferBuilder &_fbb, const GatherOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const GatherOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _axis = _o->axis;
  auto _batch_dims = _o->batch_dims;
  return circle::CreateGatherOptions(_fbb, _axis, _batch_dims);
}

inline TransposeOptionsT *
TransposeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<TransposeOptionsT>(new TransposeOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TransposeOptions::UnPackTo(TransposeOptionsT *_o,
                                       const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<TransposeOptions>
TransposeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransposeOptionsT *_o,
                       const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateTransposeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TransposeOptions>
CreateTransposeOptions(flatbuffers::FlatBufferBuilder &_fbb, const TransposeOptionsT *_o,
                       const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const TransposeOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateTransposeOptions(_fbb);
}

inline ExpOptionsT *ExpOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<ExpOptionsT>(new ExpOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ExpOptions::UnPackTo(ExpOptionsT *_o,
                                 const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ExpOptions>
ExpOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionsT *_o,
                 const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateExpOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ExpOptions>
CreateExpOptions(flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionsT *_o,
                 const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const ExpOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateExpOptions(_fbb);
}

inline CosOptionsT *CosOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<CosOptionsT>(new CosOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CosOptions::UnPackTo(CosOptionsT *_o,
                                 const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<CosOptions>
CosOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CosOptionsT *_o,
                 const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateCosOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CosOptions>
CreateCosOptions(flatbuffers::FlatBufferBuilder &_fbb, const CosOptionsT *_o,
                 const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const CosOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateCosOptions(_fbb);
}

inline ReducerOptionsT *
ReducerOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<ReducerOptionsT>(new ReducerOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReducerOptions::UnPackTo(ReducerOptionsT *_o,
                                     const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = keep_dims();
    _o->keep_dims = _e;
  }
}

inline flatbuffers::Offset<ReducerOptions>
ReducerOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReducerOptionsT *_o,
                     const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateReducerOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReducerOptions>
CreateReducerOptions(flatbuffers::FlatBufferBuilder &_fbb, const ReducerOptionsT *_o,
                     const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const ReducerOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _keep_dims = _o->keep_dims;
  return circle::CreateReducerOptions(_fbb, _keep_dims);
}

inline SqueezeOptionsT *
SqueezeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<SqueezeOptionsT>(new SqueezeOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SqueezeOptions::UnPackTo(SqueezeOptionsT *_o,
                                     const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = squeeze_dims();
    if (_e)
    {
      _o->squeeze_dims.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
      {
        _o->squeeze_dims[_i] = _e->Get(_i);
      }
    }
  }
}

inline flatbuffers::Offset<SqueezeOptions>
SqueezeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeOptionsT *_o,
                     const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateSqueezeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SqueezeOptions>
CreateSqueezeOptions(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeOptionsT *_o,
                     const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const SqueezeOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _squeeze_dims = _o->squeeze_dims.size() ? _fbb.CreateVector(_o->squeeze_dims) : 0;
  return circle::CreateSqueezeOptions(_fbb, _squeeze_dims);
}

inline SplitOptionsT *SplitOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<SplitOptionsT>(new SplitOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SplitOptions::UnPackTo(SplitOptionsT *_o,
                                   const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = num_splits();
    _o->num_splits = _e;
  }
}

inline flatbuffers::Offset<SplitOptions>
SplitOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SplitOptionsT *_o,
                   const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateSplitOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SplitOptions>
CreateSplitOptions(flatbuffers::FlatBufferBuilder &_fbb, const SplitOptionsT *_o,
                   const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const SplitOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _num_splits = _o->num_splits;
  return circle::CreateSplitOptions(_fbb, _num_splits);
}

inline SplitVOptionsT *
SplitVOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<SplitVOptionsT>(new SplitVOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SplitVOptions::UnPackTo(SplitVOptionsT *_o,
                                    const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = num_splits();
    _o->num_splits = _e;
  }
}

inline flatbuffers::Offset<SplitVOptions>
SplitVOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SplitVOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateSplitVOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SplitVOptions>
CreateSplitVOptions(flatbuffers::FlatBufferBuilder &_fbb, const SplitVOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const SplitVOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _num_splits = _o->num_splits;
  return circle::CreateSplitVOptions(_fbb, _num_splits);
}

inline StridedSliceOptionsT *
StridedSliceOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<StridedSliceOptionsT>(new StridedSliceOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StridedSliceOptions::UnPackTo(StridedSliceOptionsT *_o,
                                          const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = begin_mask();
    _o->begin_mask = _e;
  }
  {
    auto _e = end_mask();
    _o->end_mask = _e;
  }
  {
    auto _e = ellipsis_mask();
    _o->ellipsis_mask = _e;
  }
  {
    auto _e = new_axis_mask();
    _o->new_axis_mask = _e;
  }
  {
    auto _e = shrink_axis_mask();
    _o->shrink_axis_mask = _e;
  }
}

inline flatbuffers::Offset<StridedSliceOptions>
StridedSliceOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceOptionsT *_o,
                          const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateStridedSliceOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StridedSliceOptions>
CreateStridedSliceOptions(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceOptionsT *_o,
                          const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const StridedSliceOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _begin_mask = _o->begin_mask;
  auto _end_mask = _o->end_mask;
  auto _ellipsis_mask = _o->ellipsis_mask;
  auto _new_axis_mask = _o->new_axis_mask;
  auto _shrink_axis_mask = _o->shrink_axis_mask;
  return circle::CreateStridedSliceOptions(_fbb, _begin_mask, _end_mask, _ellipsis_mask,
                                           _new_axis_mask, _shrink_axis_mask);
}

inline LogSoftmaxOptionsT *
LogSoftmaxOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<LogSoftmaxOptionsT>(new LogSoftmaxOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LogSoftmaxOptions::UnPackTo(LogSoftmaxOptionsT *_o,
                                        const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LogSoftmaxOptions>
LogSoftmaxOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxOptionsT *_o,
                        const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateLogSoftmaxOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogSoftmaxOptions>
CreateLogSoftmaxOptions(flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxOptionsT *_o,
                        const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const LogSoftmaxOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateLogSoftmaxOptions(_fbb);
}

inline CastOptionsT *CastOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<CastOptionsT>(new CastOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CastOptions::UnPackTo(CastOptionsT *_o,
                                  const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = in_data_type();
    _o->in_data_type = _e;
  }
  {
    auto _e = out_data_type();
    _o->out_data_type = _e;
  }
}

inline flatbuffers::Offset<CastOptions>
CastOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CastOptionsT *_o,
                  const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateCastOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CastOptions>
CreateCastOptions(flatbuffers::FlatBufferBuilder &_fbb, const CastOptionsT *_o,
                  const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const CastOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _in_data_type = _o->in_data_type;
  auto _out_data_type = _o->out_data_type;
  return circle::CreateCastOptions(_fbb, _in_data_type, _out_data_type);
}

inline DequantizeOptionsT *
DequantizeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<DequantizeOptionsT>(new DequantizeOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DequantizeOptions::UnPackTo(DequantizeOptionsT *_o,
                                        const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<DequantizeOptions>
DequantizeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DequantizeOptionsT *_o,
                        const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateDequantizeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DequantizeOptions>
CreateDequantizeOptions(flatbuffers::FlatBufferBuilder &_fbb, const DequantizeOptionsT *_o,
                        const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const DequantizeOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateDequantizeOptions(_fbb);
}

inline MaximumMinimumOptionsT *
MaximumMinimumOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<MaximumMinimumOptionsT>(new MaximumMinimumOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MaximumMinimumOptions::UnPackTo(MaximumMinimumOptionsT *_o,
                                            const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<MaximumMinimumOptions>
MaximumMinimumOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MaximumMinimumOptionsT *_o,
                            const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateMaximumMinimumOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MaximumMinimumOptions>
CreateMaximumMinimumOptions(flatbuffers::FlatBufferBuilder &_fbb, const MaximumMinimumOptionsT *_o,
                            const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const MaximumMinimumOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateMaximumMinimumOptions(_fbb);
}

inline TileOptionsT *TileOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<TileOptionsT>(new TileOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TileOptions::UnPackTo(TileOptionsT *_o,
                                  const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<TileOptions>
TileOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TileOptionsT *_o,
                  const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateTileOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TileOptions>
CreateTileOptions(flatbuffers::FlatBufferBuilder &_fbb, const TileOptionsT *_o,
                  const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const TileOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateTileOptions(_fbb);
}

inline ArgMaxOptionsT *
ArgMaxOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<ArgMaxOptionsT>(new ArgMaxOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ArgMaxOptions::UnPackTo(ArgMaxOptionsT *_o,
                                    const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = output_type();
    _o->output_type = _e;
  }
}

inline flatbuffers::Offset<ArgMaxOptions>
ArgMaxOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateArgMaxOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ArgMaxOptions>
CreateArgMaxOptions(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const ArgMaxOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _output_type = _o->output_type;
  return circle::CreateArgMaxOptions(_fbb, _output_type);
}

inline ArgMinOptionsT *
ArgMinOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<ArgMinOptionsT>(new ArgMinOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ArgMinOptions::UnPackTo(ArgMinOptionsT *_o,
                                    const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = output_type();
    _o->output_type = _e;
  }
}

inline flatbuffers::Offset<ArgMinOptions>
ArgMinOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMinOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateArgMinOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ArgMinOptions>
CreateArgMinOptions(flatbuffers::FlatBufferBuilder &_fbb, const ArgMinOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const ArgMinOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _output_type = _o->output_type;
  return circle::CreateArgMinOptions(_fbb, _output_type);
}

inline GreaterOptionsT *
GreaterOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<GreaterOptionsT>(new GreaterOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GreaterOptions::UnPackTo(GreaterOptionsT *_o,
                                     const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<GreaterOptions>
GreaterOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterOptionsT *_o,
                     const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateGreaterOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GreaterOptions>
CreateGreaterOptions(flatbuffers::FlatBufferBuilder &_fbb, const GreaterOptionsT *_o,
                     const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const GreaterOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateGreaterOptions(_fbb);
}

inline GreaterEqualOptionsT *
GreaterEqualOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<GreaterEqualOptionsT>(new GreaterEqualOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GreaterEqualOptions::UnPackTo(GreaterEqualOptionsT *_o,
                                          const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<GreaterEqualOptions>
GreaterEqualOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionsT *_o,
                          const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateGreaterEqualOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GreaterEqualOptions>
CreateGreaterEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionsT *_o,
                          const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const GreaterEqualOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateGreaterEqualOptions(_fbb);
}

inline LessOptionsT *LessOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<LessOptionsT>(new LessOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LessOptions::UnPackTo(LessOptionsT *_o,
                                  const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LessOptions>
LessOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessOptionsT *_o,
                  const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateLessOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LessOptions>
CreateLessOptions(flatbuffers::FlatBufferBuilder &_fbb, const LessOptionsT *_o,
                  const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const LessOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateLessOptions(_fbb);
}

inline LessEqualOptionsT *
LessEqualOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<LessEqualOptionsT>(new LessEqualOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LessEqualOptions::UnPackTo(LessEqualOptionsT *_o,
                                       const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LessEqualOptions>
LessEqualOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualOptionsT *_o,
                       const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateLessEqualOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LessEqualOptions>
CreateLessEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualOptionsT *_o,
                       const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const LessEqualOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateLessEqualOptions(_fbb);
}

inline NegOptionsT *NegOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<NegOptionsT>(new NegOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NegOptions::UnPackTo(NegOptionsT *_o,
                                 const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<NegOptions>
NegOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NegOptionsT *_o,
                 const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateNegOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NegOptions>
CreateNegOptions(flatbuffers::FlatBufferBuilder &_fbb, const NegOptionsT *_o,
                 const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const NegOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateNegOptions(_fbb);
}

inline SelectOptionsT *
SelectOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<SelectOptionsT>(new SelectOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SelectOptions::UnPackTo(SelectOptionsT *_o,
                                    const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SelectOptions>
SelectOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SelectOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateSelectOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SelectOptions>
CreateSelectOptions(flatbuffers::FlatBufferBuilder &_fbb, const SelectOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const SelectOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateSelectOptions(_fbb);
}

inline SliceOptionsT *SliceOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<SliceOptionsT>(new SliceOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SliceOptions::UnPackTo(SliceOptionsT *_o,
                                   const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SliceOptions>
SliceOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SliceOptionsT *_o,
                   const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateSliceOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SliceOptions>
CreateSliceOptions(flatbuffers::FlatBufferBuilder &_fbb, const SliceOptionsT *_o,
                   const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const SliceOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateSliceOptions(_fbb);
}

inline TransposeConvOptionsT *
TransposeConvOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<TransposeConvOptionsT>(new TransposeConvOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TransposeConvOptions::UnPackTo(TransposeConvOptionsT *_o,
                                           const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = padding();
    _o->padding = _e;
  }
  {
    auto _e = stride_w();
    _o->stride_w = _e;
  }
  {
    auto _e = stride_h();
    _o->stride_h = _e;
  }
}

inline flatbuffers::Offset<TransposeConvOptions>
TransposeConvOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransposeConvOptionsT *_o,
                           const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateTransposeConvOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TransposeConvOptions>
CreateTransposeConvOptions(flatbuffers::FlatBufferBuilder &_fbb, const TransposeConvOptionsT *_o,
                           const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const TransposeConvOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _padding = _o->padding;
  auto _stride_w = _o->stride_w;
  auto _stride_h = _o->stride_h;
  return circle::CreateTransposeConvOptions(_fbb, _padding, _stride_w, _stride_h);
}

inline ExpandDimsOptionsT *
ExpandDimsOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<ExpandDimsOptionsT>(new ExpandDimsOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ExpandDimsOptions::UnPackTo(ExpandDimsOptionsT *_o,
                                        const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ExpandDimsOptions>
ExpandDimsOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsOptionsT *_o,
                        const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateExpandDimsOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ExpandDimsOptions>
CreateExpandDimsOptions(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsOptionsT *_o,
                        const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const ExpandDimsOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateExpandDimsOptions(_fbb);
}

inline SparseToDenseOptionsT *
SparseToDenseOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<SparseToDenseOptionsT>(new SparseToDenseOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SparseToDenseOptions::UnPackTo(SparseToDenseOptionsT *_o,
                                           const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = validate_indices();
    _o->validate_indices = _e;
  }
}

inline flatbuffers::Offset<SparseToDenseOptions>
SparseToDenseOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseOptionsT *_o,
                           const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateSparseToDenseOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SparseToDenseOptions>
CreateSparseToDenseOptions(flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseOptionsT *_o,
                           const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const SparseToDenseOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _validate_indices = _o->validate_indices;
  return circle::CreateSparseToDenseOptions(_fbb, _validate_indices);
}

inline EqualOptionsT *EqualOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<EqualOptionsT>(new EqualOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EqualOptions::UnPackTo(EqualOptionsT *_o,
                                   const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<EqualOptions>
EqualOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EqualOptionsT *_o,
                   const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateEqualOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EqualOptions>
CreateEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const EqualOptionsT *_o,
                   const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const EqualOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateEqualOptions(_fbb);
}

inline NotEqualOptionsT *
NotEqualOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<NotEqualOptionsT>(new NotEqualOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NotEqualOptions::UnPackTo(NotEqualOptionsT *_o,
                                      const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<NotEqualOptions>
NotEqualOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualOptionsT *_o,
                      const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateNotEqualOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NotEqualOptions>
CreateNotEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualOptionsT *_o,
                      const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const NotEqualOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateNotEqualOptions(_fbb);
}

inline ShapeOptionsT *ShapeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<ShapeOptionsT>(new ShapeOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ShapeOptions::UnPackTo(ShapeOptionsT *_o,
                                   const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = out_type();
    _o->out_type = _e;
  }
}

inline flatbuffers::Offset<ShapeOptions>
ShapeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShapeOptionsT *_o,
                   const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateShapeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ShapeOptions>
CreateShapeOptions(flatbuffers::FlatBufferBuilder &_fbb, const ShapeOptionsT *_o,
                   const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const ShapeOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _out_type = _o->out_type;
  return circle::CreateShapeOptions(_fbb, _out_type);
}

inline RankOptionsT *RankOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<RankOptionsT>(new RankOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RankOptions::UnPackTo(RankOptionsT *_o,
                                  const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<RankOptions>
RankOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RankOptionsT *_o,
                  const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateRankOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RankOptions>
CreateRankOptions(flatbuffers::FlatBufferBuilder &_fbb, const RankOptionsT *_o,
                  const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const RankOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateRankOptions(_fbb);
}

inline PowOptionsT *PowOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<PowOptionsT>(new PowOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PowOptions::UnPackTo(PowOptionsT *_o,
                                 const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<PowOptions>
PowOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PowOptionsT *_o,
                 const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreatePowOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PowOptions>
CreatePowOptions(flatbuffers::FlatBufferBuilder &_fbb, const PowOptionsT *_o,
                 const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const PowOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreatePowOptions(_fbb);
}

inline FakeQuantOptionsT *
FakeQuantOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<FakeQuantOptionsT>(new FakeQuantOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FakeQuantOptions::UnPackTo(FakeQuantOptionsT *_o,
                                       const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = min();
    _o->min = _e;
  }
  {
    auto _e = max();
    _o->max = _e;
  }
  {
    auto _e = num_bits();
    _o->num_bits = _e;
  }
  {
    auto _e = narrow_range();
    _o->narrow_range = _e;
  }
}

inline flatbuffers::Offset<FakeQuantOptions>
FakeQuantOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantOptionsT *_o,
                       const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateFakeQuantOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FakeQuantOptions>
CreateFakeQuantOptions(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantOptionsT *_o,
                       const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const FakeQuantOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _min = _o->min;
  auto _max = _o->max;
  auto _num_bits = _o->num_bits;
  auto _narrow_range = _o->narrow_range;
  return circle::CreateFakeQuantOptions(_fbb, _min, _max, _num_bits, _narrow_range);
}

inline PackOptionsT *PackOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<PackOptionsT>(new PackOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PackOptions::UnPackTo(PackOptionsT *_o,
                                  const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = values_count();
    _o->values_count = _e;
  }
  {
    auto _e = axis();
    _o->axis = _e;
  }
}

inline flatbuffers::Offset<PackOptions>
PackOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PackOptionsT *_o,
                  const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreatePackOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PackOptions>
CreatePackOptions(flatbuffers::FlatBufferBuilder &_fbb, const PackOptionsT *_o,
                  const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const PackOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _values_count = _o->values_count;
  auto _axis = _o->axis;
  return circle::CreatePackOptions(_fbb, _values_count, _axis);
}

inline LogicalOrOptionsT *
LogicalOrOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<LogicalOrOptionsT>(new LogicalOrOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LogicalOrOptions::UnPackTo(LogicalOrOptionsT *_o,
                                       const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LogicalOrOptions>
LogicalOrOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrOptionsT *_o,
                       const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateLogicalOrOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogicalOrOptions>
CreateLogicalOrOptions(flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrOptionsT *_o,
                       const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const LogicalOrOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateLogicalOrOptions(_fbb);
}

inline OneHotOptionsT *
OneHotOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<OneHotOptionsT>(new OneHotOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OneHotOptions::UnPackTo(OneHotOptionsT *_o,
                                    const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = axis();
    _o->axis = _e;
  }
}

inline flatbuffers::Offset<OneHotOptions>
OneHotOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OneHotOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateOneHotOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OneHotOptions>
CreateOneHotOptions(flatbuffers::FlatBufferBuilder &_fbb, const OneHotOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const OneHotOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _axis = _o->axis;
  return circle::CreateOneHotOptions(_fbb, _axis);
}

inline AbsOptionsT *AbsOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<AbsOptionsT>(new AbsOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AbsOptions::UnPackTo(AbsOptionsT *_o,
                                 const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<AbsOptions>
AbsOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AbsOptionsT *_o,
                 const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateAbsOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AbsOptions>
CreateAbsOptions(flatbuffers::FlatBufferBuilder &_fbb, const AbsOptionsT *_o,
                 const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const AbsOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateAbsOptions(_fbb);
}

inline HardSwishOptionsT *
HardSwishOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<HardSwishOptionsT>(new HardSwishOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HardSwishOptions::UnPackTo(HardSwishOptionsT *_o,
                                       const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<HardSwishOptions>
HardSwishOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HardSwishOptionsT *_o,
                       const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateHardSwishOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HardSwishOptions>
CreateHardSwishOptions(flatbuffers::FlatBufferBuilder &_fbb, const HardSwishOptionsT *_o,
                       const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const HardSwishOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateHardSwishOptions(_fbb);
}

inline LogicalAndOptionsT *
LogicalAndOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<LogicalAndOptionsT>(new LogicalAndOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LogicalAndOptions::UnPackTo(LogicalAndOptionsT *_o,
                                        const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LogicalAndOptions>
LogicalAndOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndOptionsT *_o,
                        const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateLogicalAndOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogicalAndOptions>
CreateLogicalAndOptions(flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndOptionsT *_o,
                        const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const LogicalAndOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateLogicalAndOptions(_fbb);
}

inline LogicalNotOptionsT *
LogicalNotOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<LogicalNotOptionsT>(new LogicalNotOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LogicalNotOptions::UnPackTo(LogicalNotOptionsT *_o,
                                        const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LogicalNotOptions>
LogicalNotOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotOptionsT *_o,
                        const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateLogicalNotOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogicalNotOptions>
CreateLogicalNotOptions(flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotOptionsT *_o,
                        const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const LogicalNotOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateLogicalNotOptions(_fbb);
}

inline UnpackOptionsT *
UnpackOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<UnpackOptionsT>(new UnpackOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UnpackOptions::UnPackTo(UnpackOptionsT *_o,
                                    const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = num();
    _o->num = _e;
  }
  {
    auto _e = axis();
    _o->axis = _e;
  }
}

inline flatbuffers::Offset<UnpackOptions>
UnpackOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnpackOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateUnpackOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UnpackOptions>
CreateUnpackOptions(flatbuffers::FlatBufferBuilder &_fbb, const UnpackOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const UnpackOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _num = _o->num;
  auto _axis = _o->axis;
  return circle::CreateUnpackOptions(_fbb, _num, _axis);
}

inline FloorDivOptionsT *
FloorDivOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<FloorDivOptionsT>(new FloorDivOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FloorDivOptions::UnPackTo(FloorDivOptionsT *_o,
                                      const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<FloorDivOptions>
FloorDivOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloorDivOptionsT *_o,
                      const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateFloorDivOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FloorDivOptions>
CreateFloorDivOptions(flatbuffers::FlatBufferBuilder &_fbb, const FloorDivOptionsT *_o,
                      const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const FloorDivOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateFloorDivOptions(_fbb);
}

inline SquareOptionsT *
SquareOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<SquareOptionsT>(new SquareOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SquareOptions::UnPackTo(SquareOptionsT *_o,
                                    const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SquareOptions>
SquareOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SquareOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateSquareOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SquareOptions>
CreateSquareOptions(flatbuffers::FlatBufferBuilder &_fbb, const SquareOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const SquareOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateSquareOptions(_fbb);
}

inline ZerosLikeOptionsT *
ZerosLikeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<ZerosLikeOptionsT>(new ZerosLikeOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ZerosLikeOptions::UnPackTo(ZerosLikeOptionsT *_o,
                                       const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ZerosLikeOptions>
ZerosLikeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeOptionsT *_o,
                       const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateZerosLikeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ZerosLikeOptions>
CreateZerosLikeOptions(flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeOptionsT *_o,
                       const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const ZerosLikeOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateZerosLikeOptions(_fbb);
}

inline FillOptionsT *FillOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<FillOptionsT>(new FillOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FillOptions::UnPackTo(FillOptionsT *_o,
                                  const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<FillOptions>
FillOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FillOptionsT *_o,
                  const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateFillOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FillOptions>
CreateFillOptions(flatbuffers::FlatBufferBuilder &_fbb, const FillOptionsT *_o,
                  const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const FillOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateFillOptions(_fbb);
}

inline FloorModOptionsT *
FloorModOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<FloorModOptionsT>(new FloorModOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FloorModOptions::UnPackTo(FloorModOptionsT *_o,
                                      const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<FloorModOptions>
FloorModOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloorModOptionsT *_o,
                      const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateFloorModOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FloorModOptions>
CreateFloorModOptions(flatbuffers::FlatBufferBuilder &_fbb, const FloorModOptionsT *_o,
                      const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const FloorModOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateFloorModOptions(_fbb);
}

inline RangeOptionsT *RangeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<RangeOptionsT>(new RangeOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RangeOptions::UnPackTo(RangeOptionsT *_o,
                                   const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<RangeOptions>
RangeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RangeOptionsT *_o,
                   const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateRangeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RangeOptions>
CreateRangeOptions(flatbuffers::FlatBufferBuilder &_fbb, const RangeOptionsT *_o,
                   const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const RangeOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateRangeOptions(_fbb);
}

inline LeakyReluOptionsT *
LeakyReluOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<LeakyReluOptionsT>(new LeakyReluOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LeakyReluOptions::UnPackTo(LeakyReluOptionsT *_o,
                                       const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = alpha();
    _o->alpha = _e;
  }
}

inline flatbuffers::Offset<LeakyReluOptions>
LeakyReluOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluOptionsT *_o,
                       const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateLeakyReluOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LeakyReluOptions>
CreateLeakyReluOptions(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluOptionsT *_o,
                       const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const LeakyReluOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _alpha = _o->alpha;
  return circle::CreateLeakyReluOptions(_fbb, _alpha);
}

inline SquaredDifferenceOptionsT *
SquaredDifferenceOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<SquaredDifferenceOptionsT>(new SquaredDifferenceOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void
SquaredDifferenceOptions::UnPackTo(SquaredDifferenceOptionsT *_o,
                                   const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SquaredDifferenceOptions>
SquaredDifferenceOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                               const SquaredDifferenceOptionsT *_o,
                               const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateSquaredDifferenceOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SquaredDifferenceOptions>
CreateSquaredDifferenceOptions(flatbuffers::FlatBufferBuilder &_fbb,
                               const SquaredDifferenceOptionsT *_o,
                               const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const SquaredDifferenceOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateSquaredDifferenceOptions(_fbb);
}

inline MirrorPadOptionsT *
MirrorPadOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<MirrorPadOptionsT>(new MirrorPadOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MirrorPadOptions::UnPackTo(MirrorPadOptionsT *_o,
                                       const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = mode();
    _o->mode = _e;
  }
}

inline flatbuffers::Offset<MirrorPadOptions>
MirrorPadOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MirrorPadOptionsT *_o,
                       const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateMirrorPadOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MirrorPadOptions>
CreateMirrorPadOptions(flatbuffers::FlatBufferBuilder &_fbb, const MirrorPadOptionsT *_o,
                       const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const MirrorPadOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _mode = _o->mode;
  return circle::CreateMirrorPadOptions(_fbb, _mode);
}

inline UniqueOptionsT *
UniqueOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<UniqueOptionsT>(new UniqueOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UniqueOptions::UnPackTo(UniqueOptionsT *_o,
                                    const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = idx_out_type();
    _o->idx_out_type = _e;
  }
}

inline flatbuffers::Offset<UniqueOptions>
UniqueOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UniqueOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateUniqueOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UniqueOptions>
CreateUniqueOptions(flatbuffers::FlatBufferBuilder &_fbb, const UniqueOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const UniqueOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _idx_out_type = _o->idx_out_type;
  return circle::CreateUniqueOptions(_fbb, _idx_out_type);
}

inline ReverseV2OptionsT *
ReverseV2Options::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<ReverseV2OptionsT>(new ReverseV2OptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReverseV2Options::UnPackTo(ReverseV2OptionsT *_o,
                                       const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ReverseV2Options>
ReverseV2Options::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReverseV2OptionsT *_o,
                       const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateReverseV2Options(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReverseV2Options>
CreateReverseV2Options(flatbuffers::FlatBufferBuilder &_fbb, const ReverseV2OptionsT *_o,
                       const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const ReverseV2OptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateReverseV2Options(_fbb);
}

inline AddNOptionsT *AddNOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<AddNOptionsT>(new AddNOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AddNOptions::UnPackTo(AddNOptionsT *_o,
                                  const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<AddNOptions>
AddNOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddNOptionsT *_o,
                  const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateAddNOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AddNOptions>
CreateAddNOptions(flatbuffers::FlatBufferBuilder &_fbb, const AddNOptionsT *_o,
                  const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const AddNOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateAddNOptions(_fbb);
}

inline GatherNdOptionsT *
GatherNdOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<GatherNdOptionsT>(new GatherNdOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GatherNdOptions::UnPackTo(GatherNdOptionsT *_o,
                                      const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<GatherNdOptions>
GatherNdOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherNdOptionsT *_o,
                      const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateGatherNdOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GatherNdOptions>
CreateGatherNdOptions(flatbuffers::FlatBufferBuilder &_fbb, const GatherNdOptionsT *_o,
                      const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const GatherNdOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateGatherNdOptions(_fbb);
}

inline WhereOptionsT *WhereOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<WhereOptionsT>(new WhereOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void WhereOptions::UnPackTo(WhereOptionsT *_o,
                                   const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<WhereOptions>
WhereOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const WhereOptionsT *_o,
                   const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateWhereOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<WhereOptions>
CreateWhereOptions(flatbuffers::FlatBufferBuilder &_fbb, const WhereOptionsT *_o,
                   const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const WhereOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateWhereOptions(_fbb);
}

inline ReverseSequenceOptionsT *
ReverseSequenceOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<ReverseSequenceOptionsT>(new ReverseSequenceOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void
ReverseSequenceOptions::UnPackTo(ReverseSequenceOptionsT *_o,
                                 const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = seq_dim();
    _o->seq_dim = _e;
  }
  {
    auto _e = batch_dim();
    _o->batch_dim = _e;
  }
}

inline flatbuffers::Offset<ReverseSequenceOptions>
ReverseSequenceOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                             const ReverseSequenceOptionsT *_o,
                             const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateReverseSequenceOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReverseSequenceOptions>
CreateReverseSequenceOptions(flatbuffers::FlatBufferBuilder &_fbb,
                             const ReverseSequenceOptionsT *_o,
                             const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const ReverseSequenceOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _seq_dim = _o->seq_dim;
  auto _batch_dim = _o->batch_dim;
  return circle::CreateReverseSequenceOptions(_fbb, _seq_dim, _batch_dim);
}

inline MatrixDiagOptionsT *
MatrixDiagOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<MatrixDiagOptionsT>(new MatrixDiagOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MatrixDiagOptions::UnPackTo(MatrixDiagOptionsT *_o,
                                        const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<MatrixDiagOptions>
MatrixDiagOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatrixDiagOptionsT *_o,
                        const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateMatrixDiagOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MatrixDiagOptions>
CreateMatrixDiagOptions(flatbuffers::FlatBufferBuilder &_fbb, const MatrixDiagOptionsT *_o,
                        const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const MatrixDiagOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateMatrixDiagOptions(_fbb);
}

inline QuantizeOptionsT *
QuantizeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<QuantizeOptionsT>(new QuantizeOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void QuantizeOptions::UnPackTo(QuantizeOptionsT *_o,
                                      const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<QuantizeOptions>
QuantizeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantizeOptionsT *_o,
                      const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateQuantizeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<QuantizeOptions>
CreateQuantizeOptions(flatbuffers::FlatBufferBuilder &_fbb, const QuantizeOptionsT *_o,
                      const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const QuantizeOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateQuantizeOptions(_fbb);
}

inline MatrixSetDiagOptionsT *
MatrixSetDiagOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<MatrixSetDiagOptionsT>(new MatrixSetDiagOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MatrixSetDiagOptions::UnPackTo(MatrixSetDiagOptionsT *_o,
                                           const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<MatrixSetDiagOptions>
MatrixSetDiagOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatrixSetDiagOptionsT *_o,
                           const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateMatrixSetDiagOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MatrixSetDiagOptions>
CreateMatrixSetDiagOptions(flatbuffers::FlatBufferBuilder &_fbb, const MatrixSetDiagOptionsT *_o,
                           const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const MatrixSetDiagOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateMatrixSetDiagOptions(_fbb);
}

inline IfOptionsT *IfOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<IfOptionsT>(new IfOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void IfOptions::UnPackTo(IfOptionsT *_o,
                                const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = then_subgraph_index();
    _o->then_subgraph_index = _e;
  }
  {
    auto _e = else_subgraph_index();
    _o->else_subgraph_index = _e;
  }
}

inline flatbuffers::Offset<IfOptions>
IfOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const IfOptionsT *_o,
                const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateIfOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<IfOptions>
CreateIfOptions(flatbuffers::FlatBufferBuilder &_fbb, const IfOptionsT *_o,
                const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const IfOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _then_subgraph_index = _o->then_subgraph_index;
  auto _else_subgraph_index = _o->else_subgraph_index;
  return circle::CreateIfOptions(_fbb, _then_subgraph_index, _else_subgraph_index);
}

inline CallOnceOptionsT *
CallOnceOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<CallOnceOptionsT>(new CallOnceOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CallOnceOptions::UnPackTo(CallOnceOptionsT *_o,
                                      const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = init_subgraph_index();
    _o->init_subgraph_index = _e;
  }
}

inline flatbuffers::Offset<CallOnceOptions>
CallOnceOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CallOnceOptionsT *_o,
                      const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateCallOnceOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CallOnceOptions>
CreateCallOnceOptions(flatbuffers::FlatBufferBuilder &_fbb, const CallOnceOptionsT *_o,
                      const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const CallOnceOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _init_subgraph_index = _o->init_subgraph_index;
  return circle::CreateCallOnceOptions(_fbb, _init_subgraph_index);
}

inline WhileOptionsT *WhileOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<WhileOptionsT>(new WhileOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void WhileOptions::UnPackTo(WhileOptionsT *_o,
                                   const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = cond_subgraph_index();
    _o->cond_subgraph_index = _e;
  }
  {
    auto _e = body_subgraph_index();
    _o->body_subgraph_index = _e;
  }
}

inline flatbuffers::Offset<WhileOptions>
WhileOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const WhileOptionsT *_o,
                   const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateWhileOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<WhileOptions>
CreateWhileOptions(flatbuffers::FlatBufferBuilder &_fbb, const WhileOptionsT *_o,
                   const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const WhileOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _cond_subgraph_index = _o->cond_subgraph_index;
  auto _body_subgraph_index = _o->body_subgraph_index;
  return circle::CreateWhileOptions(_fbb, _cond_subgraph_index, _body_subgraph_index);
}

inline NonMaxSuppressionV4OptionsT *
NonMaxSuppressionV4Options::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<NonMaxSuppressionV4OptionsT>(new NonMaxSuppressionV4OptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void
NonMaxSuppressionV4Options::UnPackTo(NonMaxSuppressionV4OptionsT *_o,
                                     const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<NonMaxSuppressionV4Options>
NonMaxSuppressionV4Options::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                 const NonMaxSuppressionV4OptionsT *_o,
                                 const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateNonMaxSuppressionV4Options(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NonMaxSuppressionV4Options>
CreateNonMaxSuppressionV4Options(flatbuffers::FlatBufferBuilder &_fbb,
                                 const NonMaxSuppressionV4OptionsT *_o,
                                 const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const NonMaxSuppressionV4OptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateNonMaxSuppressionV4Options(_fbb);
}

inline NonMaxSuppressionV5OptionsT *
NonMaxSuppressionV5Options::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<NonMaxSuppressionV5OptionsT>(new NonMaxSuppressionV5OptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void
NonMaxSuppressionV5Options::UnPackTo(NonMaxSuppressionV5OptionsT *_o,
                                     const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<NonMaxSuppressionV5Options>
NonMaxSuppressionV5Options::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                 const NonMaxSuppressionV5OptionsT *_o,
                                 const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateNonMaxSuppressionV5Options(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NonMaxSuppressionV5Options>
CreateNonMaxSuppressionV5Options(flatbuffers::FlatBufferBuilder &_fbb,
                                 const NonMaxSuppressionV5OptionsT *_o,
                                 const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const NonMaxSuppressionV5OptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateNonMaxSuppressionV5Options(_fbb);
}

inline ScatterNdOptionsT *
ScatterNdOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<ScatterNdOptionsT>(new ScatterNdOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ScatterNdOptions::UnPackTo(ScatterNdOptionsT *_o,
                                       const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ScatterNdOptions>
ScatterNdOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdOptionsT *_o,
                       const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateScatterNdOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ScatterNdOptions>
CreateScatterNdOptions(flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdOptionsT *_o,
                       const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const ScatterNdOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateScatterNdOptions(_fbb);
}

inline SelectV2OptionsT *
SelectV2Options::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<SelectV2OptionsT>(new SelectV2OptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SelectV2Options::UnPackTo(SelectV2OptionsT *_o,
                                      const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SelectV2Options>
SelectV2Options::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SelectV2OptionsT *_o,
                      const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateSelectV2Options(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SelectV2Options>
CreateSelectV2Options(flatbuffers::FlatBufferBuilder &_fbb, const SelectV2OptionsT *_o,
                      const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const SelectV2OptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateSelectV2Options(_fbb);
}

inline DensifyOptionsT *
DensifyOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<DensifyOptionsT>(new DensifyOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DensifyOptions::UnPackTo(DensifyOptionsT *_o,
                                     const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<DensifyOptions>
DensifyOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DensifyOptionsT *_o,
                     const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateDensifyOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DensifyOptions>
CreateDensifyOptions(flatbuffers::FlatBufferBuilder &_fbb, const DensifyOptionsT *_o,
                     const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const DensifyOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateDensifyOptions(_fbb);
}

inline SegmentSumOptionsT *
SegmentSumOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<SegmentSumOptionsT>(new SegmentSumOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SegmentSumOptions::UnPackTo(SegmentSumOptionsT *_o,
                                        const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SegmentSumOptions>
SegmentSumOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SegmentSumOptionsT *_o,
                        const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateSegmentSumOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SegmentSumOptions>
CreateSegmentSumOptions(flatbuffers::FlatBufferBuilder &_fbb, const SegmentSumOptionsT *_o,
                        const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const SegmentSumOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateSegmentSumOptions(_fbb);
}

inline BatchMatMulOptionsT *
BatchMatMulOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<BatchMatMulOptionsT>(new BatchMatMulOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BatchMatMulOptions::UnPackTo(BatchMatMulOptionsT *_o,
                                         const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = adjoint_lhs();
    _o->adjoint_lhs = _e;
  }
  {
    auto _e = adjoint_rhs();
    _o->adjoint_rhs = _e;
  }
  {
    auto _e = asymmetric_quantize_inputs();
    _o->asymmetric_quantize_inputs = _e;
  }
}

inline flatbuffers::Offset<BatchMatMulOptions>
BatchMatMulOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchMatMulOptionsT *_o,
                         const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateBatchMatMulOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BatchMatMulOptions>
CreateBatchMatMulOptions(flatbuffers::FlatBufferBuilder &_fbb, const BatchMatMulOptionsT *_o,
                         const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const BatchMatMulOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _adjoint_lhs = _o->adjoint_lhs;
  auto _adjoint_rhs = _o->adjoint_rhs;
  auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
  return circle::CreateBatchMatMulOptions(_fbb, _adjoint_lhs, _adjoint_rhs,
                                          _asymmetric_quantize_inputs);
}

inline CumsumOptionsT *
CumsumOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<CumsumOptionsT>(new CumsumOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CumsumOptions::UnPackTo(CumsumOptionsT *_o,
                                    const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = exclusive();
    _o->exclusive = _e;
  }
  {
    auto _e = reverse();
    _o->reverse = _e;
  }
}

inline flatbuffers::Offset<CumsumOptions>
CumsumOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CumsumOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateCumsumOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CumsumOptions>
CreateCumsumOptions(flatbuffers::FlatBufferBuilder &_fbb, const CumsumOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const CumsumOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _exclusive = _o->exclusive;
  auto _reverse = _o->reverse;
  return circle::CreateCumsumOptions(_fbb, _exclusive, _reverse);
}

inline BroadcastToOptionsT *
BroadcastToOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<BroadcastToOptionsT>(new BroadcastToOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BroadcastToOptions::UnPackTo(BroadcastToOptionsT *_o,
                                         const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<BroadcastToOptions>
BroadcastToOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BroadcastToOptionsT *_o,
                         const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateBroadcastToOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BroadcastToOptions>
CreateBroadcastToOptions(flatbuffers::FlatBufferBuilder &_fbb, const BroadcastToOptionsT *_o,
                         const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const BroadcastToOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateBroadcastToOptions(_fbb);
}

inline Rfft2dOptionsT *
Rfft2dOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<Rfft2dOptionsT>(new Rfft2dOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Rfft2dOptions::UnPackTo(Rfft2dOptionsT *_o,
                                    const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Rfft2dOptions>
Rfft2dOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Rfft2dOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateRfft2dOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Rfft2dOptions>
CreateRfft2dOptions(flatbuffers::FlatBufferBuilder &_fbb, const Rfft2dOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const Rfft2dOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateRfft2dOptions(_fbb);
}

inline HashtableOptionsT *
HashtableOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<HashtableOptionsT>(new HashtableOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HashtableOptions::UnPackTo(HashtableOptionsT *_o,
                                       const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = table_id();
    _o->table_id = _e;
  }
  {
    auto _e = key_dtype();
    _o->key_dtype = _e;
  }
  {
    auto _e = value_dtype();
    _o->value_dtype = _e;
  }
}

inline flatbuffers::Offset<HashtableOptions>
HashtableOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HashtableOptionsT *_o,
                       const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateHashtableOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HashtableOptions>
CreateHashtableOptions(flatbuffers::FlatBufferBuilder &_fbb, const HashtableOptionsT *_o,
                       const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const HashtableOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _table_id = _o->table_id;
  auto _key_dtype = _o->key_dtype;
  auto _value_dtype = _o->value_dtype;
  return circle::CreateHashtableOptions(_fbb, _table_id, _key_dtype, _value_dtype);
}

inline HashtableFindOptionsT *
HashtableFindOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<HashtableFindOptionsT>(new HashtableFindOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HashtableFindOptions::UnPackTo(HashtableFindOptionsT *_o,
                                           const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<HashtableFindOptions>
HashtableFindOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HashtableFindOptionsT *_o,
                           const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateHashtableFindOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HashtableFindOptions>
CreateHashtableFindOptions(flatbuffers::FlatBufferBuilder &_fbb, const HashtableFindOptionsT *_o,
                           const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const HashtableFindOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateHashtableFindOptions(_fbb);
}

inline HashtableImportOptionsT *
HashtableImportOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<HashtableImportOptionsT>(new HashtableImportOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void
HashtableImportOptions::UnPackTo(HashtableImportOptionsT *_o,
                                 const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<HashtableImportOptions>
HashtableImportOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                             const HashtableImportOptionsT *_o,
                             const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateHashtableImportOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HashtableImportOptions>
CreateHashtableImportOptions(flatbuffers::FlatBufferBuilder &_fbb,
                             const HashtableImportOptionsT *_o,
                             const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const HashtableImportOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateHashtableImportOptions(_fbb);
}

inline HashtableSizeOptionsT *
HashtableSizeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<HashtableSizeOptionsT>(new HashtableSizeOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HashtableSizeOptions::UnPackTo(HashtableSizeOptionsT *_o,
                                           const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<HashtableSizeOptions>
HashtableSizeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HashtableSizeOptionsT *_o,
                           const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateHashtableSizeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HashtableSizeOptions>
CreateHashtableSizeOptions(flatbuffers::FlatBufferBuilder &_fbb, const HashtableSizeOptionsT *_o,
                           const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const HashtableSizeOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateHashtableSizeOptions(_fbb);
}

inline VarHandleOptionsT *
VarHandleOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<VarHandleOptionsT>(new VarHandleOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void VarHandleOptions::UnPackTo(VarHandleOptionsT *_o,
                                       const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = container();
    if (_e)
      _o->container = _e->str();
  }
  {
    auto _e = shared_name();
    if (_e)
      _o->shared_name = _e->str();
  }
}

inline flatbuffers::Offset<VarHandleOptions>
VarHandleOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const VarHandleOptionsT *_o,
                       const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateVarHandleOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<VarHandleOptions>
CreateVarHandleOptions(flatbuffers::FlatBufferBuilder &_fbb, const VarHandleOptionsT *_o,
                       const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const VarHandleOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _container = _o->container.empty() ? 0 : _fbb.CreateString(_o->container);
  auto _shared_name = _o->shared_name.empty() ? 0 : _fbb.CreateString(_o->shared_name);
  return circle::CreateVarHandleOptions(_fbb, _container, _shared_name);
}

inline ReadVariableOptionsT *
ReadVariableOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<ReadVariableOptionsT>(new ReadVariableOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReadVariableOptions::UnPackTo(ReadVariableOptionsT *_o,
                                          const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ReadVariableOptions>
ReadVariableOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReadVariableOptionsT *_o,
                          const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateReadVariableOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReadVariableOptions>
CreateReadVariableOptions(flatbuffers::FlatBufferBuilder &_fbb, const ReadVariableOptionsT *_o,
                          const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const ReadVariableOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateReadVariableOptions(_fbb);
}

inline AssignVariableOptionsT *
AssignVariableOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<AssignVariableOptionsT>(new AssignVariableOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AssignVariableOptions::UnPackTo(AssignVariableOptionsT *_o,
                                            const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<AssignVariableOptions>
AssignVariableOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AssignVariableOptionsT *_o,
                            const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateAssignVariableOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AssignVariableOptions>
CreateAssignVariableOptions(flatbuffers::FlatBufferBuilder &_fbb, const AssignVariableOptionsT *_o,
                            const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const AssignVariableOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  return circle::CreateAssignVariableOptions(_fbb);
}

inline RandomOptionsT *
RandomOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<RandomOptionsT>(new RandomOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RandomOptions::UnPackTo(RandomOptionsT *_o,
                                    const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = seed();
    _o->seed = _e;
  }
  {
    auto _e = seed2();
    _o->seed2 = _e;
  }
}

inline flatbuffers::Offset<RandomOptions>
RandomOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RandomOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateRandomOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RandomOptions>
CreateRandomOptions(flatbuffers::FlatBufferBuilder &_fbb, const RandomOptionsT *_o,
                    const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const RandomOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _seed = _o->seed;
  auto _seed2 = _o->seed2;
  return circle::CreateRandomOptions(_fbb, _seed, _seed2);
}

inline BCQGatherOptionsT *
BCQGatherOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<BCQGatherOptionsT>(new BCQGatherOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BCQGatherOptions::UnPackTo(BCQGatherOptionsT *_o,
                                       const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = input_hidden_size();
    _o->input_hidden_size = _e;
  }
  {
    auto _e = axis();
    _o->axis = _e;
  }
}

inline flatbuffers::Offset<BCQGatherOptions>
BCQGatherOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BCQGatherOptionsT *_o,
                       const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateBCQGatherOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BCQGatherOptions>
CreateBCQGatherOptions(flatbuffers::FlatBufferBuilder &_fbb, const BCQGatherOptionsT *_o,
                       const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const BCQGatherOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _input_hidden_size = _o->input_hidden_size;
  auto _axis = _o->axis;
  return circle::CreateBCQGatherOptions(_fbb, _input_hidden_size, _axis);
}

inline BCQFullyConnectedOptionsT *
BCQFullyConnectedOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<BCQFullyConnectedOptionsT>(new BCQFullyConnectedOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void
BCQFullyConnectedOptions::UnPackTo(BCQFullyConnectedOptionsT *_o,
                                   const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = weights_hidden_size();
    _o->weights_hidden_size = _e;
  }
  {
    auto _e = fused_activation_function();
    _o->fused_activation_function = _e;
  }
}

inline flatbuffers::Offset<BCQFullyConnectedOptions>
BCQFullyConnectedOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                               const BCQFullyConnectedOptionsT *_o,
                               const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateBCQFullyConnectedOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BCQFullyConnectedOptions>
CreateBCQFullyConnectedOptions(flatbuffers::FlatBufferBuilder &_fbb,
                               const BCQFullyConnectedOptionsT *_o,
                               const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const BCQFullyConnectedOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _weights_hidden_size = _o->weights_hidden_size;
  auto _fused_activation_function = _o->fused_activation_function;
  return circle::CreateBCQFullyConnectedOptions(_fbb, _weights_hidden_size,
                                                _fused_activation_function);
}

inline InstanceNormOptionsT *
InstanceNormOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<InstanceNormOptionsT>(new InstanceNormOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void InstanceNormOptions::UnPackTo(InstanceNormOptionsT *_o,
                                          const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = epsilon();
    _o->epsilon = _e;
  }
  {
    auto _e = fused_activation_function();
    _o->fused_activation_function = _e;
  }
}

inline flatbuffers::Offset<InstanceNormOptions>
InstanceNormOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InstanceNormOptionsT *_o,
                          const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateInstanceNormOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<InstanceNormOptions>
CreateInstanceNormOptions(flatbuffers::FlatBufferBuilder &_fbb, const InstanceNormOptionsT *_o,
                          const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const InstanceNormOptionsT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _epsilon = _o->epsilon;
  auto _fused_activation_function = _o->fused_activation_function;
  return circle::CreateInstanceNormOptions(_fbb, _epsilon, _fused_activation_function);
}

inline OperatorCodeT *OperatorCode::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<OperatorCodeT>(new OperatorCodeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OperatorCode::UnPackTo(OperatorCodeT *_o,
                                   const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = deprecated_builtin_code();
    _o->deprecated_builtin_code = _e;
  }
  {
    auto _e = custom_code();
    if (_e)
      _o->custom_code = _e->str();
  }
  {
    auto _e = version();
    _o->version = _e;
  }
  {
    auto _e = builtin_code();
    _o->builtin_code = _e;
  }
}

inline flatbuffers::Offset<OperatorCode>
OperatorCode::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OperatorCodeT *_o,
                   const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateOperatorCode(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OperatorCode>
CreateOperatorCode(flatbuffers::FlatBufferBuilder &_fbb, const OperatorCodeT *_o,
                   const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const OperatorCodeT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _deprecated_builtin_code = _o->deprecated_builtin_code;
  auto _custom_code = _o->custom_code.empty() ? 0 : _fbb.CreateString(_o->custom_code);
  auto _version = _o->version;
  auto _builtin_code = _o->builtin_code;
  return circle::CreateOperatorCode(_fbb, _deprecated_builtin_code, _custom_code, _version,
                                    _builtin_code);
}

inline OperatorT *Operator::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<OperatorT>(new OperatorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Operator::UnPackTo(OperatorT *_o,
                               const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = opcode_index();
    _o->opcode_index = _e;
  }
  {
    auto _e = inputs();
    if (_e)
    {
      _o->inputs.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
      {
        _o->inputs[_i] = _e->Get(_i);
      }
    }
  }
  {
    auto _e = outputs();
    if (_e)
    {
      _o->outputs.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
      {
        _o->outputs[_i] = _e->Get(_i);
      }
    }
  }
  {
    auto _e = builtin_options_type();
    _o->builtin_options.type = _e;
  }
  {
    auto _e = builtin_options();
    if (_e)
      _o->builtin_options.value =
        circle::BuiltinOptionsUnion::UnPack(_e, builtin_options_type(), _resolver);
  }
  {
    auto _e = custom_options();
    if (_e)
    {
      _o->custom_options.resize(_e->size());
      std::copy(_e->begin(), _e->end(), _o->custom_options.begin());
    }
  }
  {
    auto _e = custom_options_format();
    _o->custom_options_format = _e;
  }
  {
    auto _e = mutating_variable_inputs();
    if (_e)
    {
      _o->mutating_variable_inputs.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
      {
        _o->mutating_variable_inputs[_i] = _e->Get(_i) != 0;
      }
    }
  }
  {
    auto _e = intermediates();
    if (_e)
    {
      _o->intermediates.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
      {
        _o->intermediates[_i] = _e->Get(_i);
      }
    }
  }
}

inline flatbuffers::Offset<Operator>
Operator::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OperatorT *_o,
               const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateOperator(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Operator>
CreateOperator(flatbuffers::FlatBufferBuilder &_fbb, const OperatorT *_o,
               const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const OperatorT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _opcode_index = _o->opcode_index;
  auto _inputs = _o->inputs.size() ? _fbb.CreateVector(_o->inputs) : 0;
  auto _outputs = _o->outputs.size() ? _fbb.CreateVector(_o->outputs) : 0;
  auto _builtin_options_type = _o->builtin_options.type;
  auto _builtin_options = _o->builtin_options.Pack(_fbb);
  auto _custom_options = _o->custom_options.size() ? _fbb.CreateVector(_o->custom_options) : 0;
  auto _custom_options_format = _o->custom_options_format;
  auto _mutating_variable_inputs =
    _o->mutating_variable_inputs.size() ? _fbb.CreateVector(_o->mutating_variable_inputs) : 0;
  auto _intermediates = _o->intermediates.size() ? _fbb.CreateVector(_o->intermediates) : 0;
  return circle::CreateOperator(_fbb, _opcode_index, _inputs, _outputs, _builtin_options_type,
                                _builtin_options, _custom_options, _custom_options_format,
                                _mutating_variable_inputs, _intermediates);
}

inline SubGraphT *SubGraph::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<SubGraphT>(new SubGraphT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SubGraph::UnPackTo(SubGraphT *_o,
                               const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = tensors();
    if (_e)
    {
      _o->tensors.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
      {
        _o->tensors[_i] = std::unique_ptr<circle::TensorT>(_e->Get(_i)->UnPack(_resolver));
      }
    }
  }
  {
    auto _e = inputs();
    if (_e)
    {
      _o->inputs.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
      {
        _o->inputs[_i] = _e->Get(_i);
      }
    }
  }
  {
    auto _e = outputs();
    if (_e)
    {
      _o->outputs.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
      {
        _o->outputs[_i] = _e->Get(_i);
      }
    }
  }
  {
    auto _e = operators();
    if (_e)
    {
      _o->operators.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
      {
        _o->operators[_i] = std::unique_ptr<circle::OperatorT>(_e->Get(_i)->UnPack(_resolver));
      }
    }
  }
  {
    auto _e = name();
    if (_e)
      _o->name = _e->str();
  }
  {
    auto _e = data_format();
    _o->data_format = _e;
  }
}

inline flatbuffers::Offset<SubGraph>
SubGraph::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT *_o,
               const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateSubGraph(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SubGraph>
CreateSubGraph(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT *_o,
               const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const SubGraphT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _tensors =
    _o->tensors.size()
      ? _fbb.CreateVector<flatbuffers::Offset<circle::Tensor>>(
          _o->tensors.size(),
          [](size_t i, _VectorArgs *__va) {
            return CreateTensor(*__va->__fbb, __va->__o->tensors[i].get(), __va->__rehasher);
          },
          &_va)
      : 0;
  auto _inputs = _o->inputs.size() ? _fbb.CreateVector(_o->inputs) : 0;
  auto _outputs = _o->outputs.size() ? _fbb.CreateVector(_o->outputs) : 0;
  auto _operators =
    _o->operators.size()
      ? _fbb.CreateVector<flatbuffers::Offset<circle::Operator>>(
          _o->operators.size(),
          [](size_t i, _VectorArgs *__va) {
            return CreateOperator(*__va->__fbb, __va->__o->operators[i].get(), __va->__rehasher);
          },
          &_va)
      : 0;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _data_format = _o->data_format;
  return circle::CreateSubGraph(_fbb, _tensors, _inputs, _outputs, _operators, _name, _data_format);
}

inline BufferT *Buffer::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<BufferT>(new BufferT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Buffer::UnPackTo(BufferT *_o, const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = data();
    if (_e)
    {
      _o->data.resize(_e->size());
      std::copy(_e->begin(), _e->end(), _o->data.begin());
    }
  }
}

inline flatbuffers::Offset<Buffer> Buffer::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                const BufferT *_o,
                                                const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateBuffer(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Buffer> CreateBuffer(flatbuffers::FlatBufferBuilder &_fbb,
                                                const BufferT *_o,
                                                const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const BufferT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  _fbb.ForceVectorAlignment(_o->data.size(), sizeof(uint8_t), 16);
  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
  return circle::CreateBuffer(_fbb, _data);
}

inline MetadataT *Metadata::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<MetadataT>(new MetadataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Metadata::UnPackTo(MetadataT *_o,
                               const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = name();
    if (_e)
      _o->name = _e->str();
  }
  {
    auto _e = buffer();
    _o->buffer = _e;
  }
}

inline flatbuffers::Offset<Metadata>
Metadata::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MetadataT *_o,
               const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateMetadata(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Metadata>
CreateMetadata(flatbuffers::FlatBufferBuilder &_fbb, const MetadataT *_o,
               const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const MetadataT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _buffer = _o->buffer;
  return circle::CreateMetadata(_fbb, _name, _buffer);
}

inline TensorMapT *TensorMap::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<TensorMapT>(new TensorMapT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TensorMap::UnPackTo(TensorMapT *_o,
                                const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = name();
    if (_e)
      _o->name = _e->str();
  }
  {
    auto _e = tensor_index();
    _o->tensor_index = _e;
  }
}

inline flatbuffers::Offset<TensorMap>
TensorMap::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorMapT *_o,
                const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateTensorMap(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TensorMap>
CreateTensorMap(flatbuffers::FlatBufferBuilder &_fbb, const TensorMapT *_o,
                const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const TensorMapT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _tensor_index = _o->tensor_index;
  return circle::CreateTensorMap(_fbb, _name, _tensor_index);
}

inline SignatureDefT *SignatureDef::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<SignatureDefT>(new SignatureDefT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SignatureDef::UnPackTo(SignatureDefT *_o,
                                   const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = inputs();
    if (_e)
    {
      _o->inputs.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
      {
        _o->inputs[_i] = std::unique_ptr<circle::TensorMapT>(_e->Get(_i)->UnPack(_resolver));
      }
    }
  }
  {
    auto _e = outputs();
    if (_e)
    {
      _o->outputs.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
      {
        _o->outputs[_i] = std::unique_ptr<circle::TensorMapT>(_e->Get(_i)->UnPack(_resolver));
      }
    }
  }
  {
    auto _e = signature_key();
    if (_e)
      _o->signature_key = _e->str();
  }
  {
    auto _e = subgraph_index();
    _o->subgraph_index = _e;
  }
}

inline flatbuffers::Offset<SignatureDef>
SignatureDef::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SignatureDefT *_o,
                   const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateSignatureDef(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SignatureDef>
CreateSignatureDef(flatbuffers::FlatBufferBuilder &_fbb, const SignatureDefT *_o,
                   const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const SignatureDefT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _inputs =
    _o->inputs.size()
      ? _fbb.CreateVector<flatbuffers::Offset<circle::TensorMap>>(
          _o->inputs.size(),
          [](size_t i, _VectorArgs *__va) {
            return CreateTensorMap(*__va->__fbb, __va->__o->inputs[i].get(), __va->__rehasher);
          },
          &_va)
      : 0;
  auto _outputs =
    _o->outputs.size()
      ? _fbb.CreateVector<flatbuffers::Offset<circle::TensorMap>>(
          _o->outputs.size(),
          [](size_t i, _VectorArgs *__va) {
            return CreateTensorMap(*__va->__fbb, __va->__o->outputs[i].get(), __va->__rehasher);
          },
          &_va)
      : 0;
  auto _signature_key = _o->signature_key.empty() ? 0 : _fbb.CreateString(_o->signature_key);
  auto _subgraph_index = _o->subgraph_index;
  return circle::CreateSignatureDef(_fbb, _inputs, _outputs, _signature_key, _subgraph_index);
}

inline ModelT *Model::UnPack(const flatbuffers::resolver_function_t *_resolver) const
{
  auto _o = std::unique_ptr<ModelT>(new ModelT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Model::UnPackTo(ModelT *_o, const flatbuffers::resolver_function_t *_resolver) const
{
  (void)_o;
  (void)_resolver;
  {
    auto _e = version();
    _o->version = _e;
  }
  {
    auto _e = operator_codes();
    if (_e)
    {
      _o->operator_codes.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
      {
        _o->operator_codes[_i] =
          std::unique_ptr<circle::OperatorCodeT>(_e->Get(_i)->UnPack(_resolver));
      }
    }
  }
  {
    auto _e = subgraphs();
    if (_e)
    {
      _o->subgraphs.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
      {
        _o->subgraphs[_i] = std::unique_ptr<circle::SubGraphT>(_e->Get(_i)->UnPack(_resolver));
      }
    }
  }
  {
    auto _e = description();
    if (_e)
      _o->description = _e->str();
  }
  {
    auto _e = buffers();
    if (_e)
    {
      _o->buffers.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
      {
        _o->buffers[_i] = std::unique_ptr<circle::BufferT>(_e->Get(_i)->UnPack(_resolver));
      }
    }
  }
  {
    auto _e = metadata_buffer();
    if (_e)
    {
      _o->metadata_buffer.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
      {
        _o->metadata_buffer[_i] = _e->Get(_i);
      }
    }
  }
  {
    auto _e = metadata();
    if (_e)
    {
      _o->metadata.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
      {
        _o->metadata[_i] = std::unique_ptr<circle::MetadataT>(_e->Get(_i)->UnPack(_resolver));
      }
    }
  }
  {
    auto _e = signature_defs();
    if (_e)
    {
      _o->signature_defs.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
      {
        _o->signature_defs[_i] =
          std::unique_ptr<circle::SignatureDefT>(_e->Get(_i)->UnPack(_resolver));
      }
    }
  }
}

inline flatbuffers::Offset<Model> Model::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                              const ModelT *_o,
                                              const flatbuffers::rehasher_function_t *_rehasher)
{
  return CreateModel(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Model> CreateModel(flatbuffers::FlatBufferBuilder &_fbb,
                                              const ModelT *_o,
                                              const flatbuffers::rehasher_function_t *_rehasher)
{
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs
  {
    flatbuffers::FlatBufferBuilder *__fbb;
    const ModelT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _version = _o->version;
  auto _operator_codes =
    _o->operator_codes.size()
      ? _fbb.CreateVector<flatbuffers::Offset<circle::OperatorCode>>(
          _o->operator_codes.size(),
          [](size_t i, _VectorArgs *__va) {
            return CreateOperatorCode(*__va->__fbb, __va->__o->operator_codes[i].get(),
                                      __va->__rehasher);
          },
          &_va)
      : 0;
  auto _subgraphs =
    _o->subgraphs.size()
      ? _fbb.CreateVector<flatbuffers::Offset<circle::SubGraph>>(
          _o->subgraphs.size(),
          [](size_t i, _VectorArgs *__va) {
            return CreateSubGraph(*__va->__fbb, __va->__o->subgraphs[i].get(), __va->__rehasher);
          },
          &_va)
      : 0;
  auto _description = _o->description.empty() ? 0 : _fbb.CreateString(_o->description);
  auto _buffers =
    _o->buffers.size()
      ? _fbb.CreateVector<flatbuffers::Offset<circle::Buffer>>(
          _o->buffers.size(),
          [](size_t i, _VectorArgs *__va) {
            return CreateBuffer(*__va->__fbb, __va->__o->buffers[i].get(), __va->__rehasher);
          },
          &_va)
      : 0;
  auto _metadata_buffer = _o->metadata_buffer.size() ? _fbb.CreateVector(_o->metadata_buffer) : 0;
  auto _metadata =
    _o->metadata.size()
      ? _fbb.CreateVector<flatbuffers::Offset<circle::Metadata>>(
          _o->metadata.size(),
          [](size_t i, _VectorArgs *__va) {
            return CreateMetadata(*__va->__fbb, __va->__o->metadata[i].get(), __va->__rehasher);
          },
          &_va)
      : 0;
  auto _signature_defs =
    _o->signature_defs.size()
      ? _fbb.CreateVector<flatbuffers::Offset<circle::SignatureDef>>(
          _o->signature_defs.size(),
          [](size_t i, _VectorArgs *__va) {
            return CreateSignatureDef(*__va->__fbb, __va->__o->signature_defs[i].get(),
                                      __va->__rehasher);
          },
          &_va)
      : 0;
  return circle::CreateModel(_fbb, _version, _operator_codes, _subgraphs, _description, _buffers,
                             _metadata_buffer, _metadata, _signature_defs);
}

inline bool VerifyQuantizationDetails(flatbuffers::Verifier &verifier, const void *obj,
                                      QuantizationDetails type)
{
  switch (type)
  {
    case QuantizationDetails_NONE:
    {
      return true;
    }
    case QuantizationDetails_CustomQuantization:
    {
      auto ptr = reinterpret_cast<const circle::CustomQuantization *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default:
      return true;
  }
}

inline bool
VerifyQuantizationDetailsVector(flatbuffers::Verifier &verifier,
                                const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
                                const flatbuffers::Vector<uint8_t> *types)
{
  if (!values || !types)
    return !values && !types;
  if (values->size() != types->size())
    return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i)
  {
    if (!VerifyQuantizationDetails(verifier, values->Get(i),
                                   types->GetEnum<QuantizationDetails>(i)))
    {
      return false;
    }
  }
  return true;
}

inline void *QuantizationDetailsUnion::UnPack(const void *obj, QuantizationDetails type,
                                              const flatbuffers::resolver_function_t *resolver)
{
  switch (type)
  {
    case QuantizationDetails_CustomQuantization:
    {
      auto ptr = reinterpret_cast<const circle::CustomQuantization *>(obj);
      return ptr->UnPack(resolver);
    }
    default:
      return nullptr;
  }
}

inline flatbuffers::Offset<void>
QuantizationDetailsUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                               const flatbuffers::rehasher_function_t *_rehasher) const
{
  switch (type)
  {
    case QuantizationDetails_CustomQuantization:
    {
      auto ptr = reinterpret_cast<const circle::CustomQuantizationT *>(value);
      return CreateCustomQuantization(_fbb, ptr, _rehasher).Union();
    }
    default:
      return 0;
  }
}

inline QuantizationDetailsUnion::QuantizationDetailsUnion(const QuantizationDetailsUnion &u)
  : type(u.type), value(nullptr)
{
  switch (type)
  {
    case QuantizationDetails_CustomQuantization:
    {
      value =
        new circle::CustomQuantizationT(*reinterpret_cast<circle::CustomQuantizationT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void QuantizationDetailsUnion::Reset()
{
  switch (type)
  {
    case QuantizationDetails_CustomQuantization:
    {
      auto ptr = reinterpret_cast<circle::CustomQuantizationT *>(value);
      delete ptr;
      break;
    }
    default:
      break;
  }
  value = nullptr;
  type = QuantizationDetails_NONE;
}

inline bool VerifySparseIndexVector(flatbuffers::Verifier &verifier, const void *obj,
                                    SparseIndexVector type)
{
  switch (type)
  {
    case SparseIndexVector_NONE:
    {
      return true;
    }
    case SparseIndexVector_Int32Vector:
    {
      auto ptr = reinterpret_cast<const circle::Int32Vector *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SparseIndexVector_Uint16Vector:
    {
      auto ptr = reinterpret_cast<const circle::Uint16Vector *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SparseIndexVector_Uint8Vector:
    {
      auto ptr = reinterpret_cast<const circle::Uint8Vector *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default:
      return true;
  }
}

inline bool
VerifySparseIndexVectorVector(flatbuffers::Verifier &verifier,
                              const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
                              const flatbuffers::Vector<uint8_t> *types)
{
  if (!values || !types)
    return !values && !types;
  if (values->size() != types->size())
    return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i)
  {
    if (!VerifySparseIndexVector(verifier, values->Get(i), types->GetEnum<SparseIndexVector>(i)))
    {
      return false;
    }
  }
  return true;
}

inline void *SparseIndexVectorUnion::UnPack(const void *obj, SparseIndexVector type,
                                            const flatbuffers::resolver_function_t *resolver)
{
  switch (type)
  {
    case SparseIndexVector_Int32Vector:
    {
      auto ptr = reinterpret_cast<const circle::Int32Vector *>(obj);
      return ptr->UnPack(resolver);
    }
    case SparseIndexVector_Uint16Vector:
    {
      auto ptr = reinterpret_cast<const circle::Uint16Vector *>(obj);
      return ptr->UnPack(resolver);
    }
    case SparseIndexVector_Uint8Vector:
    {
      auto ptr = reinterpret_cast<const circle::Uint8Vector *>(obj);
      return ptr->UnPack(resolver);
    }
    default:
      return nullptr;
  }
}

inline flatbuffers::Offset<void>
SparseIndexVectorUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                             const flatbuffers::rehasher_function_t *_rehasher) const
{
  switch (type)
  {
    case SparseIndexVector_Int32Vector:
    {
      auto ptr = reinterpret_cast<const circle::Int32VectorT *>(value);
      return CreateInt32Vector(_fbb, ptr, _rehasher).Union();
    }
    case SparseIndexVector_Uint16Vector:
    {
      auto ptr = reinterpret_cast<const circle::Uint16VectorT *>(value);
      return CreateUint16Vector(_fbb, ptr, _rehasher).Union();
    }
    case SparseIndexVector_Uint8Vector:
    {
      auto ptr = reinterpret_cast<const circle::Uint8VectorT *>(value);
      return CreateUint8Vector(_fbb, ptr, _rehasher).Union();
    }
    default:
      return 0;
  }
}

inline SparseIndexVectorUnion::SparseIndexVectorUnion(const SparseIndexVectorUnion &u)
  : type(u.type), value(nullptr)
{
  switch (type)
  {
    case SparseIndexVector_Int32Vector:
    {
      value = new circle::Int32VectorT(*reinterpret_cast<circle::Int32VectorT *>(u.value));
      break;
    }
    case SparseIndexVector_Uint16Vector:
    {
      value = new circle::Uint16VectorT(*reinterpret_cast<circle::Uint16VectorT *>(u.value));
      break;
    }
    case SparseIndexVector_Uint8Vector:
    {
      value = new circle::Uint8VectorT(*reinterpret_cast<circle::Uint8VectorT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void SparseIndexVectorUnion::Reset()
{
  switch (type)
  {
    case SparseIndexVector_Int32Vector:
    {
      auto ptr = reinterpret_cast<circle::Int32VectorT *>(value);
      delete ptr;
      break;
    }
    case SparseIndexVector_Uint16Vector:
    {
      auto ptr = reinterpret_cast<circle::Uint16VectorT *>(value);
      delete ptr;
      break;
    }
    case SparseIndexVector_Uint8Vector:
    {
      auto ptr = reinterpret_cast<circle::Uint8VectorT *>(value);
      delete ptr;
      break;
    }
    default:
      break;
  }
  value = nullptr;
  type = SparseIndexVector_NONE;
}

inline bool VerifyBuiltinOptions(flatbuffers::Verifier &verifier, const void *obj,
                                 BuiltinOptions type)
{
  switch (type)
  {
    case BuiltinOptions_NONE:
    {
      return true;
    }
    case BuiltinOptions_Conv2DOptions:
    {
      auto ptr = reinterpret_cast<const circle::Conv2DOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DepthwiseConv2DOptions:
    {
      auto ptr = reinterpret_cast<const circle::DepthwiseConv2DOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ConcatEmbeddingsOptions:
    {
      auto ptr = reinterpret_cast<const circle::ConcatEmbeddingsOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LSHProjectionOptions:
    {
      auto ptr = reinterpret_cast<const circle::LSHProjectionOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_Pool2DOptions:
    {
      auto ptr = reinterpret_cast<const circle::Pool2DOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SVDFOptions:
    {
      auto ptr = reinterpret_cast<const circle::SVDFOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_RNNOptions:
    {
      auto ptr = reinterpret_cast<const circle::RNNOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FullyConnectedOptions:
    {
      auto ptr = reinterpret_cast<const circle::FullyConnectedOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SoftmaxOptions:
    {
      auto ptr = reinterpret_cast<const circle::SoftmaxOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ConcatenationOptions:
    {
      auto ptr = reinterpret_cast<const circle::ConcatenationOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_AddOptions:
    {
      auto ptr = reinterpret_cast<const circle::AddOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_L2NormOptions:
    {
      auto ptr = reinterpret_cast<const circle::L2NormOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LocalResponseNormalizationOptions:
    {
      auto ptr = reinterpret_cast<const circle::LocalResponseNormalizationOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LSTMOptions:
    {
      auto ptr = reinterpret_cast<const circle::LSTMOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ResizeBilinearOptions:
    {
      auto ptr = reinterpret_cast<const circle::ResizeBilinearOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_CallOptions:
    {
      auto ptr = reinterpret_cast<const circle::CallOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ReshapeOptions:
    {
      auto ptr = reinterpret_cast<const circle::ReshapeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SkipGramOptions:
    {
      auto ptr = reinterpret_cast<const circle::SkipGramOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SpaceToDepthOptions:
    {
      auto ptr = reinterpret_cast<const circle::SpaceToDepthOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_EmbeddingLookupSparseOptions:
    {
      auto ptr = reinterpret_cast<const circle::EmbeddingLookupSparseOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_MulOptions:
    {
      auto ptr = reinterpret_cast<const circle::MulOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_PadOptions:
    {
      auto ptr = reinterpret_cast<const circle::PadOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_GatherOptions:
    {
      auto ptr = reinterpret_cast<const circle::GatherOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BatchToSpaceNDOptions:
    {
      auto ptr = reinterpret_cast<const circle::BatchToSpaceNDOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SpaceToBatchNDOptions:
    {
      auto ptr = reinterpret_cast<const circle::SpaceToBatchNDOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_TransposeOptions:
    {
      auto ptr = reinterpret_cast<const circle::TransposeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ReducerOptions:
    {
      auto ptr = reinterpret_cast<const circle::ReducerOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SubOptions:
    {
      auto ptr = reinterpret_cast<const circle::SubOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DivOptions:
    {
      auto ptr = reinterpret_cast<const circle::DivOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SqueezeOptions:
    {
      auto ptr = reinterpret_cast<const circle::SqueezeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SequenceRNNOptions:
    {
      auto ptr = reinterpret_cast<const circle::SequenceRNNOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_StridedSliceOptions:
    {
      auto ptr = reinterpret_cast<const circle::StridedSliceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ExpOptions:
    {
      auto ptr = reinterpret_cast<const circle::ExpOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_TopKV2Options:
    {
      auto ptr = reinterpret_cast<const circle::TopKV2Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SplitOptions:
    {
      auto ptr = reinterpret_cast<const circle::SplitOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LogSoftmaxOptions:
    {
      auto ptr = reinterpret_cast<const circle::LogSoftmaxOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_CastOptions:
    {
      auto ptr = reinterpret_cast<const circle::CastOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DequantizeOptions:
    {
      auto ptr = reinterpret_cast<const circle::DequantizeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_MaximumMinimumOptions:
    {
      auto ptr = reinterpret_cast<const circle::MaximumMinimumOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ArgMaxOptions:
    {
      auto ptr = reinterpret_cast<const circle::ArgMaxOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LessOptions:
    {
      auto ptr = reinterpret_cast<const circle::LessOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_NegOptions:
    {
      auto ptr = reinterpret_cast<const circle::NegOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_PadV2Options:
    {
      auto ptr = reinterpret_cast<const circle::PadV2Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_GreaterOptions:
    {
      auto ptr = reinterpret_cast<const circle::GreaterOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_GreaterEqualOptions:
    {
      auto ptr = reinterpret_cast<const circle::GreaterEqualOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LessEqualOptions:
    {
      auto ptr = reinterpret_cast<const circle::LessEqualOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SelectOptions:
    {
      auto ptr = reinterpret_cast<const circle::SelectOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SliceOptions:
    {
      auto ptr = reinterpret_cast<const circle::SliceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_TransposeConvOptions:
    {
      auto ptr = reinterpret_cast<const circle::TransposeConvOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SparseToDenseOptions:
    {
      auto ptr = reinterpret_cast<const circle::SparseToDenseOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_TileOptions:
    {
      auto ptr = reinterpret_cast<const circle::TileOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ExpandDimsOptions:
    {
      auto ptr = reinterpret_cast<const circle::ExpandDimsOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_EqualOptions:
    {
      auto ptr = reinterpret_cast<const circle::EqualOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_NotEqualOptions:
    {
      auto ptr = reinterpret_cast<const circle::NotEqualOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ShapeOptions:
    {
      auto ptr = reinterpret_cast<const circle::ShapeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_PowOptions:
    {
      auto ptr = reinterpret_cast<const circle::PowOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ArgMinOptions:
    {
      auto ptr = reinterpret_cast<const circle::ArgMinOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FakeQuantOptions:
    {
      auto ptr = reinterpret_cast<const circle::FakeQuantOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_PackOptions:
    {
      auto ptr = reinterpret_cast<const circle::PackOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LogicalOrOptions:
    {
      auto ptr = reinterpret_cast<const circle::LogicalOrOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_OneHotOptions:
    {
      auto ptr = reinterpret_cast<const circle::OneHotOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LogicalAndOptions:
    {
      auto ptr = reinterpret_cast<const circle::LogicalAndOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LogicalNotOptions:
    {
      auto ptr = reinterpret_cast<const circle::LogicalNotOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_UnpackOptions:
    {
      auto ptr = reinterpret_cast<const circle::UnpackOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FloorDivOptions:
    {
      auto ptr = reinterpret_cast<const circle::FloorDivOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SquareOptions:
    {
      auto ptr = reinterpret_cast<const circle::SquareOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ZerosLikeOptions:
    {
      auto ptr = reinterpret_cast<const circle::ZerosLikeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FillOptions:
    {
      auto ptr = reinterpret_cast<const circle::FillOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BidirectionalSequenceLSTMOptions:
    {
      auto ptr = reinterpret_cast<const circle::BidirectionalSequenceLSTMOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BidirectionalSequenceRNNOptions:
    {
      auto ptr = reinterpret_cast<const circle::BidirectionalSequenceRNNOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_UnidirectionalSequenceLSTMOptions:
    {
      auto ptr = reinterpret_cast<const circle::UnidirectionalSequenceLSTMOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FloorModOptions:
    {
      auto ptr = reinterpret_cast<const circle::FloorModOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_RangeOptions:
    {
      auto ptr = reinterpret_cast<const circle::RangeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ResizeNearestNeighborOptions:
    {
      auto ptr = reinterpret_cast<const circle::ResizeNearestNeighborOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LeakyReluOptions:
    {
      auto ptr = reinterpret_cast<const circle::LeakyReluOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SquaredDifferenceOptions:
    {
      auto ptr = reinterpret_cast<const circle::SquaredDifferenceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_MirrorPadOptions:
    {
      auto ptr = reinterpret_cast<const circle::MirrorPadOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_AbsOptions:
    {
      auto ptr = reinterpret_cast<const circle::AbsOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SplitVOptions:
    {
      auto ptr = reinterpret_cast<const circle::SplitVOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_UniqueOptions:
    {
      auto ptr = reinterpret_cast<const circle::UniqueOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ReverseV2Options:
    {
      auto ptr = reinterpret_cast<const circle::ReverseV2Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_AddNOptions:
    {
      auto ptr = reinterpret_cast<const circle::AddNOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_GatherNdOptions:
    {
      auto ptr = reinterpret_cast<const circle::GatherNdOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_CosOptions:
    {
      auto ptr = reinterpret_cast<const circle::CosOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_WhereOptions:
    {
      auto ptr = reinterpret_cast<const circle::WhereOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_RankOptions:
    {
      auto ptr = reinterpret_cast<const circle::RankOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ReverseSequenceOptions:
    {
      auto ptr = reinterpret_cast<const circle::ReverseSequenceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_MatrixDiagOptions:
    {
      auto ptr = reinterpret_cast<const circle::MatrixDiagOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_QuantizeOptions:
    {
      auto ptr = reinterpret_cast<const circle::QuantizeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_MatrixSetDiagOptions:
    {
      auto ptr = reinterpret_cast<const circle::MatrixSetDiagOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_HardSwishOptions:
    {
      auto ptr = reinterpret_cast<const circle::HardSwishOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_IfOptions:
    {
      auto ptr = reinterpret_cast<const circle::IfOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_WhileOptions:
    {
      auto ptr = reinterpret_cast<const circle::WhileOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DepthToSpaceOptions:
    {
      auto ptr = reinterpret_cast<const circle::DepthToSpaceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_NonMaxSuppressionV4Options:
    {
      auto ptr = reinterpret_cast<const circle::NonMaxSuppressionV4Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_NonMaxSuppressionV5Options:
    {
      auto ptr = reinterpret_cast<const circle::NonMaxSuppressionV5Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ScatterNdOptions:
    {
      auto ptr = reinterpret_cast<const circle::ScatterNdOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SelectV2Options:
    {
      auto ptr = reinterpret_cast<const circle::SelectV2Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DensifyOptions:
    {
      auto ptr = reinterpret_cast<const circle::DensifyOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SegmentSumOptions:
    {
      auto ptr = reinterpret_cast<const circle::SegmentSumOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BatchMatMulOptions:
    {
      auto ptr = reinterpret_cast<const circle::BatchMatMulOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_CumsumOptions:
    {
      auto ptr = reinterpret_cast<const circle::CumsumOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_CallOnceOptions:
    {
      auto ptr = reinterpret_cast<const circle::CallOnceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BroadcastToOptions:
    {
      auto ptr = reinterpret_cast<const circle::BroadcastToOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_Rfft2dOptions:
    {
      auto ptr = reinterpret_cast<const circle::Rfft2dOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_Conv3DOptions:
    {
      auto ptr = reinterpret_cast<const circle::Conv3DOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_HashtableOptions:
    {
      auto ptr = reinterpret_cast<const circle::HashtableOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_HashtableFindOptions:
    {
      auto ptr = reinterpret_cast<const circle::HashtableFindOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_HashtableImportOptions:
    {
      auto ptr = reinterpret_cast<const circle::HashtableImportOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_HashtableSizeOptions:
    {
      auto ptr = reinterpret_cast<const circle::HashtableSizeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_VarHandleOptions:
    {
      auto ptr = reinterpret_cast<const circle::VarHandleOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ReadVariableOptions:
    {
      auto ptr = reinterpret_cast<const circle::ReadVariableOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_AssignVariableOptions:
    {
      auto ptr = reinterpret_cast<const circle::AssignVariableOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_RandomOptions:
    {
      auto ptr = reinterpret_cast<const circle::RandomOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BCQGatherOptions:
    {
      auto ptr = reinterpret_cast<const circle::BCQGatherOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BCQFullyConnectedOptions:
    {
      auto ptr = reinterpret_cast<const circle::BCQFullyConnectedOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_InstanceNormOptions:
    {
      auto ptr = reinterpret_cast<const circle::InstanceNormOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default:
      return true;
  }
}

inline bool VerifyBuiltinOptionsVector(flatbuffers::Verifier &verifier,
                                       const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
                                       const flatbuffers::Vector<uint8_t> *types)
{
  if (!values || !types)
    return !values && !types;
  if (values->size() != types->size())
    return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i)
  {
    if (!VerifyBuiltinOptions(verifier, values->Get(i), types->GetEnum<BuiltinOptions>(i)))
    {
      return false;
    }
  }
  return true;
}

inline void *BuiltinOptionsUnion::UnPack(const void *obj, BuiltinOptions type,
                                         const flatbuffers::resolver_function_t *resolver)
{
  switch (type)
  {
    case BuiltinOptions_Conv2DOptions:
    {
      auto ptr = reinterpret_cast<const circle::Conv2DOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_DepthwiseConv2DOptions:
    {
      auto ptr = reinterpret_cast<const circle::DepthwiseConv2DOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ConcatEmbeddingsOptions:
    {
      auto ptr = reinterpret_cast<const circle::ConcatEmbeddingsOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LSHProjectionOptions:
    {
      auto ptr = reinterpret_cast<const circle::LSHProjectionOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_Pool2DOptions:
    {
      auto ptr = reinterpret_cast<const circle::Pool2DOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SVDFOptions:
    {
      auto ptr = reinterpret_cast<const circle::SVDFOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_RNNOptions:
    {
      auto ptr = reinterpret_cast<const circle::RNNOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_FullyConnectedOptions:
    {
      auto ptr = reinterpret_cast<const circle::FullyConnectedOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SoftmaxOptions:
    {
      auto ptr = reinterpret_cast<const circle::SoftmaxOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ConcatenationOptions:
    {
      auto ptr = reinterpret_cast<const circle::ConcatenationOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_AddOptions:
    {
      auto ptr = reinterpret_cast<const circle::AddOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_L2NormOptions:
    {
      auto ptr = reinterpret_cast<const circle::L2NormOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LocalResponseNormalizationOptions:
    {
      auto ptr = reinterpret_cast<const circle::LocalResponseNormalizationOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LSTMOptions:
    {
      auto ptr = reinterpret_cast<const circle::LSTMOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ResizeBilinearOptions:
    {
      auto ptr = reinterpret_cast<const circle::ResizeBilinearOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_CallOptions:
    {
      auto ptr = reinterpret_cast<const circle::CallOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ReshapeOptions:
    {
      auto ptr = reinterpret_cast<const circle::ReshapeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SkipGramOptions:
    {
      auto ptr = reinterpret_cast<const circle::SkipGramOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SpaceToDepthOptions:
    {
      auto ptr = reinterpret_cast<const circle::SpaceToDepthOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_EmbeddingLookupSparseOptions:
    {
      auto ptr = reinterpret_cast<const circle::EmbeddingLookupSparseOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_MulOptions:
    {
      auto ptr = reinterpret_cast<const circle::MulOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_PadOptions:
    {
      auto ptr = reinterpret_cast<const circle::PadOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_GatherOptions:
    {
      auto ptr = reinterpret_cast<const circle::GatherOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_BatchToSpaceNDOptions:
    {
      auto ptr = reinterpret_cast<const circle::BatchToSpaceNDOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SpaceToBatchNDOptions:
    {
      auto ptr = reinterpret_cast<const circle::SpaceToBatchNDOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_TransposeOptions:
    {
      auto ptr = reinterpret_cast<const circle::TransposeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ReducerOptions:
    {
      auto ptr = reinterpret_cast<const circle::ReducerOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SubOptions:
    {
      auto ptr = reinterpret_cast<const circle::SubOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_DivOptions:
    {
      auto ptr = reinterpret_cast<const circle::DivOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SqueezeOptions:
    {
      auto ptr = reinterpret_cast<const circle::SqueezeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SequenceRNNOptions:
    {
      auto ptr = reinterpret_cast<const circle::SequenceRNNOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_StridedSliceOptions:
    {
      auto ptr = reinterpret_cast<const circle::StridedSliceOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ExpOptions:
    {
      auto ptr = reinterpret_cast<const circle::ExpOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_TopKV2Options:
    {
      auto ptr = reinterpret_cast<const circle::TopKV2Options *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SplitOptions:
    {
      auto ptr = reinterpret_cast<const circle::SplitOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LogSoftmaxOptions:
    {
      auto ptr = reinterpret_cast<const circle::LogSoftmaxOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_CastOptions:
    {
      auto ptr = reinterpret_cast<const circle::CastOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_DequantizeOptions:
    {
      auto ptr = reinterpret_cast<const circle::DequantizeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_MaximumMinimumOptions:
    {
      auto ptr = reinterpret_cast<const circle::MaximumMinimumOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ArgMaxOptions:
    {
      auto ptr = reinterpret_cast<const circle::ArgMaxOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LessOptions:
    {
      auto ptr = reinterpret_cast<const circle::LessOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_NegOptions:
    {
      auto ptr = reinterpret_cast<const circle::NegOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_PadV2Options:
    {
      auto ptr = reinterpret_cast<const circle::PadV2Options *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_GreaterOptions:
    {
      auto ptr = reinterpret_cast<const circle::GreaterOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_GreaterEqualOptions:
    {
      auto ptr = reinterpret_cast<const circle::GreaterEqualOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LessEqualOptions:
    {
      auto ptr = reinterpret_cast<const circle::LessEqualOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SelectOptions:
    {
      auto ptr = reinterpret_cast<const circle::SelectOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SliceOptions:
    {
      auto ptr = reinterpret_cast<const circle::SliceOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_TransposeConvOptions:
    {
      auto ptr = reinterpret_cast<const circle::TransposeConvOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SparseToDenseOptions:
    {
      auto ptr = reinterpret_cast<const circle::SparseToDenseOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_TileOptions:
    {
      auto ptr = reinterpret_cast<const circle::TileOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ExpandDimsOptions:
    {
      auto ptr = reinterpret_cast<const circle::ExpandDimsOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_EqualOptions:
    {
      auto ptr = reinterpret_cast<const circle::EqualOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_NotEqualOptions:
    {
      auto ptr = reinterpret_cast<const circle::NotEqualOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ShapeOptions:
    {
      auto ptr = reinterpret_cast<const circle::ShapeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_PowOptions:
    {
      auto ptr = reinterpret_cast<const circle::PowOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ArgMinOptions:
    {
      auto ptr = reinterpret_cast<const circle::ArgMinOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_FakeQuantOptions:
    {
      auto ptr = reinterpret_cast<const circle::FakeQuantOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_PackOptions:
    {
      auto ptr = reinterpret_cast<const circle::PackOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LogicalOrOptions:
    {
      auto ptr = reinterpret_cast<const circle::LogicalOrOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_OneHotOptions:
    {
      auto ptr = reinterpret_cast<const circle::OneHotOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LogicalAndOptions:
    {
      auto ptr = reinterpret_cast<const circle::LogicalAndOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LogicalNotOptions:
    {
      auto ptr = reinterpret_cast<const circle::LogicalNotOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_UnpackOptions:
    {
      auto ptr = reinterpret_cast<const circle::UnpackOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_FloorDivOptions:
    {
      auto ptr = reinterpret_cast<const circle::FloorDivOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SquareOptions:
    {
      auto ptr = reinterpret_cast<const circle::SquareOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ZerosLikeOptions:
    {
      auto ptr = reinterpret_cast<const circle::ZerosLikeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_FillOptions:
    {
      auto ptr = reinterpret_cast<const circle::FillOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_BidirectionalSequenceLSTMOptions:
    {
      auto ptr = reinterpret_cast<const circle::BidirectionalSequenceLSTMOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_BidirectionalSequenceRNNOptions:
    {
      auto ptr = reinterpret_cast<const circle::BidirectionalSequenceRNNOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_UnidirectionalSequenceLSTMOptions:
    {
      auto ptr = reinterpret_cast<const circle::UnidirectionalSequenceLSTMOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_FloorModOptions:
    {
      auto ptr = reinterpret_cast<const circle::FloorModOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_RangeOptions:
    {
      auto ptr = reinterpret_cast<const circle::RangeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ResizeNearestNeighborOptions:
    {
      auto ptr = reinterpret_cast<const circle::ResizeNearestNeighborOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LeakyReluOptions:
    {
      auto ptr = reinterpret_cast<const circle::LeakyReluOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SquaredDifferenceOptions:
    {
      auto ptr = reinterpret_cast<const circle::SquaredDifferenceOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_MirrorPadOptions:
    {
      auto ptr = reinterpret_cast<const circle::MirrorPadOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_AbsOptions:
    {
      auto ptr = reinterpret_cast<const circle::AbsOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SplitVOptions:
    {
      auto ptr = reinterpret_cast<const circle::SplitVOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_UniqueOptions:
    {
      auto ptr = reinterpret_cast<const circle::UniqueOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ReverseV2Options:
    {
      auto ptr = reinterpret_cast<const circle::ReverseV2Options *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_AddNOptions:
    {
      auto ptr = reinterpret_cast<const circle::AddNOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_GatherNdOptions:
    {
      auto ptr = reinterpret_cast<const circle::GatherNdOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_CosOptions:
    {
      auto ptr = reinterpret_cast<const circle::CosOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_WhereOptions:
    {
      auto ptr = reinterpret_cast<const circle::WhereOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_RankOptions:
    {
      auto ptr = reinterpret_cast<const circle::RankOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ReverseSequenceOptions:
    {
      auto ptr = reinterpret_cast<const circle::ReverseSequenceOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_MatrixDiagOptions:
    {
      auto ptr = reinterpret_cast<const circle::MatrixDiagOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_QuantizeOptions:
    {
      auto ptr = reinterpret_cast<const circle::QuantizeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_MatrixSetDiagOptions:
    {
      auto ptr = reinterpret_cast<const circle::MatrixSetDiagOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_HardSwishOptions:
    {
      auto ptr = reinterpret_cast<const circle::HardSwishOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_IfOptions:
    {
      auto ptr = reinterpret_cast<const circle::IfOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_WhileOptions:
    {
      auto ptr = reinterpret_cast<const circle::WhileOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_DepthToSpaceOptions:
    {
      auto ptr = reinterpret_cast<const circle::DepthToSpaceOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_NonMaxSuppressionV4Options:
    {
      auto ptr = reinterpret_cast<const circle::NonMaxSuppressionV4Options *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_NonMaxSuppressionV5Options:
    {
      auto ptr = reinterpret_cast<const circle::NonMaxSuppressionV5Options *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ScatterNdOptions:
    {
      auto ptr = reinterpret_cast<const circle::ScatterNdOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SelectV2Options:
    {
      auto ptr = reinterpret_cast<const circle::SelectV2Options *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_DensifyOptions:
    {
      auto ptr = reinterpret_cast<const circle::DensifyOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SegmentSumOptions:
    {
      auto ptr = reinterpret_cast<const circle::SegmentSumOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_BatchMatMulOptions:
    {
      auto ptr = reinterpret_cast<const circle::BatchMatMulOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_CumsumOptions:
    {
      auto ptr = reinterpret_cast<const circle::CumsumOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_CallOnceOptions:
    {
      auto ptr = reinterpret_cast<const circle::CallOnceOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_BroadcastToOptions:
    {
      auto ptr = reinterpret_cast<const circle::BroadcastToOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_Rfft2dOptions:
    {
      auto ptr = reinterpret_cast<const circle::Rfft2dOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_Conv3DOptions:
    {
      auto ptr = reinterpret_cast<const circle::Conv3DOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_HashtableOptions:
    {
      auto ptr = reinterpret_cast<const circle::HashtableOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_HashtableFindOptions:
    {
      auto ptr = reinterpret_cast<const circle::HashtableFindOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_HashtableImportOptions:
    {
      auto ptr = reinterpret_cast<const circle::HashtableImportOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_HashtableSizeOptions:
    {
      auto ptr = reinterpret_cast<const circle::HashtableSizeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_VarHandleOptions:
    {
      auto ptr = reinterpret_cast<const circle::VarHandleOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ReadVariableOptions:
    {
      auto ptr = reinterpret_cast<const circle::ReadVariableOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_AssignVariableOptions:
    {
      auto ptr = reinterpret_cast<const circle::AssignVariableOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_RandomOptions:
    {
      auto ptr = reinterpret_cast<const circle::RandomOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_BCQGatherOptions:
    {
      auto ptr = reinterpret_cast<const circle::BCQGatherOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_BCQFullyConnectedOptions:
    {
      auto ptr = reinterpret_cast<const circle::BCQFullyConnectedOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_InstanceNormOptions:
    {
      auto ptr = reinterpret_cast<const circle::InstanceNormOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    default:
      return nullptr;
  }
}

inline flatbuffers::Offset<void>
BuiltinOptionsUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                          const flatbuffers::rehasher_function_t *_rehasher) const
{
  switch (type)
  {
    case BuiltinOptions_Conv2DOptions:
    {
      auto ptr = reinterpret_cast<const circle::Conv2DOptionsT *>(value);
      return CreateConv2DOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_DepthwiseConv2DOptions:
    {
      auto ptr = reinterpret_cast<const circle::DepthwiseConv2DOptionsT *>(value);
      return CreateDepthwiseConv2DOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ConcatEmbeddingsOptions:
    {
      auto ptr = reinterpret_cast<const circle::ConcatEmbeddingsOptionsT *>(value);
      return CreateConcatEmbeddingsOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LSHProjectionOptions:
    {
      auto ptr = reinterpret_cast<const circle::LSHProjectionOptionsT *>(value);
      return CreateLSHProjectionOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_Pool2DOptions:
    {
      auto ptr = reinterpret_cast<const circle::Pool2DOptionsT *>(value);
      return CreatePool2DOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SVDFOptions:
    {
      auto ptr = reinterpret_cast<const circle::SVDFOptionsT *>(value);
      return CreateSVDFOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_RNNOptions:
    {
      auto ptr = reinterpret_cast<const circle::RNNOptionsT *>(value);
      return CreateRNNOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_FullyConnectedOptions:
    {
      auto ptr = reinterpret_cast<const circle::FullyConnectedOptionsT *>(value);
      return CreateFullyConnectedOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SoftmaxOptions:
    {
      auto ptr = reinterpret_cast<const circle::SoftmaxOptionsT *>(value);
      return CreateSoftmaxOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ConcatenationOptions:
    {
      auto ptr = reinterpret_cast<const circle::ConcatenationOptionsT *>(value);
      return CreateConcatenationOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_AddOptions:
    {
      auto ptr = reinterpret_cast<const circle::AddOptionsT *>(value);
      return CreateAddOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_L2NormOptions:
    {
      auto ptr = reinterpret_cast<const circle::L2NormOptionsT *>(value);
      return CreateL2NormOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LocalResponseNormalizationOptions:
    {
      auto ptr = reinterpret_cast<const circle::LocalResponseNormalizationOptionsT *>(value);
      return CreateLocalResponseNormalizationOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LSTMOptions:
    {
      auto ptr = reinterpret_cast<const circle::LSTMOptionsT *>(value);
      return CreateLSTMOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ResizeBilinearOptions:
    {
      auto ptr = reinterpret_cast<const circle::ResizeBilinearOptionsT *>(value);
      return CreateResizeBilinearOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_CallOptions:
    {
      auto ptr = reinterpret_cast<const circle::CallOptionsT *>(value);
      return CreateCallOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ReshapeOptions:
    {
      auto ptr = reinterpret_cast<const circle::ReshapeOptionsT *>(value);
      return CreateReshapeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SkipGramOptions:
    {
      auto ptr = reinterpret_cast<const circle::SkipGramOptionsT *>(value);
      return CreateSkipGramOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SpaceToDepthOptions:
    {
      auto ptr = reinterpret_cast<const circle::SpaceToDepthOptionsT *>(value);
      return CreateSpaceToDepthOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_EmbeddingLookupSparseOptions:
    {
      auto ptr = reinterpret_cast<const circle::EmbeddingLookupSparseOptionsT *>(value);
      return CreateEmbeddingLookupSparseOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_MulOptions:
    {
      auto ptr = reinterpret_cast<const circle::MulOptionsT *>(value);
      return CreateMulOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_PadOptions:
    {
      auto ptr = reinterpret_cast<const circle::PadOptionsT *>(value);
      return CreatePadOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_GatherOptions:
    {
      auto ptr = reinterpret_cast<const circle::GatherOptionsT *>(value);
      return CreateGatherOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_BatchToSpaceNDOptions:
    {
      auto ptr = reinterpret_cast<const circle::BatchToSpaceNDOptionsT *>(value);
      return CreateBatchToSpaceNDOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SpaceToBatchNDOptions:
    {
      auto ptr = reinterpret_cast<const circle::SpaceToBatchNDOptionsT *>(value);
      return CreateSpaceToBatchNDOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_TransposeOptions:
    {
      auto ptr = reinterpret_cast<const circle::TransposeOptionsT *>(value);
      return CreateTransposeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ReducerOptions:
    {
      auto ptr = reinterpret_cast<const circle::ReducerOptionsT *>(value);
      return CreateReducerOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SubOptions:
    {
      auto ptr = reinterpret_cast<const circle::SubOptionsT *>(value);
      return CreateSubOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_DivOptions:
    {
      auto ptr = reinterpret_cast<const circle::DivOptionsT *>(value);
      return CreateDivOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SqueezeOptions:
    {
      auto ptr = reinterpret_cast<const circle::SqueezeOptionsT *>(value);
      return CreateSqueezeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SequenceRNNOptions:
    {
      auto ptr = reinterpret_cast<const circle::SequenceRNNOptionsT *>(value);
      return CreateSequenceRNNOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_StridedSliceOptions:
    {
      auto ptr = reinterpret_cast<const circle::StridedSliceOptionsT *>(value);
      return CreateStridedSliceOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ExpOptions:
    {
      auto ptr = reinterpret_cast<const circle::ExpOptionsT *>(value);
      return CreateExpOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_TopKV2Options:
    {
      auto ptr = reinterpret_cast<const circle::TopKV2OptionsT *>(value);
      return CreateTopKV2Options(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SplitOptions:
    {
      auto ptr = reinterpret_cast<const circle::SplitOptionsT *>(value);
      return CreateSplitOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LogSoftmaxOptions:
    {
      auto ptr = reinterpret_cast<const circle::LogSoftmaxOptionsT *>(value);
      return CreateLogSoftmaxOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_CastOptions:
    {
      auto ptr = reinterpret_cast<const circle::CastOptionsT *>(value);
      return CreateCastOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_DequantizeOptions:
    {
      auto ptr = reinterpret_cast<const circle::DequantizeOptionsT *>(value);
      return CreateDequantizeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_MaximumMinimumOptions:
    {
      auto ptr = reinterpret_cast<const circle::MaximumMinimumOptionsT *>(value);
      return CreateMaximumMinimumOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ArgMaxOptions:
    {
      auto ptr = reinterpret_cast<const circle::ArgMaxOptionsT *>(value);
      return CreateArgMaxOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LessOptions:
    {
      auto ptr = reinterpret_cast<const circle::LessOptionsT *>(value);
      return CreateLessOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_NegOptions:
    {
      auto ptr = reinterpret_cast<const circle::NegOptionsT *>(value);
      return CreateNegOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_PadV2Options:
    {
      auto ptr = reinterpret_cast<const circle::PadV2OptionsT *>(value);
      return CreatePadV2Options(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_GreaterOptions:
    {
      auto ptr = reinterpret_cast<const circle::GreaterOptionsT *>(value);
      return CreateGreaterOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_GreaterEqualOptions:
    {
      auto ptr = reinterpret_cast<const circle::GreaterEqualOptionsT *>(value);
      return CreateGreaterEqualOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LessEqualOptions:
    {
      auto ptr = reinterpret_cast<const circle::LessEqualOptionsT *>(value);
      return CreateLessEqualOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SelectOptions:
    {
      auto ptr = reinterpret_cast<const circle::SelectOptionsT *>(value);
      return CreateSelectOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SliceOptions:
    {
      auto ptr = reinterpret_cast<const circle::SliceOptionsT *>(value);
      return CreateSliceOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_TransposeConvOptions:
    {
      auto ptr = reinterpret_cast<const circle::TransposeConvOptionsT *>(value);
      return CreateTransposeConvOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SparseToDenseOptions:
    {
      auto ptr = reinterpret_cast<const circle::SparseToDenseOptionsT *>(value);
      return CreateSparseToDenseOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_TileOptions:
    {
      auto ptr = reinterpret_cast<const circle::TileOptionsT *>(value);
      return CreateTileOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ExpandDimsOptions:
    {
      auto ptr = reinterpret_cast<const circle::ExpandDimsOptionsT *>(value);
      return CreateExpandDimsOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_EqualOptions:
    {
      auto ptr = reinterpret_cast<const circle::EqualOptionsT *>(value);
      return CreateEqualOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_NotEqualOptions:
    {
      auto ptr = reinterpret_cast<const circle::NotEqualOptionsT *>(value);
      return CreateNotEqualOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ShapeOptions:
    {
      auto ptr = reinterpret_cast<const circle::ShapeOptionsT *>(value);
      return CreateShapeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_PowOptions:
    {
      auto ptr = reinterpret_cast<const circle::PowOptionsT *>(value);
      return CreatePowOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ArgMinOptions:
    {
      auto ptr = reinterpret_cast<const circle::ArgMinOptionsT *>(value);
      return CreateArgMinOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_FakeQuantOptions:
    {
      auto ptr = reinterpret_cast<const circle::FakeQuantOptionsT *>(value);
      return CreateFakeQuantOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_PackOptions:
    {
      auto ptr = reinterpret_cast<const circle::PackOptionsT *>(value);
      return CreatePackOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LogicalOrOptions:
    {
      auto ptr = reinterpret_cast<const circle::LogicalOrOptionsT *>(value);
      return CreateLogicalOrOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_OneHotOptions:
    {
      auto ptr = reinterpret_cast<const circle::OneHotOptionsT *>(value);
      return CreateOneHotOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LogicalAndOptions:
    {
      auto ptr = reinterpret_cast<const circle::LogicalAndOptionsT *>(value);
      return CreateLogicalAndOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LogicalNotOptions:
    {
      auto ptr = reinterpret_cast<const circle::LogicalNotOptionsT *>(value);
      return CreateLogicalNotOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_UnpackOptions:
    {
      auto ptr = reinterpret_cast<const circle::UnpackOptionsT *>(value);
      return CreateUnpackOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_FloorDivOptions:
    {
      auto ptr = reinterpret_cast<const circle::FloorDivOptionsT *>(value);
      return CreateFloorDivOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SquareOptions:
    {
      auto ptr = reinterpret_cast<const circle::SquareOptionsT *>(value);
      return CreateSquareOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ZerosLikeOptions:
    {
      auto ptr = reinterpret_cast<const circle::ZerosLikeOptionsT *>(value);
      return CreateZerosLikeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_FillOptions:
    {
      auto ptr = reinterpret_cast<const circle::FillOptionsT *>(value);
      return CreateFillOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_BidirectionalSequenceLSTMOptions:
    {
      auto ptr = reinterpret_cast<const circle::BidirectionalSequenceLSTMOptionsT *>(value);
      return CreateBidirectionalSequenceLSTMOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_BidirectionalSequenceRNNOptions:
    {
      auto ptr = reinterpret_cast<const circle::BidirectionalSequenceRNNOptionsT *>(value);
      return CreateBidirectionalSequenceRNNOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_UnidirectionalSequenceLSTMOptions:
    {
      auto ptr = reinterpret_cast<const circle::UnidirectionalSequenceLSTMOptionsT *>(value);
      return CreateUnidirectionalSequenceLSTMOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_FloorModOptions:
    {
      auto ptr = reinterpret_cast<const circle::FloorModOptionsT *>(value);
      return CreateFloorModOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_RangeOptions:
    {
      auto ptr = reinterpret_cast<const circle::RangeOptionsT *>(value);
      return CreateRangeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ResizeNearestNeighborOptions:
    {
      auto ptr = reinterpret_cast<const circle::ResizeNearestNeighborOptionsT *>(value);
      return CreateResizeNearestNeighborOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LeakyReluOptions:
    {
      auto ptr = reinterpret_cast<const circle::LeakyReluOptionsT *>(value);
      return CreateLeakyReluOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SquaredDifferenceOptions:
    {
      auto ptr = reinterpret_cast<const circle::SquaredDifferenceOptionsT *>(value);
      return CreateSquaredDifferenceOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_MirrorPadOptions:
    {
      auto ptr = reinterpret_cast<const circle::MirrorPadOptionsT *>(value);
      return CreateMirrorPadOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_AbsOptions:
    {
      auto ptr = reinterpret_cast<const circle::AbsOptionsT *>(value);
      return CreateAbsOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SplitVOptions:
    {
      auto ptr = reinterpret_cast<const circle::SplitVOptionsT *>(value);
      return CreateSplitVOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_UniqueOptions:
    {
      auto ptr = reinterpret_cast<const circle::UniqueOptionsT *>(value);
      return CreateUniqueOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ReverseV2Options:
    {
      auto ptr = reinterpret_cast<const circle::ReverseV2OptionsT *>(value);
      return CreateReverseV2Options(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_AddNOptions:
    {
      auto ptr = reinterpret_cast<const circle::AddNOptionsT *>(value);
      return CreateAddNOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_GatherNdOptions:
    {
      auto ptr = reinterpret_cast<const circle::GatherNdOptionsT *>(value);
      return CreateGatherNdOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_CosOptions:
    {
      auto ptr = reinterpret_cast<const circle::CosOptionsT *>(value);
      return CreateCosOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_WhereOptions:
    {
      auto ptr = reinterpret_cast<const circle::WhereOptionsT *>(value);
      return CreateWhereOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_RankOptions:
    {
      auto ptr = reinterpret_cast<const circle::RankOptionsT *>(value);
      return CreateRankOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ReverseSequenceOptions:
    {
      auto ptr = reinterpret_cast<const circle::ReverseSequenceOptionsT *>(value);
      return CreateReverseSequenceOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_MatrixDiagOptions:
    {
      auto ptr = reinterpret_cast<const circle::MatrixDiagOptionsT *>(value);
      return CreateMatrixDiagOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_QuantizeOptions:
    {
      auto ptr = reinterpret_cast<const circle::QuantizeOptionsT *>(value);
      return CreateQuantizeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_MatrixSetDiagOptions:
    {
      auto ptr = reinterpret_cast<const circle::MatrixSetDiagOptionsT *>(value);
      return CreateMatrixSetDiagOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_HardSwishOptions:
    {
      auto ptr = reinterpret_cast<const circle::HardSwishOptionsT *>(value);
      return CreateHardSwishOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_IfOptions:
    {
      auto ptr = reinterpret_cast<const circle::IfOptionsT *>(value);
      return CreateIfOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_WhileOptions:
    {
      auto ptr = reinterpret_cast<const circle::WhileOptionsT *>(value);
      return CreateWhileOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_DepthToSpaceOptions:
    {
      auto ptr = reinterpret_cast<const circle::DepthToSpaceOptionsT *>(value);
      return CreateDepthToSpaceOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_NonMaxSuppressionV4Options:
    {
      auto ptr = reinterpret_cast<const circle::NonMaxSuppressionV4OptionsT *>(value);
      return CreateNonMaxSuppressionV4Options(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_NonMaxSuppressionV5Options:
    {
      auto ptr = reinterpret_cast<const circle::NonMaxSuppressionV5OptionsT *>(value);
      return CreateNonMaxSuppressionV5Options(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ScatterNdOptions:
    {
      auto ptr = reinterpret_cast<const circle::ScatterNdOptionsT *>(value);
      return CreateScatterNdOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SelectV2Options:
    {
      auto ptr = reinterpret_cast<const circle::SelectV2OptionsT *>(value);
      return CreateSelectV2Options(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_DensifyOptions:
    {
      auto ptr = reinterpret_cast<const circle::DensifyOptionsT *>(value);
      return CreateDensifyOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SegmentSumOptions:
    {
      auto ptr = reinterpret_cast<const circle::SegmentSumOptionsT *>(value);
      return CreateSegmentSumOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_BatchMatMulOptions:
    {
      auto ptr = reinterpret_cast<const circle::BatchMatMulOptionsT *>(value);
      return CreateBatchMatMulOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_CumsumOptions:
    {
      auto ptr = reinterpret_cast<const circle::CumsumOptionsT *>(value);
      return CreateCumsumOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_CallOnceOptions:
    {
      auto ptr = reinterpret_cast<const circle::CallOnceOptionsT *>(value);
      return CreateCallOnceOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_BroadcastToOptions:
    {
      auto ptr = reinterpret_cast<const circle::BroadcastToOptionsT *>(value);
      return CreateBroadcastToOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_Rfft2dOptions:
    {
      auto ptr = reinterpret_cast<const circle::Rfft2dOptionsT *>(value);
      return CreateRfft2dOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_Conv3DOptions:
    {
      auto ptr = reinterpret_cast<const circle::Conv3DOptionsT *>(value);
      return CreateConv3DOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_HashtableOptions:
    {
      auto ptr = reinterpret_cast<const circle::HashtableOptionsT *>(value);
      return CreateHashtableOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_HashtableFindOptions:
    {
      auto ptr = reinterpret_cast<const circle::HashtableFindOptionsT *>(value);
      return CreateHashtableFindOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_HashtableImportOptions:
    {
      auto ptr = reinterpret_cast<const circle::HashtableImportOptionsT *>(value);
      return CreateHashtableImportOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_HashtableSizeOptions:
    {
      auto ptr = reinterpret_cast<const circle::HashtableSizeOptionsT *>(value);
      return CreateHashtableSizeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_VarHandleOptions:
    {
      auto ptr = reinterpret_cast<const circle::VarHandleOptionsT *>(value);
      return CreateVarHandleOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ReadVariableOptions:
    {
      auto ptr = reinterpret_cast<const circle::ReadVariableOptionsT *>(value);
      return CreateReadVariableOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_AssignVariableOptions:
    {
      auto ptr = reinterpret_cast<const circle::AssignVariableOptionsT *>(value);
      return CreateAssignVariableOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_RandomOptions:
    {
      auto ptr = reinterpret_cast<const circle::RandomOptionsT *>(value);
      return CreateRandomOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_BCQGatherOptions:
    {
      auto ptr = reinterpret_cast<const circle::BCQGatherOptionsT *>(value);
      return CreateBCQGatherOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_BCQFullyConnectedOptions:
    {
      auto ptr = reinterpret_cast<const circle::BCQFullyConnectedOptionsT *>(value);
      return CreateBCQFullyConnectedOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_InstanceNormOptions:
    {
      auto ptr = reinterpret_cast<const circle::InstanceNormOptionsT *>(value);
      return CreateInstanceNormOptions(_fbb, ptr, _rehasher).Union();
    }
    default:
      return 0;
  }
}

inline BuiltinOptionsUnion::BuiltinOptionsUnion(const BuiltinOptionsUnion &u)
  : type(u.type), value(nullptr)
{
  switch (type)
  {
    case BuiltinOptions_Conv2DOptions:
    {
      value = new circle::Conv2DOptionsT(*reinterpret_cast<circle::Conv2DOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_DepthwiseConv2DOptions:
    {
      value = new circle::DepthwiseConv2DOptionsT(
        *reinterpret_cast<circle::DepthwiseConv2DOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ConcatEmbeddingsOptions:
    {
      value = new circle::ConcatEmbeddingsOptionsT(
        *reinterpret_cast<circle::ConcatEmbeddingsOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LSHProjectionOptions:
    {
      value = new circle::LSHProjectionOptionsT(
        *reinterpret_cast<circle::LSHProjectionOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_Pool2DOptions:
    {
      value = new circle::Pool2DOptionsT(*reinterpret_cast<circle::Pool2DOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SVDFOptions:
    {
      value = new circle::SVDFOptionsT(*reinterpret_cast<circle::SVDFOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_RNNOptions:
    {
      value = new circle::RNNOptionsT(*reinterpret_cast<circle::RNNOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_FullyConnectedOptions:
    {
      value = new circle::FullyConnectedOptionsT(
        *reinterpret_cast<circle::FullyConnectedOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SoftmaxOptions:
    {
      value = new circle::SoftmaxOptionsT(*reinterpret_cast<circle::SoftmaxOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ConcatenationOptions:
    {
      value = new circle::ConcatenationOptionsT(
        *reinterpret_cast<circle::ConcatenationOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_AddOptions:
    {
      value = new circle::AddOptionsT(*reinterpret_cast<circle::AddOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_L2NormOptions:
    {
      value = new circle::L2NormOptionsT(*reinterpret_cast<circle::L2NormOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LocalResponseNormalizationOptions:
    {
      value = new circle::LocalResponseNormalizationOptionsT(
        *reinterpret_cast<circle::LocalResponseNormalizationOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LSTMOptions:
    {
      value = new circle::LSTMOptionsT(*reinterpret_cast<circle::LSTMOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ResizeBilinearOptions:
    {
      value = new circle::ResizeBilinearOptionsT(
        *reinterpret_cast<circle::ResizeBilinearOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_CallOptions:
    {
      value = new circle::CallOptionsT(*reinterpret_cast<circle::CallOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ReshapeOptions:
    {
      value = new circle::ReshapeOptionsT(*reinterpret_cast<circle::ReshapeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SkipGramOptions:
    {
      value = new circle::SkipGramOptionsT(*reinterpret_cast<circle::SkipGramOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SpaceToDepthOptions:
    {
      value = new circle::SpaceToDepthOptionsT(
        *reinterpret_cast<circle::SpaceToDepthOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_EmbeddingLookupSparseOptions:
    {
      value = new circle::EmbeddingLookupSparseOptionsT(
        *reinterpret_cast<circle::EmbeddingLookupSparseOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_MulOptions:
    {
      value = new circle::MulOptionsT(*reinterpret_cast<circle::MulOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_PadOptions:
    {
      value = new circle::PadOptionsT(*reinterpret_cast<circle::PadOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_GatherOptions:
    {
      value = new circle::GatherOptionsT(*reinterpret_cast<circle::GatherOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_BatchToSpaceNDOptions:
    {
      value = new circle::BatchToSpaceNDOptionsT(
        *reinterpret_cast<circle::BatchToSpaceNDOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SpaceToBatchNDOptions:
    {
      value = new circle::SpaceToBatchNDOptionsT(
        *reinterpret_cast<circle::SpaceToBatchNDOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_TransposeOptions:
    {
      value =
        new circle::TransposeOptionsT(*reinterpret_cast<circle::TransposeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ReducerOptions:
    {
      value = new circle::ReducerOptionsT(*reinterpret_cast<circle::ReducerOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SubOptions:
    {
      value = new circle::SubOptionsT(*reinterpret_cast<circle::SubOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_DivOptions:
    {
      value = new circle::DivOptionsT(*reinterpret_cast<circle::DivOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SqueezeOptions:
    {
      value = new circle::SqueezeOptionsT(*reinterpret_cast<circle::SqueezeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SequenceRNNOptions:
    {
      value =
        new circle::SequenceRNNOptionsT(*reinterpret_cast<circle::SequenceRNNOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_StridedSliceOptions:
    {
      value = new circle::StridedSliceOptionsT(
        *reinterpret_cast<circle::StridedSliceOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ExpOptions:
    {
      value = new circle::ExpOptionsT(*reinterpret_cast<circle::ExpOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_TopKV2Options:
    {
      value = new circle::TopKV2OptionsT(*reinterpret_cast<circle::TopKV2OptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SplitOptions:
    {
      value = new circle::SplitOptionsT(*reinterpret_cast<circle::SplitOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LogSoftmaxOptions:
    {
      value =
        new circle::LogSoftmaxOptionsT(*reinterpret_cast<circle::LogSoftmaxOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_CastOptions:
    {
      value = new circle::CastOptionsT(*reinterpret_cast<circle::CastOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_DequantizeOptions:
    {
      value =
        new circle::DequantizeOptionsT(*reinterpret_cast<circle::DequantizeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_MaximumMinimumOptions:
    {
      value = new circle::MaximumMinimumOptionsT(
        *reinterpret_cast<circle::MaximumMinimumOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ArgMaxOptions:
    {
      value = new circle::ArgMaxOptionsT(*reinterpret_cast<circle::ArgMaxOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LessOptions:
    {
      value = new circle::LessOptionsT(*reinterpret_cast<circle::LessOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_NegOptions:
    {
      value = new circle::NegOptionsT(*reinterpret_cast<circle::NegOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_PadV2Options:
    {
      value = new circle::PadV2OptionsT(*reinterpret_cast<circle::PadV2OptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_GreaterOptions:
    {
      value = new circle::GreaterOptionsT(*reinterpret_cast<circle::GreaterOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_GreaterEqualOptions:
    {
      value = new circle::GreaterEqualOptionsT(
        *reinterpret_cast<circle::GreaterEqualOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LessEqualOptions:
    {
      value =
        new circle::LessEqualOptionsT(*reinterpret_cast<circle::LessEqualOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SelectOptions:
    {
      value = new circle::SelectOptionsT(*reinterpret_cast<circle::SelectOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SliceOptions:
    {
      value = new circle::SliceOptionsT(*reinterpret_cast<circle::SliceOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_TransposeConvOptions:
    {
      value = new circle::TransposeConvOptionsT(
        *reinterpret_cast<circle::TransposeConvOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SparseToDenseOptions:
    {
      value = new circle::SparseToDenseOptionsT(
        *reinterpret_cast<circle::SparseToDenseOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_TileOptions:
    {
      value = new circle::TileOptionsT(*reinterpret_cast<circle::TileOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ExpandDimsOptions:
    {
      value =
        new circle::ExpandDimsOptionsT(*reinterpret_cast<circle::ExpandDimsOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_EqualOptions:
    {
      value = new circle::EqualOptionsT(*reinterpret_cast<circle::EqualOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_NotEqualOptions:
    {
      value = new circle::NotEqualOptionsT(*reinterpret_cast<circle::NotEqualOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ShapeOptions:
    {
      value = new circle::ShapeOptionsT(*reinterpret_cast<circle::ShapeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_PowOptions:
    {
      value = new circle::PowOptionsT(*reinterpret_cast<circle::PowOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ArgMinOptions:
    {
      value = new circle::ArgMinOptionsT(*reinterpret_cast<circle::ArgMinOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_FakeQuantOptions:
    {
      value =
        new circle::FakeQuantOptionsT(*reinterpret_cast<circle::FakeQuantOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_PackOptions:
    {
      value = new circle::PackOptionsT(*reinterpret_cast<circle::PackOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LogicalOrOptions:
    {
      value =
        new circle::LogicalOrOptionsT(*reinterpret_cast<circle::LogicalOrOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_OneHotOptions:
    {
      value = new circle::OneHotOptionsT(*reinterpret_cast<circle::OneHotOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LogicalAndOptions:
    {
      value =
        new circle::LogicalAndOptionsT(*reinterpret_cast<circle::LogicalAndOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LogicalNotOptions:
    {
      value =
        new circle::LogicalNotOptionsT(*reinterpret_cast<circle::LogicalNotOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_UnpackOptions:
    {
      value = new circle::UnpackOptionsT(*reinterpret_cast<circle::UnpackOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_FloorDivOptions:
    {
      value = new circle::FloorDivOptionsT(*reinterpret_cast<circle::FloorDivOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SquareOptions:
    {
      value = new circle::SquareOptionsT(*reinterpret_cast<circle::SquareOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ZerosLikeOptions:
    {
      value =
        new circle::ZerosLikeOptionsT(*reinterpret_cast<circle::ZerosLikeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_FillOptions:
    {
      value = new circle::FillOptionsT(*reinterpret_cast<circle::FillOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_BidirectionalSequenceLSTMOptions:
    {
      value = new circle::BidirectionalSequenceLSTMOptionsT(
        *reinterpret_cast<circle::BidirectionalSequenceLSTMOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_BidirectionalSequenceRNNOptions:
    {
      value = new circle::BidirectionalSequenceRNNOptionsT(
        *reinterpret_cast<circle::BidirectionalSequenceRNNOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_UnidirectionalSequenceLSTMOptions:
    {
      value = new circle::UnidirectionalSequenceLSTMOptionsT(
        *reinterpret_cast<circle::UnidirectionalSequenceLSTMOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_FloorModOptions:
    {
      value = new circle::FloorModOptionsT(*reinterpret_cast<circle::FloorModOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_RangeOptions:
    {
      value = new circle::RangeOptionsT(*reinterpret_cast<circle::RangeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ResizeNearestNeighborOptions:
    {
      value = new circle::ResizeNearestNeighborOptionsT(
        *reinterpret_cast<circle::ResizeNearestNeighborOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LeakyReluOptions:
    {
      value =
        new circle::LeakyReluOptionsT(*reinterpret_cast<circle::LeakyReluOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SquaredDifferenceOptions:
    {
      value = new circle::SquaredDifferenceOptionsT(
        *reinterpret_cast<circle::SquaredDifferenceOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_MirrorPadOptions:
    {
      value =
        new circle::MirrorPadOptionsT(*reinterpret_cast<circle::MirrorPadOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_AbsOptions:
    {
      value = new circle::AbsOptionsT(*reinterpret_cast<circle::AbsOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SplitVOptions:
    {
      value = new circle::SplitVOptionsT(*reinterpret_cast<circle::SplitVOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_UniqueOptions:
    {
      value = new circle::UniqueOptionsT(*reinterpret_cast<circle::UniqueOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ReverseV2Options:
    {
      value =
        new circle::ReverseV2OptionsT(*reinterpret_cast<circle::ReverseV2OptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_AddNOptions:
    {
      value = new circle::AddNOptionsT(*reinterpret_cast<circle::AddNOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_GatherNdOptions:
    {
      value = new circle::GatherNdOptionsT(*reinterpret_cast<circle::GatherNdOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_CosOptions:
    {
      value = new circle::CosOptionsT(*reinterpret_cast<circle::CosOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_WhereOptions:
    {
      value = new circle::WhereOptionsT(*reinterpret_cast<circle::WhereOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_RankOptions:
    {
      value = new circle::RankOptionsT(*reinterpret_cast<circle::RankOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ReverseSequenceOptions:
    {
      value = new circle::ReverseSequenceOptionsT(
        *reinterpret_cast<circle::ReverseSequenceOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_MatrixDiagOptions:
    {
      value =
        new circle::MatrixDiagOptionsT(*reinterpret_cast<circle::MatrixDiagOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_QuantizeOptions:
    {
      value = new circle::QuantizeOptionsT(*reinterpret_cast<circle::QuantizeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_MatrixSetDiagOptions:
    {
      value = new circle::MatrixSetDiagOptionsT(
        *reinterpret_cast<circle::MatrixSetDiagOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_HardSwishOptions:
    {
      value =
        new circle::HardSwishOptionsT(*reinterpret_cast<circle::HardSwishOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_IfOptions:
    {
      value = new circle::IfOptionsT(*reinterpret_cast<circle::IfOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_WhileOptions:
    {
      value = new circle::WhileOptionsT(*reinterpret_cast<circle::WhileOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_DepthToSpaceOptions:
    {
      value = new circle::DepthToSpaceOptionsT(
        *reinterpret_cast<circle::DepthToSpaceOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_NonMaxSuppressionV4Options:
    {
      value = new circle::NonMaxSuppressionV4OptionsT(
        *reinterpret_cast<circle::NonMaxSuppressionV4OptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_NonMaxSuppressionV5Options:
    {
      value = new circle::NonMaxSuppressionV5OptionsT(
        *reinterpret_cast<circle::NonMaxSuppressionV5OptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ScatterNdOptions:
    {
      value =
        new circle::ScatterNdOptionsT(*reinterpret_cast<circle::ScatterNdOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SelectV2Options:
    {
      value = new circle::SelectV2OptionsT(*reinterpret_cast<circle::SelectV2OptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_DensifyOptions:
    {
      value = new circle::DensifyOptionsT(*reinterpret_cast<circle::DensifyOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SegmentSumOptions:
    {
      value =
        new circle::SegmentSumOptionsT(*reinterpret_cast<circle::SegmentSumOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_BatchMatMulOptions:
    {
      value =
        new circle::BatchMatMulOptionsT(*reinterpret_cast<circle::BatchMatMulOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_CumsumOptions:
    {
      value = new circle::CumsumOptionsT(*reinterpret_cast<circle::CumsumOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_CallOnceOptions:
    {
      value = new circle::CallOnceOptionsT(*reinterpret_cast<circle::CallOnceOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_BroadcastToOptions:
    {
      value =
        new circle::BroadcastToOptionsT(*reinterpret_cast<circle::BroadcastToOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_Rfft2dOptions:
    {
      value = new circle::Rfft2dOptionsT(*reinterpret_cast<circle::Rfft2dOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_Conv3DOptions:
    {
      value = new circle::Conv3DOptionsT(*reinterpret_cast<circle::Conv3DOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_HashtableOptions:
    {
      value =
        new circle::HashtableOptionsT(*reinterpret_cast<circle::HashtableOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_HashtableFindOptions:
    {
      value = new circle::HashtableFindOptionsT(
        *reinterpret_cast<circle::HashtableFindOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_HashtableImportOptions:
    {
      value = new circle::HashtableImportOptionsT(
        *reinterpret_cast<circle::HashtableImportOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_HashtableSizeOptions:
    {
      value = new circle::HashtableSizeOptionsT(
        *reinterpret_cast<circle::HashtableSizeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_VarHandleOptions:
    {
      value =
        new circle::VarHandleOptionsT(*reinterpret_cast<circle::VarHandleOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ReadVariableOptions:
    {
      value = new circle::ReadVariableOptionsT(
        *reinterpret_cast<circle::ReadVariableOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_AssignVariableOptions:
    {
      value = new circle::AssignVariableOptionsT(
        *reinterpret_cast<circle::AssignVariableOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_RandomOptions:
    {
      value = new circle::RandomOptionsT(*reinterpret_cast<circle::RandomOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_BCQGatherOptions:
    {
      value =
        new circle::BCQGatherOptionsT(*reinterpret_cast<circle::BCQGatherOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_BCQFullyConnectedOptions:
    {
      value = new circle::BCQFullyConnectedOptionsT(
        *reinterpret_cast<circle::BCQFullyConnectedOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_InstanceNormOptions:
    {
      value = new circle::InstanceNormOptionsT(
        *reinterpret_cast<circle::InstanceNormOptionsT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void BuiltinOptionsUnion::Reset()
{
  switch (type)
  {
    case BuiltinOptions_Conv2DOptions:
    {
      auto ptr = reinterpret_cast<circle::Conv2DOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_DepthwiseConv2DOptions:
    {
      auto ptr = reinterpret_cast<circle::DepthwiseConv2DOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ConcatEmbeddingsOptions:
    {
      auto ptr = reinterpret_cast<circle::ConcatEmbeddingsOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LSHProjectionOptions:
    {
      auto ptr = reinterpret_cast<circle::LSHProjectionOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_Pool2DOptions:
    {
      auto ptr = reinterpret_cast<circle::Pool2DOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SVDFOptions:
    {
      auto ptr = reinterpret_cast<circle::SVDFOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_RNNOptions:
    {
      auto ptr = reinterpret_cast<circle::RNNOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_FullyConnectedOptions:
    {
      auto ptr = reinterpret_cast<circle::FullyConnectedOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SoftmaxOptions:
    {
      auto ptr = reinterpret_cast<circle::SoftmaxOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ConcatenationOptions:
    {
      auto ptr = reinterpret_cast<circle::ConcatenationOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_AddOptions:
    {
      auto ptr = reinterpret_cast<circle::AddOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_L2NormOptions:
    {
      auto ptr = reinterpret_cast<circle::L2NormOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LocalResponseNormalizationOptions:
    {
      auto ptr = reinterpret_cast<circle::LocalResponseNormalizationOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LSTMOptions:
    {
      auto ptr = reinterpret_cast<circle::LSTMOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ResizeBilinearOptions:
    {
      auto ptr = reinterpret_cast<circle::ResizeBilinearOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_CallOptions:
    {
      auto ptr = reinterpret_cast<circle::CallOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ReshapeOptions:
    {
      auto ptr = reinterpret_cast<circle::ReshapeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SkipGramOptions:
    {
      auto ptr = reinterpret_cast<circle::SkipGramOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SpaceToDepthOptions:
    {
      auto ptr = reinterpret_cast<circle::SpaceToDepthOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_EmbeddingLookupSparseOptions:
    {
      auto ptr = reinterpret_cast<circle::EmbeddingLookupSparseOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_MulOptions:
    {
      auto ptr = reinterpret_cast<circle::MulOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_PadOptions:
    {
      auto ptr = reinterpret_cast<circle::PadOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_GatherOptions:
    {
      auto ptr = reinterpret_cast<circle::GatherOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_BatchToSpaceNDOptions:
    {
      auto ptr = reinterpret_cast<circle::BatchToSpaceNDOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SpaceToBatchNDOptions:
    {
      auto ptr = reinterpret_cast<circle::SpaceToBatchNDOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_TransposeOptions:
    {
      auto ptr = reinterpret_cast<circle::TransposeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ReducerOptions:
    {
      auto ptr = reinterpret_cast<circle::ReducerOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SubOptions:
    {
      auto ptr = reinterpret_cast<circle::SubOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_DivOptions:
    {
      auto ptr = reinterpret_cast<circle::DivOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SqueezeOptions:
    {
      auto ptr = reinterpret_cast<circle::SqueezeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SequenceRNNOptions:
    {
      auto ptr = reinterpret_cast<circle::SequenceRNNOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_StridedSliceOptions:
    {
      auto ptr = reinterpret_cast<circle::StridedSliceOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ExpOptions:
    {
      auto ptr = reinterpret_cast<circle::ExpOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_TopKV2Options:
    {
      auto ptr = reinterpret_cast<circle::TopKV2OptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SplitOptions:
    {
      auto ptr = reinterpret_cast<circle::SplitOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LogSoftmaxOptions:
    {
      auto ptr = reinterpret_cast<circle::LogSoftmaxOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_CastOptions:
    {
      auto ptr = reinterpret_cast<circle::CastOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_DequantizeOptions:
    {
      auto ptr = reinterpret_cast<circle::DequantizeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_MaximumMinimumOptions:
    {
      auto ptr = reinterpret_cast<circle::MaximumMinimumOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ArgMaxOptions:
    {
      auto ptr = reinterpret_cast<circle::ArgMaxOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LessOptions:
    {
      auto ptr = reinterpret_cast<circle::LessOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_NegOptions:
    {
      auto ptr = reinterpret_cast<circle::NegOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_PadV2Options:
    {
      auto ptr = reinterpret_cast<circle::PadV2OptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_GreaterOptions:
    {
      auto ptr = reinterpret_cast<circle::GreaterOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_GreaterEqualOptions:
    {
      auto ptr = reinterpret_cast<circle::GreaterEqualOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LessEqualOptions:
    {
      auto ptr = reinterpret_cast<circle::LessEqualOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SelectOptions:
    {
      auto ptr = reinterpret_cast<circle::SelectOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SliceOptions:
    {
      auto ptr = reinterpret_cast<circle::SliceOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_TransposeConvOptions:
    {
      auto ptr = reinterpret_cast<circle::TransposeConvOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SparseToDenseOptions:
    {
      auto ptr = reinterpret_cast<circle::SparseToDenseOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_TileOptions:
    {
      auto ptr = reinterpret_cast<circle::TileOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ExpandDimsOptions:
    {
      auto ptr = reinterpret_cast<circle::ExpandDimsOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_EqualOptions:
    {
      auto ptr = reinterpret_cast<circle::EqualOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_NotEqualOptions:
    {
      auto ptr = reinterpret_cast<circle::NotEqualOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ShapeOptions:
    {
      auto ptr = reinterpret_cast<circle::ShapeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_PowOptions:
    {
      auto ptr = reinterpret_cast<circle::PowOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ArgMinOptions:
    {
      auto ptr = reinterpret_cast<circle::ArgMinOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_FakeQuantOptions:
    {
      auto ptr = reinterpret_cast<circle::FakeQuantOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_PackOptions:
    {
      auto ptr = reinterpret_cast<circle::PackOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LogicalOrOptions:
    {
      auto ptr = reinterpret_cast<circle::LogicalOrOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_OneHotOptions:
    {
      auto ptr = reinterpret_cast<circle::OneHotOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LogicalAndOptions:
    {
      auto ptr = reinterpret_cast<circle::LogicalAndOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LogicalNotOptions:
    {
      auto ptr = reinterpret_cast<circle::LogicalNotOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_UnpackOptions:
    {
      auto ptr = reinterpret_cast<circle::UnpackOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_FloorDivOptions:
    {
      auto ptr = reinterpret_cast<circle::FloorDivOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SquareOptions:
    {
      auto ptr = reinterpret_cast<circle::SquareOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ZerosLikeOptions:
    {
      auto ptr = reinterpret_cast<circle::ZerosLikeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_FillOptions:
    {
      auto ptr = reinterpret_cast<circle::FillOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_BidirectionalSequenceLSTMOptions:
    {
      auto ptr = reinterpret_cast<circle::BidirectionalSequenceLSTMOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_BidirectionalSequenceRNNOptions:
    {
      auto ptr = reinterpret_cast<circle::BidirectionalSequenceRNNOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_UnidirectionalSequenceLSTMOptions:
    {
      auto ptr = reinterpret_cast<circle::UnidirectionalSequenceLSTMOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_FloorModOptions:
    {
      auto ptr = reinterpret_cast<circle::FloorModOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_RangeOptions:
    {
      auto ptr = reinterpret_cast<circle::RangeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ResizeNearestNeighborOptions:
    {
      auto ptr = reinterpret_cast<circle::ResizeNearestNeighborOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LeakyReluOptions:
    {
      auto ptr = reinterpret_cast<circle::LeakyReluOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SquaredDifferenceOptions:
    {
      auto ptr = reinterpret_cast<circle::SquaredDifferenceOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_MirrorPadOptions:
    {
      auto ptr = reinterpret_cast<circle::MirrorPadOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_AbsOptions:
    {
      auto ptr = reinterpret_cast<circle::AbsOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SplitVOptions:
    {
      auto ptr = reinterpret_cast<circle::SplitVOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_UniqueOptions:
    {
      auto ptr = reinterpret_cast<circle::UniqueOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ReverseV2Options:
    {
      auto ptr = reinterpret_cast<circle::ReverseV2OptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_AddNOptions:
    {
      auto ptr = reinterpret_cast<circle::AddNOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_GatherNdOptions:
    {
      auto ptr = reinterpret_cast<circle::GatherNdOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_CosOptions:
    {
      auto ptr = reinterpret_cast<circle::CosOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_WhereOptions:
    {
      auto ptr = reinterpret_cast<circle::WhereOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_RankOptions:
    {
      auto ptr = reinterpret_cast<circle::RankOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ReverseSequenceOptions:
    {
      auto ptr = reinterpret_cast<circle::ReverseSequenceOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_MatrixDiagOptions:
    {
      auto ptr = reinterpret_cast<circle::MatrixDiagOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_QuantizeOptions:
    {
      auto ptr = reinterpret_cast<circle::QuantizeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_MatrixSetDiagOptions:
    {
      auto ptr = reinterpret_cast<circle::MatrixSetDiagOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_HardSwishOptions:
    {
      auto ptr = reinterpret_cast<circle::HardSwishOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_IfOptions:
    {
      auto ptr = reinterpret_cast<circle::IfOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_WhileOptions:
    {
      auto ptr = reinterpret_cast<circle::WhileOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_DepthToSpaceOptions:
    {
      auto ptr = reinterpret_cast<circle::DepthToSpaceOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_NonMaxSuppressionV4Options:
    {
      auto ptr = reinterpret_cast<circle::NonMaxSuppressionV4OptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_NonMaxSuppressionV5Options:
    {
      auto ptr = reinterpret_cast<circle::NonMaxSuppressionV5OptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ScatterNdOptions:
    {
      auto ptr = reinterpret_cast<circle::ScatterNdOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SelectV2Options:
    {
      auto ptr = reinterpret_cast<circle::SelectV2OptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_DensifyOptions:
    {
      auto ptr = reinterpret_cast<circle::DensifyOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SegmentSumOptions:
    {
      auto ptr = reinterpret_cast<circle::SegmentSumOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_BatchMatMulOptions:
    {
      auto ptr = reinterpret_cast<circle::BatchMatMulOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_CumsumOptions:
    {
      auto ptr = reinterpret_cast<circle::CumsumOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_CallOnceOptions:
    {
      auto ptr = reinterpret_cast<circle::CallOnceOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_BroadcastToOptions:
    {
      auto ptr = reinterpret_cast<circle::BroadcastToOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_Rfft2dOptions:
    {
      auto ptr = reinterpret_cast<circle::Rfft2dOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_Conv3DOptions:
    {
      auto ptr = reinterpret_cast<circle::Conv3DOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_HashtableOptions:
    {
      auto ptr = reinterpret_cast<circle::HashtableOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_HashtableFindOptions:
    {
      auto ptr = reinterpret_cast<circle::HashtableFindOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_HashtableImportOptions:
    {
      auto ptr = reinterpret_cast<circle::HashtableImportOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_HashtableSizeOptions:
    {
      auto ptr = reinterpret_cast<circle::HashtableSizeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_VarHandleOptions:
    {
      auto ptr = reinterpret_cast<circle::VarHandleOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ReadVariableOptions:
    {
      auto ptr = reinterpret_cast<circle::ReadVariableOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_AssignVariableOptions:
    {
      auto ptr = reinterpret_cast<circle::AssignVariableOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_RandomOptions:
    {
      auto ptr = reinterpret_cast<circle::RandomOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_BCQGatherOptions:
    {
      auto ptr = reinterpret_cast<circle::BCQGatherOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_BCQFullyConnectedOptions:
    {
      auto ptr = reinterpret_cast<circle::BCQFullyConnectedOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_InstanceNormOptions:
    {
      auto ptr = reinterpret_cast<circle::InstanceNormOptionsT *>(value);
      delete ptr;
      break;
    }
    default:
      break;
  }
  value = nullptr;
  type = BuiltinOptions_NONE;
}

inline const circle::Model *GetModel(const void *buf)
{
  return flatbuffers::GetRoot<circle::Model>(buf);
}

inline const circle::Model *GetSizePrefixedModel(const void *buf)
{
  return flatbuffers::GetSizePrefixedRoot<circle::Model>(buf);
}

inline const char *ModelIdentifier() { return "CIR0"; }

inline bool ModelBufferHasIdentifier(const void *buf)
{
  return flatbuffers::BufferHasIdentifier(buf, ModelIdentifier());
}

inline bool VerifyModelBuffer(flatbuffers::Verifier &verifier)
{
  return verifier.VerifyBuffer<circle::Model>(ModelIdentifier());
}

inline bool VerifySizePrefixedModelBuffer(flatbuffers::Verifier &verifier)
{
  return verifier.VerifySizePrefixedBuffer<circle::Model>(ModelIdentifier());
}

inline const char *ModelExtension() { return "circle"; }

inline void FinishModelBuffer(flatbuffers::FlatBufferBuilder &fbb,
                              flatbuffers::Offset<circle::Model> root)
{
  fbb.Finish(root, ModelIdentifier());
}

inline void FinishSizePrefixedModelBuffer(flatbuffers::FlatBufferBuilder &fbb,
                                          flatbuffers::Offset<circle::Model> root)
{
  fbb.FinishSizePrefixed(root, ModelIdentifier());
}

inline std::unique_ptr<circle::ModelT>
UnPackModel(const void *buf, const flatbuffers::resolver_function_t *res = nullptr)
{
  return std::unique_ptr<circle::ModelT>(GetModel(buf)->UnPack(res));
}

inline std::unique_ptr<circle::ModelT>
UnPackSizePrefixedModel(const void *buf, const flatbuffers::resolver_function_t *res = nullptr)
{
  return std::unique_ptr<circle::ModelT>(GetSizePrefixedModel(buf)->UnPack(res));
}

} // namespace circle

#endif // FLATBUFFERS_GENERATED_SCHEMA_CIRCLE_H_
